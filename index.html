<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>DharmaForge ‚Äî A Strict, Self-Validating Knowledge Modeling Engine - v1.0</title>
    <style>
        :root {
            --bg: #0b0f13;
            --panel: #0f1518; DharmaForge
            --panel-2: #0c1113;
            --muted: #9aa6b0;
            --text: #e6eef6;
            --accent: #4da3ff;
            --glow: rgba(77, 163, 255, 0.12);
            --border: rgba(255, 255, 255, 0.06);
            --danger: #ff6b6b;
            --success: #6ee7b7;
            --reference: #fbbf24;
            --warning: #fbbf24;
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: linear-gradient(180deg, #071018 0%, #0b0f13 100%);
            color: var(--text);
            font-size: 13px
        }

        .app {
            height: 100vh;
            display: flex;
            flex-direction: column
        }

        header {
            padding: 10px 14px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), transparent);
        }

        header h1 {
            flex: 0 0 auto;
        }

        header .nav-buttons {
            flex: 1;
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        header .top-controls {
            flex: 0 0 auto;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        h1 {
            margin: 0;
            font-size: 15px
        }

        .top-controls {
            margin-left: auto;
            display: flex;
            gap: 8px;
            align-items: center
        }

        main {
            flex: 1;
            display: flex;
            gap: 12px;
            padding: 12px;
            box-sizing: border-box;
            min-height: 0
        }

        .pane {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), transparent);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 6px 30px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            min-width: 0;
            overflow: hidden
        }

        .left {
            width: 360px;
            flex: 0 0 360px;
            min-width: 260px;
            max-width: 520px
        }

        .center {
            flex: 1;
            min-width: 360px
        }

        .right {
            width: 340px;
            flex: 0 0 340px;
            min-width: 260px
        }

        .pane .title {
            font-size: 13px;
            color: var(--muted);
            margin-bottom: 8px;
            flex-shrink: 0
        }

        .tree {
            overflow: auto;
            flex: 1;
            padding-right: 6px;
            min-height: 0;
            overflow-x: auto;
            overflow-y: auto
        }

        .template-list {
            overflow: auto;
            flex: 1;
            min-height: 0
        }

        .card-row {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), transparent);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer
        }

        .card-row:hover {
            box-shadow: 0 0 0 6px var(--glow)
        }

        .card-row.selected {
            box-shadow: 0 0 0 8px rgba(77, 163, 255, 0.14);
            outline: 2px solid rgba(77, 163, 255, 0.06)
        }

        .card-name {
            font-weight: 600
        }

        .card-type {
            font-size: 12px;
            color: var(--muted);
            margin-left: 6px
        }

        .field-line {
            display: flex;
            gap: 8px;
            align-items: flex-start;
            padding: 6px;
            border-radius: 6px
        }

        .field-key {
            min-width: 100px;
            max-width: 180px;
            color: var(--muted);
            font-size: 13px;
            word-wrap: break-word;
            flex-shrink: 0
        }

        input[type=text],
        input[type=number],
        select,
        textarea {
            background: #071018;
            border: 1px solid var(--border);
            padding: 6px;
            border-radius: 6px;
            color: var(--text);
            outline: none;
            min-width: 0;
            width: 100%;
            box-sizing: border-box
        }

        select option {
            background: #071018;
            color: var(--text)
        }

        textarea {
            resize: vertical;
            min-height: 60px;
            font-family: inherit
        }

        .valueInputDark {
            background: #061018 !important;
            color: #f6fbff !important;
            border: 1px solid rgba(255, 255, 255, 0.08) !important;
            padding: 6px 8px !important;
            border-radius: 6px !important;
            min-width: 0 !important;
            width: 100% !important;
            box-sizing: border-box !important;
        }

        .muted {
            color: var(--muted)
        }

        .btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.06);
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            color: var(--text)
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed
        }

        .btn.primary {
            background: linear-gradient(90deg, rgba(77, 163, 255, 0.08), rgba(99, 102, 241, 0.06));
            border-color: rgba(77, 163, 255, 0.18)
        }

        .btn.danger {
            border-color: rgba(255, 107, 107, 0.18)
        }

        .small {
            font-size: 12px;
            padding: 6px 8px
        }

        .editor {
            overflow-x: auto;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
            min-width: 0
        }

        .editor-content {
            min-width: max-content;
            padding-right: 20px
        }

        .editor-mode-indicator {
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 12px;
            font-weight: 600;
            display: inline-block
        }

        .editor-mode-hierarchy {
            background: rgba(77, 163, 255, 0.08);
            color: var(--accent);
            border: 1px solid rgba(77, 163, 255, 0.12)
        }

        .editor-mode-library {
            background: rgba(110, 231, 183, 0.08);
            color: var(--success);
            border: 1px solid rgba(110, 231, 183, 0.12)
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 6px
        }

        .field-list {
            margin-top: 8px
        }

        .field-def {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.01);
            margin-bottom: 8px;
            border: 1px solid var(--border)
        }

        /* Static default indicator */
        .field-def.has-default {
            border-left: 3px solid rgba(251, 191, 36, 0.6);
            padding-left: 8px;
            transition: background 0.15s ease;
        }

        .field-def.has-default:hover {
            background: rgba(251, 191, 36, 0.05);
        }

        .search {
            display: flex;
            align-items: center;
            gap: 8px
        }

        .search input {
            flex: 1
        }

        .footer {
            padding: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.02);
            display: flex;
            gap: 8px;
            align-items: center
        }

        .drag-handle {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.06);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            flex-shrink: 0;
            font-size: 10px;
            color: var(--muted)
        }

        .drag-over {
            outline: 2px dashed rgba(77, 163, 255, 0.22) !important;
            background: rgba(77, 163, 255, 0.05) !important
        }

        .list-item {
            border: 1px solid var(--border);
            background: #071018;
            padding: 8px;
            border-radius: 6px;
            color: var(--text);
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px
        }

        .reference-icon {
            color: var(--reference);
            font-size: 14px;
            cursor: help;
            flex-shrink: 0;
        }

        .reference-child {
            border-style: dashed !important;
            border-color: rgba(251, 191, 36, 0.3) !important;
            background: rgba(251, 191, 36, 0.02) !important;
        }

        .tree-root {
            font-family: inherit;
            user-select: none;
            min-width: min-content;
        }

        .tree-node {
            position: relative;
            padding: 6px 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-radius: 6px;
            cursor: pointer;
            min-width: max-content;
        }

        .tree-node:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .tree-node.selected {
            background: rgba(77, 163, 255, 0.08);
            border-radius: 6px;
        }

        .twisty {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--muted);
            flex-shrink: 0
        }

        .twisty:hover {
            color: var(--text);
        }

        .node-label {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
            min-width: 0;
        }

        .tree-branch {
            margin: 0;
            padding: 0;
            list-style: none;
            position: relative;
        }

        .tree-branch>li {
            position: relative;
            padding-left: 18px;
        }

        .tree-branch>li::before {
            content: "";
            position: absolute;
            left: 6px;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(255, 255, 255, 0.03);
        }

        .tree-branch>li>.tree-node::before {
            content: "";
            position: absolute;
            left: 6px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 1px;
            background: rgba(255, 255, 255, 0.03);
        }

        .tree-branch>li:last-child::before {
            bottom: 50%;
        }

        .instance-card {
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.01);
            margin-left: 0 !important;
            min-width: max-content;
            box-sizing: border-box;
        }

        .instance-card.deleted-template {
            border-color: var(--border);
            opacity: 0.8;
        }

        .instance-card.deleted-template .instance-header {
            background: rgba(128, 128, 128, 0.1);
        }

        .instance-card.static-child {
            border-color: rgba(167, 139, 250, 0.2);
            background: rgba(167, 139, 250, 0.02);
        }

        .instance-card.reference-child {
            border-style: dashed;
            border-color: rgba(251, 191, 36, 0.3);
            background: rgba(251, 191, 36, 0.02);
        }

        .instance-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            border-radius: 6px;
        }

        .instance-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            cursor: pointer;
            min-width: 0;
        }

        .instance-header-left:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .instance-header-actions {
            display: flex;
            gap: 6px;
            flex-shrink: 0;
        }

        .instance-body {
            margin-top: 8px;
            padding-left: 12px;
            border-left: 2px solid rgba(255, 255, 255, 0.03);
            min-width: max-content;
        }

        .instance-body.collapsed {
            display: none;
        }

        .nav-buttons {
            display: flex;
            gap: 4px;
            margin-right: 8px;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            max-width: 500px;
            max-height: 70vh;
            overflow: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        }

        .modal-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .modal-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 400px;
            overflow: auto;
        }

        .modal-item {
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.01);
        }

        .modal-item:hover {
            background: rgba(77, 163, 255, 0.08);
            border-color: rgba(77, 163, 255, 0.2);
        }

        .modal-item:disabled,
        .modal-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .modal-footer {
            margin-top: 16px;
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .warning-banner {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 12px;
            font-size: 12px;
            color: var(--warning);
        }

        /* HARDENING: Validation error banner */
        .error-banner {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 12px;
            font-size: 12px;
            color: var(--danger);
        }

        .entityref-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 4px;
            padding: 4px 8px;
            margin: 2px;
            font-size: 11px;
            color: var(--warning);
        }

        .entityref-chip.broken {
            background: rgba(255, 107, 107, 0.1);
            border-color: rgba(255, 107, 107, 0.3);
            color: var(--danger);
            opacity: 0.7;
            cursor: not-allowed;
        }

        .entityref-chip.broken::before {
            content: '‚ö†Ô∏è ';
            margin-right: 2px;
        }

        /* Override indicator styling */
        .override-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 6px;
            padding: 6px 8px;
            background: rgba(59, 130, 246, 0.05);
            border-left: 2px solid var(--primary);
            border-radius: 3px;
            font-size: 11px;
        }

        .override-badge {
            color: var(--primary);
            font-weight: 600;
        }

        .override-original {
            color: var(--muted);
            flex: 1;
        }

        .entityref-chip .remove {
            cursor: pointer;
            margin-left: 4px;
            font-weight: bold;
        }

        @media(max-width:980px) {
            .left {
                display: none
            }

            .right {
                display: none
            }

            .center {
                flex: 1
            }
        }
    </style>
</head>

<body>
    <div class="app">
        <header>
            <h1>DharmaForge: A Strict, Self-Validating Knowledge Modeling Engine - v1.0</h1>
            <div class="nav-buttons">
                <button id="backBtn" class="btn small" title="Back">‚óÄ</button>
                <button id="forwardBtn" class="btn small" title="Forward">‚ñ∂</button>
            </div>
            <div class="top-controls">
                <button id="undoBtn" class="btn small">Undo (Ctrl+Z)</button>
                <button id="redoBtn" class="btn small">Redo (Ctrl+Y)</button>
                <button id="exportBtn" class="btn small">Export JSON</button>
                <button id="importBtn" class="btn small">Import JSON</button>
                <button id="validateBtn" class="btn small">Validate</button>
                <button id="cleanupOrphansBtn" class="btn small">üßπ Clean Orphans</button>
                <button id="resetBtn" class="btn small">Reset</button>
            </div>
        </header>

        <main>
            <div class="pane left">
                <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
                    <div class="title" style="margin-bottom:0">Instance Hierarchy</div>
                    <label style="display:flex;align-items:center;gap:4px;margin:0;font-size:11px">
                        <input type="checkbox" id="verboseToggle" checked style="width:auto">
                        <span class="muted">Verbose</span>
                    </label>
                </div>
                <div class="tree" id="hierarchy"></div>
                <div class="footer">
                    <div class="muted">Selected: <span id="selectedSummary">‚Äî</span></div>
                </div>
            </div>

            <div class="pane center">
                <div class="title">Workspace</div>
                <div class="editor" id="editor"></div>
            </div>

            <div class="pane right">
                <div style="display:flex;align-items:center;justify-content:space-between;flex-shrink:0">
                    <div class="title">Blueprint Library</div>
                    <button id="newBlueprintBtn" class="btn small primary">+ New</button>
                </div>
                <div class="search" style="margin:8px 0;flex-shrink:0">
                    <input id="templateSearch" type="text" placeholder="Search blueprints" />
                </div>
                <div class="template-list" id="templateList"></div>
            </div>
        </main>
    </div>

    <input id="fileInput" type="file" style="display:none" accept="application/json" />

    <script>
        'use strict';

        // ============================================================================
        // CONSTANTS & ENUMS
        // ============================================================================

        const FIELD_KIND = {
            PRIMITIVE: 'primitive',
            CARD_REF: 'instantiation',
            LIST_OF_CARDS: 'instantiationList',
            ENTITY_REF: 'instanceReference',
            LIST_ENTITY_REF: 'instanceReferenceList'  // ‚Üê ADD THIS LINE
        };

        const FIELD_MODE = {
            CONTAIN: 'contain',
            REFERENCE: 'reference'
        };

        const PRIMITIVE_TYPE = {
            TEXT: 'text',
            NUMBER: 'number'
        };

        const STORAGE_KEY = 'DharmaForge_v1';
        const MAX_UNDO = 200;
        const SCHEMA_VERSION = 8; // HARDENING: Bumped for hardened version

        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================

        /**
         * Generate a new UUID v4.
         */
        function generateUUID() {
            if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                return crypto.randomUUID();
            }
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        /**
         * Deep clone an object using JSON serialization.
         * WARNING: Not suitable for instance hydration (does not regenerate UUIDs).
         */
        function deepClone(obj) {
            return JSON.parse(JSON.stringify(obj));
        }

        /**
         * Check if a value is a valid UUID string.
         */
        function isValidUUID(value) {
            return (
                typeof value === 'string' &&
                /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)
            );
        }

        // ============================================================================
        // TYPE GUARDS
        // ============================================================================

        /**
         * Check if a field is a contain-mode field (creates ownership).
         */
        function isContainField(field) {
            return (
                (field.fieldKind === FIELD_KIND.CARD_REF ||
                    field.fieldKind === FIELD_KIND.LIST_OF_CARDS) &&
                field.fieldMode === FIELD_MODE.CONTAIN
            );
        }

        /**
         * Check if a field is a reference-mode field (non-owning).
         */
        function isReferenceField(field) {
            return (
                (field.fieldKind === FIELD_KIND.CARD_REF ||
                    field.fieldKind === FIELD_KIND.LIST_OF_CARDS) &&
                field.fieldMode === FIELD_MODE.REFERENCE
            );
        }

        /**
         * Check if a field is an instanceReference field (always non-owning).
         */
        function isEntityRefField(field) {
            return field.fieldKind === FIELD_KIND.ENTITY_REF || field.fieldKind === FIELD_KIND.LIST_ENTITY_REF;
        }

        /**
         * DEPRECATED Check if a field is static (defined by template, not instance). DEPRECATED.
         */
        function isFieldStatic(template, field) {
            return false //template.isStatic === true || field.isFieldStatic === true;
        }

        /**
         * Check if an object is a StaticInstanceShape (pre-hydration blueprint).
         * StaticInstanceShape has NO id, NO _parent, NO _parentField.
         */
        function isStaticInstanceShape(obj) {
            return false //(
            //obj !== null &&
            //typeof obj === 'object' &&
            //typeof obj.templateId === 'string' &&
            //typeof obj.fieldValues === 'object' &&
            //obj._isStaticShape === true &&
            //obj.id === undefined
            //);
        }

        // HARDENING: Check if an object is a runtime instance (has ID)
        function isRuntimeInstance(obj) {
            return (
                obj !== null &&
                typeof obj === 'object' &&
                isValidUUID(obj.id) &&
                typeof obj.templateId === 'string' &&
                typeof obj.fieldValues === 'object'
            );
        }

        // ============================================================================
        // STATE MANAGEMENT
        // ============================================================================

        let state = {
            schemaVersion: SCHEMA_VERSION,
            blueprints: [],
            instances: {},
            rootInstanceId: null
        };

        let undoStack = [];
        let redoStack = [];
        let navHistory = [];
        let navHistoryIndex = -1;
        let selected = { kind: 'instance', id: null };
        let collapsed = {};
        let editorCollapsed = {};
        let verboseMode = true;

        // HARDENING: Track validation state
        let lastValidationResult = null;
        let validationWarningsVisible = false;

        // ============================================================================
        // INTEGRITY HELPERS
        // ============================================================================

        // HARDENING: Check if instance exists in registry
        function isInstanceInRegistry(instanceId) {
            return state.instances.hasOwnProperty(instanceId);
        }

        // HARDENING: Collect all reachable instance IDs from containment graph
        function collectReachableInstances() {
            const reachable = new Set();
            const visited = new Set();

            function traverse(instId) {
                if (!instId || visited.has(instId)) return;
                visited.add(instId);

                const inst = state.instances[instId];
                if (!inst) return;

                reachable.add(instId);

                const tpl = findBlueprintById(inst.templateId);
                if (!tpl) return;

                for (const field of tpl.fields) {
                    if (!isContainField(field)) continue;

                    const val = inst.fieldValues[field.id];
                    if (!val) continue;

                    // FIXED: Contain mode now stores IDs (strings), not objects
                    if (field.fieldKind === FIELD_KIND.CARD_REF) {
                        if (typeof val === 'string') {
                            traverse(val);
                        }
                    } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                        if (Array.isArray(val)) {
                            for (const childId of val) {
                                if (typeof childId === 'string') {
                                    traverse(childId);
                                }
                            }
                        }
                    }
                }
            }  // ‚Üê This closing brace was missing

            if (state.rootInstanceId) {
                traverse(state.rootInstanceId);
            }

            return reachable;
        }

        // HARDENING: Check for duplicate IDs in state (registry only)
        function findDuplicateIds() {
            const registryIds = Object.keys(state.instances);
            const uniqueIds = new Set(registryIds);

            // Check if any registry key points to an instance with a different ID
            const idMismatches = [];
            for (const registryKey in state.instances) {
                const inst = state.instances[registryKey];
                if (inst && inst.id && inst.id !== registryKey) {
                    idMismatches.push({
                        registryKey: registryKey,
                        instanceId: inst.id
                    });
                }
            }

            if (idMismatches.length > 0) {
                console.error('Registry key/instance ID mismatches:', idMismatches);
                return idMismatches.map(m => m.instanceId);
            }

            // JavaScript objects cannot have duplicate keys, so if we got here, no duplicates
            return [];
        }

        // HARDENING: Check if an instance has multiple owners
        function findMultiOwnership() {
            const ownershipMap = new Map(); // instanceId -> array of parent references

            function scanInstance(inst, parentId, parentFieldId) {
                if (!inst || !inst.id) return;

                if (!ownershipMap.has(inst.id)) {
                    ownershipMap.set(inst.id, []);
                }

                if (parentId && parentFieldId) {
                    ownershipMap.get(inst.id).push({ parentId, parentFieldId });
                }

                const tpl = findBlueprintById(inst.templateId);
                if (!tpl) return;

                for (const field of tpl.fields) {
                    if (!isContainField(field)) continue;

                    const val = inst.fieldValues[field.id];
                    if (!val) continue;

                    if (field.fieldKind === FIELD_KIND.CARD_REF && val.id) {
                        scanInstance(val, inst.id, field.id);
                    } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS && Array.isArray(val)) {
                        for (const child of val) {
                            scanInstance(child, inst.id, field.id);
                        }
                    }
                }
            }

            if (state.rootInstanceId) {
                const root = state.instances[state.rootInstanceId];
                if (root) scanInstance(root, null, null);
            }

            const violations = [];
            for (const [instId, owners] of ownershipMap.entries()) {
                if (owners.length > 1) {
                    violations.push({
                        instanceId: instId,
                        owners: owners
                    });
                }
            }

            return violations;
        }

        // HARDENING: Get all descendant IDs of an instance (for cycle prevention)
        function getDescendantIds(instanceId) {
            const descendants = new Set();
            const visited = new Set();

            function traverse(instId) {
                if (!instId || visited.has(instId)) return;
                visited.add(instId);

                const inst = state.instances[instId];
                if (!inst) return;

                descendants.add(instId);

                const tpl = findBlueprintById(inst.templateId);
                if (!tpl) return;

                for (const field of tpl.fields) {
                    if (!isContainField(field)) continue;

                    const val = inst.fieldValues[field.id];
                    if (!val) continue;

                    if (field.fieldKind === FIELD_KIND.CARD_REF && val.id) {
                        traverse(val.id);
                    } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS && Array.isArray(val)) {
                        for (const child of val) {
                            if (child?.id) traverse(child.id);
                        }
                    }
                }
            }

            traverse(instanceId);
            descendants.delete(instanceId); // Don't include self

            return descendants;
        }

        // HARDENING: Check if template has any instances depending on it
        function getBlueprintInstanceCount(templateId) {
            let count = 0;
            for (const instId in state.instances) {
                if (state.instances[instId].templateId === templateId) {
                    count++;
                }
            }
            return count;
        }

        // HARDENING: Check if field has owned children
        function getFieldOwnedChildrenCount(templateId, fieldId) {
            let count = 0;

            for (const instId in state.instances) {
                const inst = state.instances[instId];
                if (inst.templateId !== templateId) continue;

                const val = inst.fieldValues[fieldId];
                if (!val) continue;

                const tpl = findBlueprintById(templateId);
                if (!tpl) continue;

                const field = tpl.fields.find(f => f.id === fieldId);
                if (!field || !isContainField(field)) continue;

                if (field.fieldKind === FIELD_KIND.CARD_REF && val.id) {
                    count++;
                } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS && Array.isArray(val)) {
                    count += val.filter(c => c?.id).length;
                }
            }

            return count;
        }

        // ============================================================================
        // UNDO/REDO (HARDENED)
        // ============================================================================

        // HARDENING: Push state snapshot with validation
        function pushUndo() {
            undoStack.push(deepClone(state));
            if (undoStack.length > MAX_UNDO) undoStack.shift();
            redoStack = [];
            updateUndoButtons();
        }

        // HARDENING: Undo with post-restore validation
        function undo() {
            if (!undoStack.length) return;

            redoStack.push(deepClone(state));
            state = deepClone(undoStack.pop());

            // HARDENING: Validate restored state
            const validation = validateState();
            if (!validation.valid) {
                console.warn('Undo restored invalid state:', validation.errors);
                showValidationWarning('Undo restored state with issues. Run Validate for details.');
            }

            save();
            renderAll();
            updateUndoButtons();
        }

        // HARDENING: Redo with post-restore validation
        function redo() {
            if (!redoStack.length) return;

            undoStack.push(deepClone(state));
            state = deepClone(redoStack.pop());

            // HARDENING: Validate restored state
            const validation = validateState();
            if (!validation.valid) {
                console.warn('Redo restored invalid state:', validation.errors);
                showValidationWarning('Redo restored state with issues. Run Validate for details.');
            }

            save();
            renderAll();
            updateUndoButtons();
        }

        function updateUndoButtons() {
            document.getElementById('undoBtn').disabled = undoStack.length === 0;
            document.getElementById('redoBtn').disabled = redoStack.length === 0;
        }

        // ============================================================================
        // PERSISTENCE (HARDENED)
        // ============================================================================

        function save() {
            console.log('üíæ SAVE() called from:', new Error().stack.split('\n')[2]);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
        }

        function load() {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return false;
            try {
                state = JSON.parse(raw);
                migrateState(state);

                // HARDENING: Ensure all field values match their field kinds
                // HARDENING: Ensure all field values match their field kinds + normalize to IDs
                for (const instId in state.instances) {
                    const inst = state.instances[instId];
                    const tpl = state.blueprints.find(t => t.id === inst.templateId);
                    if (!tpl) continue;

                    for (const field of tpl.fields || []) {
                        if (!inst.fieldValues) inst.fieldValues = {};
                        const val = inst.fieldValues[field.id];

                        // FIXED: Normalize contain-mode fields to store IDs (migration from old format)
                        if (field.fieldKind === FIELD_KIND.CARD_REF) {
                            if (val && typeof val === 'object' && val.id) {
                                // Old format: stored full object, convert to ID
                                inst.fieldValues[field.id] = val.id;
                            } else if (Array.isArray(val)) {
                                // Wrong type: array for single field
                                inst.fieldValues[field.id] = val.length > 0 && val[0]?.id ? val[0].id : null;
                            }
                        }

                        if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                            if (!Array.isArray(val)) {
                                // Wrong type: not an array
                                if (val && typeof val === 'object' && val.id) {
                                    inst.fieldValues[field.id] = [val.id];
                                } else {
                                    inst.fieldValues[field.id] = [];
                                }
                            } else {
                                // Normalize array items to IDs
                                inst.fieldValues[field.id] = val.map(item => {
                                    if (typeof item === 'string') return item; // Already ID
                                    if (item && typeof item === 'object' && item.id) return item.id; // Extract ID
                                    return null;
                                }).filter(id => id !== null);
                            }
                        }

                        // Ensure entity ref fields are arrays of IDs
                        if (field.fieldKind === FIELD_KIND.ENTITY_REF ||
                            field.fieldKind === FIELD_KIND.LIST_ENTITY_REF) {
                            if (!Array.isArray(val)) {
                                inst.fieldValues[field.id] = [];
                            }
                        }
                    }
                }

                save();

                // HARDENING: Validate loaded state
                const validation = validateState();
                if (!validation.valid) {
                    console.warn('Loaded state has validation errors:', validation.errors);
                    showValidationWarning('Loaded state has integrity issues. Run Validate for details.');
                }

                return true;
            } catch (e) {
                console.error('Load error:', e);
                return false;
            }
        }

        function exportJSON() {
            // HARDENING: Validate before export
            const validation = validateState();
            if (!validation.valid) {
                if (!confirm('State has validation errors. Export anyway?\n\nErrors:\n' +
                    validation.errors.slice(0, 5).join('\n') +
                    (validation.errors.length > 5 ? '\n... and more' : ''))) {
                    return;
                }
            }

            const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'DharmaForge_export.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // HARDENING: Import with automatic validation
        function importJSONFile(file) {
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const parsed = JSON.parse(reader.result);

                    if (!Array.isArray(parsed.blueprints)) {
                        alert('Invalid JSON: missing blueprints array');
                        return;
                    }

                    pushUndo();
                    state = parsed;
                    migrateState(state);

                    // HARDENING: Validate imported state
                    const validation = validateState();

                    if (!validation.valid) {
                        const errorReport = [
                            '‚ö†Ô∏è IMPORTED STATE HAS ERRORS:',
                            '',
                            'ERRORS:',
                            ...validation.errors.slice(0, 10),
                            validation.errors.length > 10 ? `... and ${validation.errors.length - 10} more errors` : '',
                            '',
                            validation.warnings.length > 0 ? 'WARNINGS:' : '',
                            ...validation.warnings.slice(0, 5),
                            validation.warnings.length > 5 ? `... and ${validation.warnings.length - 5} more warnings` : '',
                            '',
                            'The import completed, but the state is not valid.',
                            'You may need to fix issues manually or restore from backup.'
                        ].filter(Boolean).join('\n');

                        alert(errorReport);
                        lastValidationResult = validation;
                    } else if (validation.warnings.length > 0) {
                        alert(`Import successful with ${validation.warnings.length} warning(s).\n\nRun Validate to see details.`);
                        lastValidationResult = validation;
                    } else {
                        alert('Import successful - state is valid!');
                        lastValidationResult = null;
                    }

                    save();
                    renderAll();
                } catch (e) {
                    alert('Parse error: ' + e.message);
                }
            };
            reader.readAsText(file);
        }

        function reset() {
            if (confirm('Reset all data? This will delete everything and start fresh.')) {
                localStorage.removeItem(STORAGE_KEY);
                location.reload();
            }
        }

        // HARDENING: Show validation warning banner
        function showValidationWarning(message) {
            validationWarningsVisible = true;
            renderAll();
        }

        // ============================================================================
        // STATE MIGRATION (HARDENED)
        // ============================================================================

        function migrateState(st) {
            // HARDENING: Ensure all reachable instances are in registry
            ensureRegistryConsistency(st);

            // HARDENING: Ensure template static properties exist
            for (const tpl of st.blueprints || []) {
                if (tpl.isStatic === undefined) tpl.isStatic = false;
                if (!tpl.staticValues) tpl.staticValues = {};
            }
        }

        // HARDENING: Ensure all reachable instances are in registry (defensive)
        function ensureRegistryConsistency(st) {
            if (!st.instances) st.instances = {};
            const registryIds = new Set(Object.keys(st.instances));
            const missingFromRegistry = [];

            function scanTree(inst, visited = new Set()) {
                if (!inst || !inst.id) return;
                if (visited.has(inst.id)) return; // HARDENING: Prevent infinite loops
                visited.add(inst.id);

                // HARDENING: Only add if truly missing from registry
                if (!registryIds.has(inst.id)) {
                    missingFromRegistry.push(inst);
                    st.instances[inst.id] = inst;
                    registryIds.add(inst.id);
                }

                const tpl = st.blueprints.find(t => t.id === inst.templateId);
                if (!tpl) return;

                for (const field of tpl.fields || []) {
                    if (!isContainField(field)) continue;
                    const val = inst.fieldValues?.[field.id];
                    if (!val) continue;
                    if (field.fieldKind === FIELD_KIND.CARD_REF && val.id) {
                        scanTree(val, visited);
                    } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS && Array.isArray(val)) {
                        for (const child of val) {
                            if (child?.id) scanTree(child, visited);
                        }
                    }
                }
            }

            if (st.rootInstanceId) {
                const root = st.instances[st.rootInstanceId];
                if (root) scanTree(root);
            }

            if (missingFromRegistry.length > 0) {
                console.warn(`Registry consistency: Added ${missingFromRegistry.length} missing instance(s) to registry`);
            }
        }

        /**
         * Flatten instance tree into registry.
         * HARDENING: Skip instances already in registry to prevent duplicates.
         */
        function flattenInstanceTree(inst, registry, visited = new Set()) {
            if (!inst || !inst.id) return;
            if (visited.has(inst.id)) return; // HARDENING: Cycle protection
            visited.add(inst.id);

            // HARDENING: Only add if not already in registry
            if (!registry[inst.id]) {
                registry[inst.id] = inst;
            }

            const tpl = findBlueprintById(inst.templateId);
            if (!tpl) return;

            for (const field of tpl.fields || []) {
                const val = inst.fieldValues?.[field.id];
                if (!val) continue;

                if (field.fieldKind === FIELD_KIND.CARD_REF && field.fieldMode === FIELD_MODE.CONTAIN) {
                    if (val && typeof val === 'object' && val.id) {
                        flattenInstanceTree(val, registry, visited);
                    }
                } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS && field.fieldMode === FIELD_MODE.CONTAIN) {
                    if (Array.isArray(val)) {
                        for (const child of val) {
                            if (child && typeof child === 'object' && child.id) {
                                flattenInstanceTree(child, registry, visited);
                            }
                        }
                    }
                }
            }
        }

        // ============================================================================
        // TEMPLATE HELPERS
        // ============================================================================

        function findBlueprintById(id) {
            return state.blueprints.find(t => t.id === id);
        }

        function isRootBlueprintId(id) {
            const rt = state.blueprints[0];
            return rt && rt.id === id && rt.type === 'Root';
        }

        function createBlueprint(name = 'New', type = 'Generic') {
            pushUndo();
            const t = {
                id: generateUUID(),
                name,
                type,
                fields: [],
            };
            state.blueprints.push(t);
            save();
            renderAll();
            return t;
        }

        // ============================================================================
        // INSTANCE HELPERS
        // ============================================================================

        function findInstanceById(id) {
            return state.instances[id];
        }

        function getRootInstance() {
            return state.instances[state.rootInstanceId];
        }

        // HARDENING: Register instance with validation
        function registerInstance(inst) {
            if (!inst || !inst.id) {
                console.error('Cannot register instance without ID');
                return;
            }

            if (state.instances[inst.id] && state.instances[inst.id] !== inst) {
                console.warn('Registering instance with duplicate ID:', inst.id);
            }

            state.instances[inst.id] = inst;
        }

        // ============================================================================
        // INSTANCE CREATION
        // ============================================================================

        function createInstance(templateId, parentId = null, parentFieldId = null) {
            const tpl = findBlueprintById(templateId);
            if (!tpl) return null;

            const inst = {
                id: generateUUID(),
                templateId: tpl.id,
                fieldValues: {},
                _parent: parentId,
                _parentField: parentFieldId
            };

            // Initialize field values
            for (const field of tpl.fields) {
                // STATIC REIMPLEMENTATION: Skip primitives with defaults (leave undefined)
                if (tpl.isStatic &&
                    field.fieldKind === FIELD_KIND.PRIMITIVE &&
                    tpl.staticValues?.[field.id] !== undefined &&
                    tpl.staticValues[field.id] !== null &&
                    tpl.staticValues[field.id] !== '') {
                    // Don't initialize - leave undefined to use template default
                    continue;
                }

                // Default initialization for all field kinds
                if (field.fieldKind === FIELD_KIND.PRIMITIVE) {
                    inst.fieldValues[field.id] = field.primitiveType === PRIMITIVE_TYPE.NUMBER ? 0 : '';
                } else if (field.fieldKind === FIELD_KIND.CARD_REF) {
                    inst.fieldValues[field.id] = null;
                } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                    inst.fieldValues[field.id] = [];
                } else if (field.fieldKind === FIELD_KIND.ENTITY_REF) {
                    inst.fieldValues[field.id] = [];
                } else if (field.fieldKind === FIELD_KIND.LIST_ENTITY_REF) {
                    inst.fieldValues[field.id] = [];
                }
            }

            registerInstance(inst);
            return inst;
        }

        // ============================================================================
        // INSTANCE DELETION (HARDENED)
        // ============================================================================

        /**
         * Delete an instance and all owned descendants.
         * Synchronously cleans all references (instanceReference, reference-mode).
         * 
         * INVARIANTS ENFORCED:
         * - Deletion cascades to owned children only
         * - Non-owning references do not block deletion
         * - All references to deleted instances are cleaned
         * - No dangling IDs remain after deletion
         * - Instances removed from registry
         */
        function deleteInstance(instanceId) {
            console.log('üóëÔ∏è deleteInstance called for:', instanceId?.slice(0, 8));

            const inst = findInstanceById(instanceId);
            if (!inst) return;

            // HARDENING: Check if instance is root
            if (instanceId === state.rootInstanceId) {
                alert('Cannot delete root instance');
                return;
            }

            // Step 1: Compute deletion set (owned descendants)
            const deletionSet = new Set();
            const visited = new Set();

            function collectOwnedDescendants(id) {
                if (visited.has(id)) return; // Cycle protection
                visited.add(id);
                deletionSet.add(id);

                const current = findInstanceById(id);
                if (!current) return;

                const tpl = findBlueprintById(current.templateId);
                if (!tpl) return;

                // Traverse only contain-mode children
                for (const field of tpl.fields) {
                    if (!isContainField(field)) continue;

                    const val = current.fieldValues[field.id];
                    if (!val) continue;

                    // FIXED: Contain mode now stores IDs (strings), not objects
                    if (field.fieldKind === FIELD_KIND.CARD_REF) {
                        if (val && typeof val === 'string') {
                            collectOwnedDescendants(val);
                        }
                    } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                        if (Array.isArray(val)) {
                            for (const childId of val) {
                                if (childId && typeof childId === 'string') {
                                    collectOwnedDescendants(childId);
                                }
                            }
                        }
                    }
                }
            }

            collectOwnedDescendants(instanceId);

            // HARDENING: Step 2: Detach from parent containment field
            if (inst._parent) {
                const parent = findInstanceById(inst._parent);
                if (parent && inst._parentField) {
                    const parentTpl = findBlueprintById(parent.templateId);
                    if (parentTpl) {
                        const parentField = parentTpl.fields.find(f => f.id === inst._parentField);
                        if (parentField && isContainField(parentField)) {
                            if (parentField.fieldKind === FIELD_KIND.CARD_REF) {
                                parent.fieldValues[parentField.id] = null;
                            } else if (parentField.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                                const arr = parent.fieldValues[parentField.id];
                                if (Array.isArray(arr)) {
                                    // FIXED: Array contains IDs (strings), not objects
                                    parent.fieldValues[parentField.id] = arr.filter(id => !deletionSet.has(id));
                                }
                            }
                        }
                    }
                }
            }

            // Step 3: Delete all instances in deletion set from registry
            for (const id of deletionSet) {
                delete state.instances[id];
            }

            // Step 4: Clean all references (synchronous)
            try {
                cleanupReferences(deletionSet);
            } catch (err) {
                console.error('üö® cleanupReferences failed:', err);
            }
        }

        /**
         * Clean all references to deleted instance IDs.
         * Scans all instances and removes deleted IDs from:
         * - instanceReference fields (HARDENING: reference removal only, never cascade delete)
         * - reference-mode instantiation fields
         * - reference-mode instantiationList fields
         */
        function cleanupReferences(deletedIds) {
            console.log('üßπ cleanupReferences called with', deletedIds.size, 'deleted IDs:', Array.from(deletedIds));

            for (const instId in state.instances) {
                const inst = state.instances[instId];
                const tpl = findBlueprintById(inst.templateId);
                if (!tpl) continue;

                for (const field of tpl.fields) {
                    if (isFieldStatic(tpl, field)) continue;

                    const val = inst.fieldValues[field.id];

                    // ENTITY_REF and LIST_ENTITY_REF: Do NOT clean broken references
                    // Broken references are valid states - users see ‚ö†Ô∏è broken chips

                    // Clean reference-mode instantiation
                    if (isReferenceField(field) && field.fieldKind === FIELD_KIND.CARD_REF) {
                        if (val && deletedIds.has(val)) {
                            inst.fieldValues[field.id] = null;
                            console.log(`  ‚úÇÔ∏è Cleaned instantiation field "${field.name}" in instance ${instId.slice(0, 8)}`);
                        }
                    }

                    // Clean reference-mode instantiationList
                    if (isReferenceField(field) && field.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                        if (Array.isArray(val)) {
                            const before = val.length;
                            inst.fieldValues[field.id] = val.filter(id => !deletedIds.has(id));
                            const after = inst.fieldValues[field.id].length;
                            if (before !== after) {
                                console.log(`  ‚úÇÔ∏è Cleaned instantiationList field "${field.name}" in instance ${instId.slice(0, 8)}: ${before} ‚Üí ${after} refs`);
                            }
                        }
                    }
                }
            }

            console.log('üßπ cleanupReferences complete');
        }

        // ============================================================================
        // INSTANCE MOVE (REPARENTING) - HARDENED
        // ============================================================================

        /**
         * Move an instance to a new parent (reparenting).
         * This is an explicit, atomic operation.
         * 
         * INVARIANTS ENFORCED:
         * - Instance must exist
         * - New parent must exist
         * - New field must be contain-mode
         * - Cannot create multi-ownership
         * - Cannot create cycles
         * - Operation is atomic (all or nothing)
         * 
         * @param instanceId - Instance to move
         * @param newParentId - New parent instance ID
         * @param newFieldId - Field ID in new parent
         * @returns Success/failure with error message
         */
        function moveInstance(instanceId, newParentId, newFieldId) {
            const inst = findInstanceById(instanceId);
            if (!inst) return { success: false, error: 'Instance not found' };

            const newParent = findInstanceById(newParentId);
            if (!newParent) return { success: false, error: 'New parent not found' };

            const newParentTpl = findBlueprintById(newParent.templateId);
            if (!newParentTpl) return { success: false, error: 'New parent template not found' };

            const newField = newParentTpl.fields.find(f => f.id === newFieldId);
            if (!newField) return { success: false, error: 'New field not found' };

            if (!isContainField(newField)) {
                return { success: false, error: 'New field must be contain-mode' };
            }

            // HARDENING: Prevent moving root
            if (instanceId === state.rootInstanceId) {
                return { success: false, error: 'Cannot move root instance' };
            }

            // HARDENING: Prevent cycle creation (cannot move into own descendants)
            const descendants = getDescendantIds(instanceId);
            if (descendants.has(newParentId)) {
                return { success: false, error: 'Cannot move instance into its own descendant (would create cycle)' };
            }

            // HARDENING: Prevent moving to same parent/field (no-op)
            if (inst._parent === newParentId && inst._parentField === newFieldId) {
                return { success: false, error: 'Instance already in this location' };
            }

            // Check type compatibility
            if (newField.cardTypeFilter) {
                const instTpl = findBlueprintById(inst.templateId);
                if (instTpl && instTpl.type !== newField.cardTypeFilter) {
                    return { success: false, error: `Type mismatch: expected ${newField.cardTypeFilter}, got ${instTpl.type}` };
                }
            }

            // Step 1: Remove from old parent
            if (inst._parent) {
                const oldParent = findInstanceById(inst._parent);
                if (oldParent && inst._parentField) {
                    const oldParentTpl = findBlueprintById(oldParent.templateId);
                    if (oldParentTpl) {
                        const oldField = oldParentTpl.fields.find(f => f.id === inst._parentField);
                        if (oldField) {
                            if (oldField.fieldKind === FIELD_KIND.CARD_REF) {
                                oldParent.fieldValues[oldField.id] = null;
                            } else if (oldField.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                                const arr = oldParent.fieldValues[oldField.id];
                                if (Array.isArray(arr)) {
                                    const idx = arr.indexOf(instanceId);
                                    if (idx >= 0) arr.splice(idx, 1);
                                }
                            }
                        }
                    }
                }
            }

            // Step 2: Add to new parent
            if (newField.fieldKind === FIELD_KIND.CARD_REF) {
                if (newParent.fieldValues[newFieldId]) {
                    return { success: false, error: 'Target instantiation field already occupied' };
                }
                newParent.fieldValues[newFieldId] = inst.id;
            } else if (newField.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                if (!Array.isArray(newParent.fieldValues[newFieldId])) {
                    newParent.fieldValues[newFieldId] = [];
                }
                newParent.fieldValues[newFieldId].push(inst.id);
            }

            // Step 3: Update instance ownership
            inst._parent = newParentId;
            inst._parentField = newFieldId;

            return { success: true };
        }

        // ============================================================================
        // INSTANCE COPY (DEEP CLONE) - HARDENED
        // ============================================================================

        /**
         * Deep copy an instance with fresh UUIDs.
         * Recursively clones all owned descendants.
         * instanceReferences are copied as IDs (pointing to same targets).
         * 
         * INVARIANTS ENFORCED:
         * - All clones receive fresh UUIDs
         * - Ownership structure is preserved
         * - instanceReferences remain IDs (not cloned)
         * - No shared ownership created
         * - All clones registered in state.instances
         * 
         * @param instanceId - Instance to copy
         * @param targetParentId - Target parent instance ID
         * @param targetFieldId - Target field ID in parent
         * @returns New instance or null
         */
        function copyInstance(instanceId, targetParentId, targetFieldId) {
            const inst = findInstanceById(instanceId);
            if (!inst) return null;

            const targetParent = findInstanceById(targetParentId);
            if (!targetParent) return null;

            const targetParentTpl = findBlueprintById(targetParent.templateId);
            if (!targetParentTpl) return null;

            const targetField = targetParentTpl.fields.find(f => f.id === targetFieldId);
            if (!targetField || !isContainField(targetField)) return null;

            // HARDENING: Prevent copying root
            if (instanceId === state.rootInstanceId) {
                alert('Cannot copy root instance');
                return null;
            }

            // Deep clone with fresh UUIDs
            const cloned = deepCloneInstance(inst, targetParentId, targetFieldId);
            if (!cloned) return null;

            // Add to target parent
            if (targetField.fieldKind === FIELD_KIND.CARD_REF) {
                targetParent.fieldValues[targetFieldId] = cloned;
            } else if (targetField.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                if (!Array.isArray(targetParent.fieldValues[targetFieldId])) {
                    targetParent.fieldValues[targetFieldId] = [];
                }
                targetParent.fieldValues[targetFieldId].push(cloned);
            }

            return cloned;
        }

        /**
         * Recursively deep clone an instance with fresh UUIDs.
         * HARDENING: Ensures all clones are registered.
         */
        function deepCloneInstance(inst, newParentId, newParentFieldId) {
            const tpl = findBlueprintById(inst.templateId);
            if (!tpl) return null;

            const cloned = {
                id: generateUUID(), // HARDENING: Always fresh UUID
                templateId: inst.templateId,
                fieldValues: {},
                _parent: newParentId,
                _parentField: newParentFieldId
            };

            // Clone field values
            for (const field of tpl.fields) {
                if (isFieldStatic(tpl, field)) continue;

                const val = inst.fieldValues[field.id];

                if (field.fieldKind === FIELD_KIND.PRIMITIVE) {
                    cloned.fieldValues[field.id] = val;
                } else if (field.fieldKind === FIELD_KIND.CARD_REF) {
                    if (field.fieldMode === FIELD_MODE.CONTAIN) {
                        if (val && val.id) {
                            cloned.fieldValues[field.id] = deepCloneInstance(val, cloned.id, field.id);
                        } else {
                            cloned.fieldValues[field.id] = null;
                        }
                    } else {
                        // Reference mode: copy ID verbatim
                        cloned.fieldValues[field.id] = val;
                    }
                } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                    if (field.fieldMode === FIELD_MODE.CONTAIN) {
                        const arr = [];
                        if (Array.isArray(val)) {
                            for (const child of val) {
                                if (child?.id) {
                                    const childClone = deepCloneInstance(child, cloned.id, field.id);
                                    if (childClone) arr.push(childClone);
                                }
                            }
                        }
                        cloned.fieldValues[field.id] = arr;
                    } else {
                        // Reference mode: copy IDs verbatim
                        cloned.fieldValues[field.id] = Array.isArray(val) ? [...val] : [];
                    }
                } else if (field.fieldKind === FIELD_KIND.ENTITY_REF) {
                    // instanceReference: copy IDs verbatim
                    cloned.fieldValues[field.id] = Array.isArray(val) ? [...val] : [];
                }
            }

            registerInstance(cloned); // HARDENING: Register immediately
            return cloned;
        }

        // ============================================================================
        // VALIDATION (COMPREHENSIVE)
        // ============================================================================

        /**
         * Validate entire state for invariant violations.
         * Returns { valid: boolean, errors: string[], warnings: string[] }
         * 
         * HARDENING: Comprehensive integrity checks
         */
        function validateState() {
            const errors = [];
            const warnings = [];

            // Check root exists
            if (!state.rootInstanceId) {
                errors.push('No root instance defined');
            } else if (!state.instances[state.rootInstanceId]) {
                errors.push('Root instance does not exist in registry');
            }

            // HARDENING: Check for duplicate IDs
            const duplicates = findDuplicateIds();
            if (duplicates.length > 0) {
                errors.push(`Duplicate instance IDs found: ${duplicates.join(', ')}`);
            }

            // HARDENING: Check for multi-ownership
            const multiOwnership = findMultiOwnership();
            if (multiOwnership.length > 0) {
                for (const violation of multiOwnership) {
                    errors.push(
                        `Instance ${violation.instanceId} has multiple owners: ${violation.owners.length} parents`
                    );
                }
            }

            // HARDENING: Check for orphaned instances in registry
            const reachable = collectReachableInstances();
            const registryIds = Object.keys(state.instances);
            const orphaned = registryIds.filter(
                id => id !== state.rootInstanceId && !reachable.has(id)
            );
            if (orphaned.length > 0) {
                warnings.push(
                    `${orphaned.length} orphaned instance(s) in registry (unreachable from root)`
                );
            }

            // Check all instances
            for (const instId in state.instances) {
                const inst = state.instances[instId];

                // Check valid UUID
                if (!isValidUUID(inst.id)) {
                    errors.push(`Instance ${instId} has invalid UUID`);
                }

                // Check template exists
                const tpl = findBlueprintById(inst.templateId);
                if (!tpl) {
                    errors.push(
                        `Instance ${instId} references missing template: ${inst.templateId}`
                    );
                    continue;
                }

                // Check ownership
                if (inst._parent !== null) {
                    if (!isValidUUID(inst._parent)) {
                        errors.push(
                            `Instance ${instId} has invalid parent ID: ${inst._parent}`
                        );
                    }
                    const parent = findInstanceById(inst._parent);
                    if (!parent) {
                        errors.push(
                            `Instance ${instId} references missing parent: ${inst._parent}`
                        );
                    }
                } else if (inst.id !== state.rootInstanceId) {
                    errors.push(
                        `Instance ${instId} has no parent but is not root`
                    );
                }

                // Check field values
                for (const field of tpl.fields) {
                    if (isFieldStatic(tpl, field)) continue;

                    const val = inst.fieldValues[field.id];

                    // Check instanceReference and instanceReferenceList
                    if (isEntityRefField(field)) {
                        if (!Array.isArray(val)) {
                            errors.push(
                                `Instance ${instId}, field ${field.name}: ${field.fieldKind} must be array`
                            );
                        } else {
                            for (const refId of val) {
                                if (!isValidUUID(refId)) {
                                    errors.push(
                                        `Instance ${instId}, field ${field.name}: invalid UUID in ${field.fieldKind}: ${refId}`
                                    );
                                }
                                if (!findInstanceById(refId)) {
                                    warnings.push(
                                        `Instance ${instId}, field ${field.name}: broken ${field.fieldKind} to ${refId}`
                                    );
                                }
                            }

                            // SEMANTIC WARNING: instanceReference ambiguity
                            if (
                                field.fieldKind === FIELD_KIND.ENTITY_REF &&
                                val.length > 1
                            ) {
                                warnings.push(
                                    `Instance ${instId}, field ${field.name}: instanceReference has ${val.length} candidates (ambiguous reference)`
                                );
                            }
                        }
                    }

                    // Check reference-mode fields
                    if (isReferenceField(field)) {
                        if (field.fieldKind === FIELD_KIND.CARD_REF) {
                            if (val !== null && !isValidUUID(val)) {
                                errors.push(
                                    `Instance ${instId}, field ${field.name}: reference instantiation must be UUID or null`
                                );
                            }
                            if (val && !findInstanceById(val)) {
                                warnings.push(
                                    `Instance ${instId}, field ${field.name}: broken reference to ${val}`
                                );
                            }
                        } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                            if (!Array.isArray(val)) {
                                errors.push(
                                    `Instance ${instId}, field ${field.name}: reference instantiationList must be array`
                                );
                            } else {
                                for (const refId of val) {
                                    if (!isValidUUID(refId)) {
                                        errors.push(
                                            `Instance ${instId}, field ${field.name}: invalid UUID in instantiationList: ${refId}`
                                        );
                                    }
                                    if (!findInstanceById(refId)) {
                                        warnings.push(
                                            `Instance ${instId}, field ${field.name}: broken reference to ${refId}`
                                        );
                                    }
                                }
                            }
                        }
                    }

                    // FIXED: Check contain-mode fields (now store IDs like reference mode)
                    if (isContainField(field)) {
                        if (field.fieldKind === FIELD_KIND.CARD_REF) {
                            if (val !== null && !isValidUUID(val)) {
                                errors.push(
                                    `Instance ${instId}, field ${field.name}: contain instantiation must be valid UUID or null`
                                );
                            }
                            if (val && !findInstanceById(val)) {
                                warnings.push(
                                    `Instance ${instId}, field ${field.name}: contain instantiation references missing instance ${val}`
                                );
                            }
                        } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                            if (!Array.isArray(val)) {
                                errors.push(
                                    `Instance ${instId}, field ${field.name}: contain instantiationList must be array`
                                );
                            } else {
                                for (let i = 0; i < val.length; i++) {
                                    if (!isValidUUID(val[i])) {
                                        errors.push(
                                            `Instance ${instId}, field ${field.name}[${i}]: must be valid UUID`
                                        );
                                    }
                                    if (!findInstanceById(val[i])) {
                                        warnings.push(
                                            `Instance ${instId}, field ${field.name}[${i}]: references missing instance ${val[i]}`
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // HARDENING: Check for ownership cycles (treat as corruption)
            const cycleResult = detectOwnershipCycles();
            errors.push(...cycleResult.errors);

            return {
                valid: errors.length === 0,
                errors,
                warnings
            };
        }


        /**
         * Detect ownership cycles in contain-mode graph.
         * HARDENING: Cycles are errors, not warnings.
         */
        function detectOwnershipCycles() {
            const errors = [];
            const visited = new Set();
            const recursionStack = new Set();

            function dfs(instId, path) {
                if (recursionStack.has(instId)) {
                    errors.push(`OWNERSHIP CYCLE: ${path.join(' -> ')} -> ${instId}`);
                    return;
                }
                if (visited.has(instId)) return;

                visited.add(instId);
                recursionStack.add(instId);
                path.push(instId);

                const inst = findInstanceById(instId);
                if (!inst) {
                    path.pop();
                    recursionStack.delete(instId);
                    return;
                }

                const tpl = findBlueprintById(inst.templateId);
                if (tpl) {
                    for (const field of tpl.fields) {
                        if (!isContainField(field)) continue;

                        const val = inst.fieldValues[field.id];
                        if (!val) continue;

                        if (field.fieldKind === FIELD_KIND.CARD_REF && val.id) {
                            dfs(val.id, path);
                        } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS && Array.isArray(val)) {
                            for (const child of val) {
                                if (child?.id) dfs(child.id, path);
                            }
                        }
                    }
                }

                path.pop();
                recursionStack.delete(instId);
            }

            if (state.rootInstanceId) {
                dfs(state.rootInstanceId, []);
            }

            return { errors };
        }

        // ============================================================================
        // FIELD MANAGEMENT (HARDENED)
        // ============================================================================

        function addField(templateId, field) {
            pushUndo();
            const tpl = findBlueprintById(templateId);
            if (!tpl) return;

            tpl.fields.push(field);

            // Initialize field in template static values (primitives only)
            if (tpl.isStatic && field.fieldKind === FIELD_KIND.PRIMITIVE) {
                tpl.staticValues[field.id] = field.primitiveType === PRIMITIVE_TYPE.NUMBER ? 0 : '';
            } else {
                // Initialize in all existing instances
                for (const instId in state.instances) {
                    const inst = state.instances[instId];
                    if (inst.templateId !== templateId) continue;

                    if (field.fieldKind === FIELD_KIND.PRIMITIVE) {
                        inst.fieldValues[field.id] = field.primitiveType === PRIMITIVE_TYPE.NUMBER ? 0 : '';
                    } else if (field.fieldKind === FIELD_KIND.CARD_REF) {
                        inst.fieldValues[field.id] = null;
                    } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                        inst.fieldValues[field.id] = [];
                    } else if (field.fieldKind === FIELD_KIND.ENTITY_REF) {
                        inst.fieldValues[field.id] = [];
                    } else if (field.fieldKind === FIELD_KIND.LIST_ENTITY_REF) {
                        inst.fieldValues[field.id] = [];
                    }
                }
            }

            save();
            renderAll();
        }

        function removeField(templateId, fieldId) {
            pushUndo();
            const tpl = findBlueprintById(templateId);
            if (!tpl) return;

            // Remove field from template
            tpl.fields = tpl.fields.filter(f => f.id !== fieldId);

            // Remove from template static values if exists
            if (tpl.staticValues && tpl.staticValues[fieldId] !== undefined) {
                delete tpl.staticValues[fieldId];
            }

            // Remove field data from all instances of this template
            for (const instId in state.instances) {
                const inst = state.instances[instId];
                if (inst.templateId === templateId && inst.fieldValues[fieldId] !== undefined) {
                    delete inst.fieldValues[fieldId];
                }
            }

            save();
            renderAll();
        }

        // ============================================================================
        // FIELD MANAGEMENT - END
        // ============================================================================

        // ============================================================================
        // NAVIGATION
        // ============================================================================

        function navigateTo(kind, id, addToHistory = true) {
            console.log('üîµ NAVIGATE TO:', kind, id);
            console.log('üîç Active element:', document.activeElement);
            console.log('üîç Tag name:', document.activeElement?.tagName);
            console.log('üîç Is INPUT?:', document.activeElement?.tagName === 'INPUT');

            // Force blur
            if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                console.log('üî• FORCING BLUR');
                document.activeElement.blur();
            } else {
                console.log('‚ö†Ô∏è NOT FORCING BLUR - not an input or no active element');
            }
            if (addToHistory) {
                navHistory = navHistory.slice(0, navHistoryIndex + 1);
                navHistory.push({ kind, id });
                navHistoryIndex = navHistory.length - 1;
            }
            selected = { kind, id };
            renderAll();
            updateNavButtons();
        }

        function navigateBack() {
            if (navHistoryIndex > 0) {
                navHistoryIndex--;
                const loc = navHistory[navHistoryIndex];
                selected = { kind: loc.kind, id: loc.id };
                renderAll();
                updateNavButtons();
            }
        }

        function navigateForward() {
            if (navHistoryIndex < navHistory.length - 1) {
                navHistoryIndex++;
                const loc = navHistory[navHistoryIndex];
                selected = { kind: loc.kind, id: loc.id };
                renderAll();
                updateNavButtons();
            }
        }

        function updateNavButtons() {
            document.getElementById('backBtn').disabled = navHistoryIndex <= 0;
            document.getElementById('forwardBtn').disabled =
                navHistory.length === 0 || navHistoryIndex >= navHistory.length - 1;
        }

        // ============================================================================
        // ENTITY_REF NAVIGATION
        // ============================================================================

        /**
         * Navigate to a referenced instance from an instanceReference chip.
         * 
         * BEHAVIOR:
         * - If target exists: Navigate to it, expand in hierarchy, load in editor
         * - If target missing: No navigation, no error thrown (visual warning only)
         * 
         * @param targetInstanceId - Instance ID to navigate to
         * @returns Boolean indicating whether navigation succeeded
         */
        function handleEntityRefNavigate(targetInstanceId) {
            if (!targetInstanceId) {
                console.warn('handleEntityRefNavigate: No target ID provided');
                return false;
            }

            // Check if target exists in registry
            const targetInstance = findInstanceById(targetInstanceId);

            if (!targetInstance) {
                console.warn(`handleEntityRefNavigate: Target instance not found: ${targetInstanceId}`);
                // UI will show broken reference warning, no action needed here
                return false;
            }

            // Target exists - navigate to it
            console.log(`Navigating to instanceReference target: ${targetInstanceId.slice(0, 8)}`);

            // Expand parent chain in hierarchy (if collapsed)
            expandParentChain(targetInstanceId);

            // Navigate to the instance
            navigateTo('instance', targetInstanceId);

            return true;
        }

        /**
         * Expand all parent nodes in the hierarchy tree to make an instance visible.
         * This ensures the target instance is not hidden by collapsed ancestors.
         * 
         * @param instanceId - Instance ID to make visible
         */
        function expandParentChain(instanceId) {
            const chain = [];
            let currentId = instanceId;

            // Walk up the parent chain
            while (currentId) {
                const inst = findInstanceById(currentId);
                if (!inst) break;

                chain.push(currentId);
                currentId = inst._parent;
            }

            // Expand all ancestors (except the target itself)
            for (let i = chain.length - 1; i > 0; i--) {
                const ancestorId = chain[i];
                if (collapsed[ancestorId]) {
                    collapsed[ancestorId] = false;
                }
            }
        }

        // ============================================================================
        // INSTANCE PICKER MODAL (HARDENED)
        // ============================================================================

        /**
         * Show modal to pick an instance for instanceReference or reference-mode field.
         * HARDENING: Exclude self and descendants to prevent cycles.
         */
        function showInstancePicker(filterType, onSelect, excludeInstanceId = null, showOnlyOrphans = false) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';

            const modal = document.createElement('div');
            modal.className = 'modal';

            const title = document.createElement('div');
            title.className = 'modal-title';
            title.textContent = showOnlyOrphans ?
                'Move Orphaned Instance Here' :
                'Select Instance to Reference';
            modal.appendChild(title);

            const listContainer = document.createElement('div');
            listContainer.className = 'modal-list';

            // HARDENING: Collect exclusion set (self + descendants)
            const exclusionSet = new Set();
            if (excludeInstanceId) {
                exclusionSet.add(excludeInstanceId);
                const descendants = getDescendantIds(excludeInstanceId);
                for (const descId of descendants) {
                    exclusionSet.add(descId);
                }
            }

            // PHASE 1: Optionally filter for orphans only
            const reachable = showOnlyOrphans ? collectReachableInstances() : null;

            // Find matching instances
            const candidates = [];
            for (const instId in state.instances) {
                // HARDENING: Skip excluded instances
                if (exclusionSet.has(instId)) continue;

                const inst = state.instances[instId];
                const tpl = findBlueprintById(inst.templateId);
                if (tpl && tpl.type === filterType) {
                    // PHASE 1: Filter for orphans if requested
                    if (showOnlyOrphans) {
                        if (!reachable.has(instId) && instId !== state.rootInstanceId) {
                            candidates.push(inst);
                        }
                    } else {
                        candidates.push(inst);
                    }
                }
            }

            if (candidates.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'muted';
                empty.textContent = showOnlyOrphans ?
                    `No orphaned instances of type "${filterType}" found.` :
                    `No instances of type "${filterType}" available (excluding self and descendants).`;
                listContainer.appendChild(empty);
            } else {
                for (const inst of candidates) {
                    const item = document.createElement('div');
                    item.className = 'modal-item';
                    const tpl = findBlueprintById(inst.templateId);

                    // Instance labeling: template name
                    const displayLabel = tpl?.name || 'Unknown';

                    item.innerHTML = `
    <div class="card-name">${displayLabel}</div>
    <div class="muted" style="font-size:11px">${inst.id.slice(0, 8)}</div>
  `;
                    item.onclick = () => {
                        onSelect(inst.id);
                        document.body.removeChild(overlay);
                    };
                    listContainer.appendChild(item);
                }
            }

            modal.appendChild(listContainer);

            const footer = document.createElement('div');
            footer.className = 'modal-footer';
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn small';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => document.body.removeChild(overlay);
            footer.appendChild(cancelBtn);
            modal.appendChild(footer);

            overlay.appendChild(modal);
            overlay.onclick = (e) => {
                if (e.target === overlay) document.body.removeChild(overlay);
            };
            document.body.appendChild(overlay);
        }

        // ============================================================================
        // MERGED CHILDREN HELPER
        // ============================================================================

        function getMergedChildrenWithProvenance(template, instance, fieldId) {
            const field = template.fields.find(f => f.id === fieldId);
            if (!field) return [];

            if (!instance) return [];

            const result = [];
            const val = instance.fieldValues[fieldId];
            let children = [];

            if (field.fieldKind === FIELD_KIND.CARD_REF) {
                // FIXED: Both modes now store IDs, resolve to instance
                if (val) {
                    const resolved = findInstanceById(val);
                    if (resolved) children = [resolved];
                }
            } else if (field.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                // FIXED: Both modes now store IDs, resolve to instances
                if (Array.isArray(val)) {
                    children = val.map(id => findInstanceById(id)).filter(Boolean);
                }
            }

            // Add all children with provenance
            for (let i = 0; i < children.length; i++) {
                if (isRuntimeInstance(children[i])) {
                    // FIXED: Determine origin by checking _parent ownership, not field mode
                    const isOwned = children[i]._parent === instance.id;
                    result.push({
                        child: children[i],
                        origin: isOwned ? 'dynamic' : 'reference',
                        dynamicIndex: i
                    });
                }
            }

            return result;
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        /**
         * Initialize sample data if state is empty.
         */
        function initSampleIfEmpty() {
            if (state.blueprints.length > 0 && state.rootInstanceId) return;

            state.blueprints = [];
            state.instances = {};

            const rootT = {
                id: generateUUID(),
                name: 'DharmaForge',
                type: 'Root',
                fields: [
                    {
                        id: generateUUID(),
                        name: 'Title',
                        fieldKind: FIELD_KIND.PRIMITIVE,
                        primitiveType: PRIMITIVE_TYPE.TEXT
                    }
                ]
            };

            state.blueprints.push(rootT);

            const rootInst = createInstance(rootT.id);
            rootInst.fieldValues[rootT.fields[0].id] = 'My Knowledge Base';
            state.rootInstanceId = rootInst.id;

            save();
        }

        // ============================================================================
        // RENDER ORCHESTRATION
        // ============================================================================

        function renderAll() {
            console.log('üîÑ RENDER ALL called from:', new Error().stack);
            renderHierarchy();
            renderLibrary();
            renderEditor();
            updateUndoButtons();
            updateNavButtons();
        }

        const el = {
            hierarchy: document.getElementById('hierarchy'),
            templateList: document.getElementById('templateList'),
            editor: document.getElementById('editor'),
            selectedSummary: document.getElementById('selectedSummary'),
            templateSearch: document.getElementById('templateSearch'),
            verboseToggle: document.getElementById('verboseToggle'),
            backBtn: document.getElementById('backBtn'),
            forwardBtn: document.getElementById('forwardBtn')
        };

        // ============================================================================
        // HIERARCHY RENDERING (HARDENED)
        // ============================================================================

        function renderHierarchy() {
            el.hierarchy.innerHTML = '';
            const root = getRootInstance();
            if (!root) return;

            // HARDENING: Show validation warnings if present
            if (validationWarningsVisible && lastValidationResult && !lastValidationResult.valid) {
                const banner = document.createElement('div');
                banner.className = 'warning-banner';
                banner.style.marginBottom = '8px';
                banner.innerHTML = `‚ö†Ô∏è State has validation issues. Click Validate for details.`;
                banner.style.cursor = 'pointer';
                banner.onclick = () => {
                    document.getElementById('validateBtn').click();
                };
                el.hierarchy.appendChild(banner);
            }

            const treeRoot = document.createElement('div');
            treeRoot.className = 'tree-root';
            const ul = document.createElement('ul');
            ul.className = 'tree-branch';

            function buildLi(inst, visited = new Set()) {
                if (visited.has(inst.id)) {
                    const li = document.createElement('li');
                    const node = document.createElement('div');
                    node.className = 'tree-node';
                    node.style.color = 'var(--danger)';
                    node.textContent = '‚ö†Ô∏è Circular reference';
                    li.appendChild(node);
                    return li;
                }
                visited.add(inst.id);

                const tpl = findBlueprintById(inst.templateId) || { name: 'üì¶ (Blueprint Deleted)', type: '?', fields: [] };
                const li = document.createElement('li');
                const node = document.createElement('div');
                node.className = 'tree-node';
                if (selected.kind === 'instance' && selected.id === inst.id) {
                    node.classList.add('selected');
                }

                // HARDENING: Mark if instance is not in registry
                if (!isInstanceInRegistry(inst.id)) {
                    node.style.borderLeft = '3px solid var(--danger)';
                    node.title = 'Instance not in registry';
                }

                // Check if has children
                const hasChildren = (() => {
                    for (const f of tpl.fields || []) {
                        if (f.fieldKind === FIELD_KIND.CARD_REF || f.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                            const merged = getMergedChildrenWithProvenance(tpl, inst, f.id);
                            if (merged.length > 0) return true;
                        }
                    }
                    return false;
                })();

                const expanded = !collapsed[inst.id];
                const twisty = document.createElement('div');
                twisty.className = 'twisty';
                twisty.innerHTML = hasChildren ? (expanded ? '‚ñæ' : '‚ñ∏') : '';
                twisty.onclick = (e) => {
                    e.stopPropagation();
                    if (!hasChildren) return;
                    collapsed[inst.id] = !collapsed[inst.id];
                    renderAll();
                };
                node.appendChild(twisty);

                const label = document.createElement('div');
                label.className = 'node-label';
                const nameSpan = document.createElement('div');
                nameSpan.className = 'card-name';
                nameSpan.textContent = tpl.name;
                label.appendChild(nameSpan);

                const typeSpan = document.createElement('div');
                typeSpan.className = 'card-type muted';
                typeSpan.textContent = tpl.type;
                label.appendChild(typeSpan);

                const idSpan = document.createElement('div');
                idSpan.className = 'muted';
                idSpan.style.marginLeft = 'auto';
                idSpan.textContent = inst.id ? inst.id.slice(0, 8) : '';
                label.appendChild(idSpan);

                node.appendChild(label);
                node.onclick = (e) => {
                    e.stopPropagation();

                    // Force save of any active input before navigation
                    const activeInput = document.querySelector('input.valueInputDark:focus');
                    if (activeInput) {
                        console.log('üî• SAVING ACTIVE INPUT before navigation');

                        // Manually trigger the input's save logic
                        activeInput.blur(); // Triggers onblur

                        // Also manually save to ensure it's immediate
                        // Find the instance and field being edited
                        // (The blur handler will also save, but this ensures immediate save)
                        save();

                        console.log('üíæ SAVED - now navigating');
                    }

                    navigateTo('instance', inst.id);
                };

                // HARDENING: Prevent dragging root
                node.draggable = isRuntimeInstance(inst) && inst.id !== state.rootInstanceId;

                if (node.draggable) {
                    node.ondragstart = (e) => {
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                            type: 'instance-move',
                            instanceId: inst.id
                        }));
                        e.dataTransfer.effectAllowed = 'move';
                    };
                }

                li.appendChild(node);

                // Verbose mode: show field values
                if (verboseMode) {
                    const details = document.createElement('div');
                    details.style.padding = '4px 8px';
                    details.style.marginLeft = '18px';

                    for (const f of tpl.fields || []) {
                        const fLine = document.createElement('div');
                        fLine.style.display = 'flex';
                        fLine.style.gap = '8px';
                        fLine.style.alignItems = 'center';

                        const key = document.createElement('div');
                        key.className = 'field-key';
                        key.textContent = f.name;
                        key.style.width = '140px';

                        const valArea = document.createElement('div');
                        valArea.style.flex = '1';
                        valArea.className = 'muted';

                        if (f.fieldKind === FIELD_KIND.PRIMITIVE) {
                            const primVal = inst.fieldValues?.[f.id];
                            valArea.textContent = (primVal === null || primVal === '') ? '[NULL]' : String(primVal);
                        } else if (f.fieldKind === FIELD_KIND.ENTITY_REF) {
                            const ids = inst.fieldValues?.[f.id];
                            if (Array.isArray(ids)) {
                                valArea.textContent = `üîó ${ids.length} ref(s)`;
                            } else {
                                valArea.textContent = '[EMPTY]';
                            }
                        } else if (f.fieldKind === FIELD_KIND.LIST_ENTITY_REF) {
                            // Show ordered list of referenced instance names (vertical, numbered)
                            let ids = inst.fieldValues?.[f.id];
                            if (Array.isArray(ids)) {
                                // Normalize to string IDs (in case of object corruption)
                                ids = ids.map(item => {
                                    if (typeof item === 'object' && item !== null && item.id) {
                                        return item.id;
                                    }
                                    return item;
                                }).filter(id => typeof id === 'string');

                                if (ids.length === 0) {
                                    valArea.textContent = '[EMPTY]';
                                } else {
                                    // Create vertical numbered list
                                    valArea.innerHTML = '';
                                    valArea.style.display = 'flex';
                                    valArea.style.flexDirection = 'column';
                                    valArea.style.gap = '2px';

                                    ids.forEach((refId, index) => {
                                        const refInst = findInstanceById(refId);
                                        const refTpl = refInst ? findBlueprintById(refInst.templateId) : null;

                                        // Use template name
                                        const refName = refInst && refTpl ? refTpl.name : '‚ö†Ô∏è [missing]';

                                        const item = document.createElement('div');
                                        item.style.fontSize = '11px';
                                        item.style.display = 'flex';
                                        item.style.gap = '4px';

                                        const num = document.createElement('span');
                                        num.textContent = `${index + 1}.`;
                                        num.style.minWidth = '20px';
                                        num.style.color = 'var(--muted)';

                                        const name = document.createElement('span');
                                        name.textContent = refName;
                                        name.className = refInst ? '' : 'muted';

                                        item.appendChild(num);
                                        item.appendChild(name);
                                        valArea.appendChild(item);
                                    });
                                }
                            } else {
                                valArea.textContent = '[EMPTY]';
                            }
                        } else if (f.fieldKind === FIELD_KIND.CARD_REF || f.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                            const merged = getMergedChildrenWithProvenance(tpl, inst, f.id);
                            valArea.textContent = merged.map(x => {
                                const childTpl = findBlueprintById(x.child.templateId);
                                return childTpl?.name || 'üì¶ (Blueprint Deleted)';
                            }).join(', ');
                        }

                        fLine.appendChild(key);
                        fLine.appendChild(valArea);
                        details.appendChild(fLine);
                    }

                    li.appendChild(details);
                }

                // Render children
                if (hasChildren && expanded) {
                    const branch = document.createElement('ul');
                    branch.className = 'tree-branch';

                    for (const f of tpl.fields || []) {
                        if (f.fieldKind === FIELD_KIND.CARD_REF || f.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                            const merged = getMergedChildrenWithProvenance(tpl, inst, f.id);
                            for (const item of merged) {
                                const childLi = buildLi(item.child, new Set(visited));
                                branch.appendChild(childLi);
                            }
                        }
                    }

                    li.appendChild(branch);
                }

                return li;
            }

            const rootLi = buildLi(root, new Set());
            ul.appendChild(rootLi);
            treeRoot.appendChild(ul);
            el.hierarchy.appendChild(treeRoot);
            el.selectedSummary.textContent = selected.id ?
                `${selected.kind}: ${selected.id.slice(0, 8)}` : '‚Äî';
        }

        // ============================================================================
        // LIBRARY RENDERING
        // ============================================================================

        function renderLibrary() {
            const q = (el.templateSearch.value || '').toLowerCase();
            el.templateList.innerHTML = '';
            const frag = document.createDocumentFragment();

            for (const t of state.blueprints) {
                if (q && !(t.name.toLowerCase().includes(q) || (t.type || '').toLowerCase().includes(q))) {
                    continue;
                }

                const row = document.createElement('div');
                row.className = 'card-row' +
                    (selected.kind === 'template' && selected.id === t.id ? ' selected' : '');
                if (t.isStatic) row.classList.add('static-template');

                row.onclick = (e) => {
                    e.stopPropagation();
                    navigateTo('template', t.id);
                };

                const mid = document.createElement('div');
                mid.style.flex = '1';
                mid.innerHTML = `<div class='card-name'>${t.name}${t.isStatic ? ' (<span class="static-badge">static</span>)' : ''}</div><div class='card-type muted'>${t.type}</div>`;
                row.appendChild(mid);

                const actions = document.createElement('div');
                actions.style.display = 'flex';
                actions.style.gap = '6px';

                if (!isRootBlueprintId(t.id)) {
                    const delBtn = document.createElement('button');
                    delBtn.className = 'btn small danger';
                    delBtn.textContent = 'Delete';
                    delBtn.onclick = (e) => {
                        e.stopPropagation();  // Prevent row click

                        if (isRootBlueprintId(t.id)) {
                            alert('Cannot delete root template');
                            return;
                        }

                        // HARD CONTRACT: Block deletion if instances exist
                        const instances = Object.values(state.instances).filter(inst =>
                            inst.templateId === t.id
                        );

                        if (instances.length > 0) {
                            const instanceList = instances.map(inst => {
                                const parent = findInstanceById(inst._parent);
                                const parentTpl = parent ? findBlueprintById(parent.templateId) : null;
                                const containerField = parentTpl?.fields.find(f => f.id === inst._parentField);

                                const location = containerField ?
                                    `${parentTpl.name}.${containerField.name}` :
                                    'Unknown location';

                                return `  ‚Ä¢ Instance ${inst.id.slice(0, 8)} in ${location}`;
                            }).join('\n');

                            alert(
                                `Cannot delete template ${t.name}\n\n` +
                                `${instances.length} instance(s) still exist:\n\n${instanceList}\n\n` +
                                `Delete all instances first, then delete the template.`
                            );
                            return;
                        }

                        if (confirm(`Delete template ${t.name}?`)) {
                            pushUndo();
                            state.blueprints = state.blueprints.filter(tpl => tpl.id !== t.id);
                            save();
                            renderAll();
                        }
                    };
                    actions.appendChild(delBtn);
                }

                row.appendChild(actions);
                frag.appendChild(row);
            }

            el.templateList.appendChild(frag);
        }

        // ============================================================================
        // EDITOR RENDERING (HARDENED)
        // ============================================================================

        function renderEditor() {
            const container = el.editor;
            container.innerHTML = '';

            if (!selected.id) {
                container.innerHTML = '<div class="muted">Select a template or instance to edit.</div>';
                return;
            }

            const wrapper = document.createElement('div');
            wrapper.className = 'editor-content';

            const modeIndicator = document.createElement('div');
            modeIndicator.className = 'editor-mode-indicator ' +
                (selected.kind === 'instance' ? 'editor-mode-hierarchy' : 'editor-mode-library');
            modeIndicator.textContent = selected.kind === 'instance' ?
                'üìã Editing Instance (Hierarchy)' : 'üìö Editing Blueprint (Library)';
            wrapper.appendChild(modeIndicator);

            if (selected.kind === 'template') {
                renderBlueprintEditor(wrapper);
            } else if (selected.kind === 'instance') {
                renderInstanceEditor(wrapper);
            }

            container.appendChild(wrapper);
        }

        /**
 * Update visual indicators on field rows without full re-render.
 * Adds/removes .has-default class and tooltips based on current staticValues.
 */
        function updateFieldIndicators() {
            const tpl = findBlueprintById(selected.id);
            if (!tpl || selected.kind !== 'template') return;

            // Find all field definition rows
            const fieldDefs = document.querySelectorAll('.field-def');

            fieldDefs.forEach((fd, idx) => {
                if (idx >= tpl.fields.length) return;
                const field = tpl.fields[idx];

                // Only update primitive fields
                if (field.fieldKind !== FIELD_KIND.PRIMITIVE) {
                    fd.classList.remove('has-default');
                    fd.title = '';
                    return;
                }

                // Check if field has a non-empty default value
                const hasDefault = tpl.isStatic &&
                    tpl.staticValues &&
                    tpl.staticValues[field.id] !== undefined &&
                    tpl.staticValues[field.id] !== null &&
                    tpl.staticValues[field.id] !== '';

                if (hasDefault) {
                    fd.classList.add('has-default');
                    const defaultValue = tpl.staticValues[field.id];
                    const displayValue = typeof defaultValue === 'number' ? defaultValue : `"${defaultValue}"`;
                    fd.title = `Default value: ${displayValue}`;
                } else {
                    fd.classList.remove('has-default');
                    fd.title = '';
                }
            });
        }

        function renderBlueprintEditor(wrapper) {
            const tpl = findBlueprintById(selected.id);
            if (!tpl) {
                wrapper.innerHTML = '<div class="muted">Blueprint not found.</div>';
                return;
            }

            const wrap = document.createElement('div');

            // Blueprint name
            const nameLabel = document.createElement('label');
            nameLabel.textContent = 'Blueprint Name';
            const nameInput = document.createElement('input');
            nameInput.value = tpl.name;
            nameInput.disabled = isRootBlueprintId(tpl.id);
            nameInput.onfocus = () => pushUndo();
            nameInput.oninput = () => { tpl.name = nameInput.value; save(); };
            nameInput.onblur = () => { save(); renderAll(); };

            wrap.appendChild(nameLabel);
            wrap.appendChild(nameInput);

            // Blueprint type
            const typeLabel = document.createElement('label');
            typeLabel.textContent = 'Blueprint Type';

            const typeSelect = document.createElement('select');
            typeSelect.classList.add('valueInputDark');
            typeSelect.disabled = isRootBlueprintId(tpl.id);

            // Gather existing types (excluding Root)
            const existingTypes = Array.from(new Set(
                state.blueprints.map(t => t.type).filter(t => t && t !== 'Root')
            )).sort();

            // Add existing types as options
            for (const type of existingTypes) {
                const opt = document.createElement('option');
                opt.value = type;
                opt.textContent = type;
                typeSelect.appendChild(opt);
            }

            // Add separator and "Create new..." option
            if (existingTypes.length > 0) {
                const separator = document.createElement('option');
                separator.disabled = true;
                separator.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
                typeSelect.appendChild(separator);
            }

            const newOpt = document.createElement('option');
            newOpt.value = '__new__';
            newOpt.textContent = '+ Create new type...';
            typeSelect.appendChild(newOpt);

            // Set current value
            typeSelect.value = tpl.type;

            // Handle selection change
            typeSelect.onchange = () => {
                if (typeSelect.value === '__new__') {
                    const newType = prompt('Enter new type name:');
                    if (newType && newType.trim()) {
                        pushUndo();
                        tpl.type = newType.trim();
                        save();
                        renderAll();
                    } else {
                        typeSelect.value = tpl.type; // Revert if cancelled
                    }
                } else {
                    pushUndo();
                    tpl.type = typeSelect.value;
                    save();
                    renderAll();
                }
            };

            wrap.appendChild(nameLabel);
            wrap.appendChild(nameInput);
            wrap.appendChild(typeLabel);
            wrap.appendChild(typeSelect);

            // ============================================================================
            // STATIC TEMPLATE DEFAULTS SECTION
            // ============================================================================

            // HARDENING: Ensure staticValues exists
            if (!tpl.staticValues) {
                tpl.staticValues = {};
            }

            // Static defaults toggle and editor
            const staticSection = document.createElement('div');
            staticSection.style.marginTop = '20px';
            staticSection.style.padding = '16px';
            staticSection.style.border = '1px solid var(--border)';
            staticSection.style.borderRadius = '6px';
            staticSection.style.backgroundColor = 'rgba(251,191,36,0.05)';

            // Section header with checkbox
            const staticHeader = document.createElement('div');
            staticHeader.style.display = 'flex';
            staticHeader.style.alignItems = 'center';
            staticHeader.style.gap = '8px';
            staticHeader.style.marginBottom = '12px';

            const staticToggle = document.createElement('input');
            staticToggle.type = 'checkbox';
            staticToggle.id = 'staticToggle';
            staticToggle.checked = !!tpl.isStatic;
            staticToggle.style.cursor = 'pointer';

            const staticLabel = document.createElement('label');
            staticLabel.htmlFor = 'staticToggle';
            staticLabel.textContent = 'Use blueprint defaults';
            staticLabel.style.cursor = 'pointer';
            staticLabel.style.fontWeight = '600';
            staticLabel.title = 'Pre-fill new instances with default values';

            staticHeader.appendChild(staticToggle);
            staticHeader.appendChild(staticLabel);
            staticSection.appendChild(staticHeader);

            // Help text
            const staticHelp = document.createElement('div');
            staticHelp.className = 'muted';
            staticHelp.style.fontSize = '12px';
            staticHelp.style.marginBottom = '12px';
            staticHelp.textContent = 'New instances will start with these default values. Existing instances are not affected.';
            staticSection.appendChild(staticHelp);

            // Container for default value inputs
            const defaultsContainer = document.createElement('div');
            defaultsContainer.style.display = tpl.isStatic ? 'block' : 'none';

            // Function to render default value inputs
            function renderDefaultInputs() {
                try {
                    defaultsContainer.innerHTML = '';

                    if (!tpl || !tpl.fields) {
                        const error = document.createElement('div');
                        error.className = 'muted';
                        error.textContent = 'Blueprint not found or has no fields.';
                        defaultsContainer.appendChild(error);
                        return;
                    }

                    // HARDENING: Ensure staticValues exists
                    if (!tpl.staticValues) {
                        tpl.staticValues = {};
                    }

                    const primitiveFields = tpl.fields.filter(f => f && f.fieldKind === FIELD_KIND.PRIMITIVE);

                    if (primitiveFields.length === 0) {
                        const noFields = document.createElement('div');
                        noFields.className = 'muted';
                        noFields.textContent = 'No primitive fields yet. Add text or number fields to configure defaults.';
                        defaultsContainer.appendChild(noFields);
                        return;
                    }

                    for (const field of primitiveFields) {
                        if (!field || !field.id) continue;

                        const fieldRow = document.createElement('div');
                        fieldRow.style.marginBottom = '12px';

                        const fieldLabel = document.createElement('label');
                        fieldLabel.textContent = field.name || 'Unnamed field';
                        fieldLabel.style.display = 'block';
                        fieldLabel.style.marginBottom = '4px';
                        fieldLabel.style.fontSize = '13px';

                        const fieldInput = document.createElement('input');
                        fieldInput.type = field.primitiveType === PRIMITIVE_TYPE.NUMBER ? 'number' : 'text';

                        // HARDENING: Safe access to staticValues with fallback
                        const currentValue = tpl.staticValues[field.id];
                        const defaultValue = field.primitiveType === PRIMITIVE_TYPE.NUMBER ? 0 : '';
                        fieldInput.value = (currentValue !== undefined && currentValue !== null) ? currentValue : defaultValue;

                        fieldInput.style.width = '100%';
                        fieldInput.placeholder = `Default value for new instances...`;

                        fieldInput.onfocus = () => pushUndo();
                        fieldInput.oninput = () => {
                            // HARDENING: Ensure staticValues exists before writing
                            if (!tpl.staticValues) {
                                tpl.staticValues = {};
                            }

                            if (field.primitiveType === PRIMITIVE_TYPE.NUMBER) {
                                tpl.staticValues[field.id] = fieldInput.value === '' ? 0 : Number(fieldInput.value);
                            } else {
                                tpl.staticValues[field.id] = fieldInput.value;
                            }
                            save();

                            // STATIC UI: Update field indicator without full re-render
                            updateFieldIndicators();
                        };

                        const fieldHint = document.createElement('div');
                        fieldHint.className = 'muted';
                        fieldHint.style.fontSize = '11px';
                        fieldHint.style.marginTop = '2px';

                        // Calculate usage statistics
                        let usingDefault = 0;
                        let overridden = 0;
                        let totalInstances = 0;

                        for (const instId in state.instances) {
                            const inst = state.instances[instId];
                            if (inst.templateId !== tpl.id) continue;

                            totalInstances++;

                            if (inst.fieldValues[field.id] === undefined) {
                                usingDefault++;
                            } else {
                                overridden++;
                            }
                        }

                        if (totalInstances === 0) {
                            fieldHint.textContent = `New ${tpl.name || 'instances'} will start with this value`;
                        } else {
                            const parts = [];
                            if (usingDefault > 0) parts.push(`${usingDefault} using default`);
                            if (overridden > 0) parts.push(`${overridden} overridden`);

                            fieldHint.textContent = `üìä ${parts.join(', ')} (${totalInstances} total)`;
                            fieldHint.title = `${usingDefault} instance(s) will use this template default\n${overridden} instance(s) have custom values`;
                        }

                        fieldRow.appendChild(fieldLabel);
                        fieldRow.appendChild(fieldInput);
                        fieldRow.appendChild(fieldHint);
                        defaultsContainer.appendChild(fieldRow);
                    }
                } catch (error) {
                    console.error('Error rendering default inputs:', error);
                    defaultsContainer.innerHTML = '<div class="muted" style="color: var(--danger);">Error rendering defaults. Check console.</div>';
                }
            }

            // Initial render
            renderDefaultInputs();

            // Toggle handler
            staticToggle.onchange = () => {
                pushUndo();
                tpl.isStatic = staticToggle.checked;

                // HARDENING: Initialize staticValues if enabling
                if (tpl.isStatic && !tpl.staticValues) {
                    tpl.staticValues = {};
                }

                // Show/hide defaults container
                defaultsContainer.style.display = tpl.isStatic ? 'block' : 'none';

                // Render inputs if showing
                if (tpl.isStatic) {
                    renderDefaultInputs();
                }

                save();
                renderAll();
            };

            staticSection.appendChild(defaultsContainer);
            wrap.appendChild(staticSection);

            // ============================================================================
            // END STATIC SECTION
            // ============================================================================
            // Fields list
            const fieldList = document.createElement('div');
            fieldList.className = 'field-list';

            for (let fieldIdx = 0; fieldIdx < tpl.fields.length; fieldIdx++) {
                const f = tpl.fields[fieldIdx];
                const fd = document.createElement('div');
                fd.className = 'field-def';

                // STATIC UI: Add visual indicator for fields with defaults
                if (tpl.isStatic &&
                    f.fieldKind === FIELD_KIND.PRIMITIVE &&
                    tpl.staticValues &&
                    tpl.staticValues[f.id] !== undefined &&
                    tpl.staticValues[f.id] !== null &&
                    tpl.staticValues[f.id] !== '') {
                    fd.classList.add('has-default');

                    // Add tooltip showing default value
                    const defaultValue = tpl.staticValues[f.id];
                    const displayValue = typeof defaultValue === 'number' ? defaultValue : `"${defaultValue}"`;
                    fd.title = `Default value: ${displayValue}`;
                }
                fd.draggable = true;

                // Drag handle
                const dragHandle = document.createElement('div');
                dragHandle.className = 'drag-handle';
                dragHandle.innerHTML = '‚ãÆ‚ãÆ';
                fd.appendChild(dragHandle);

                fd.ondragstart = (e) => {
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                        type: 'field-reorder',
                        templateId: tpl.id,
                        fieldIndex: fieldIdx
                    }));
                };
                fd.ondragover = (e) => {
                    e.preventDefault();
                    fd.classList.add('drag-over');
                };
                fd.ondragleave = () => {
                    fd.classList.remove('drag-over');
                };
                fd.ondrop = (e) => {
                    e.preventDefault();
                    fd.classList.remove('drag-over');
                    try {
                        const payload = JSON.parse(e.dataTransfer.getData('text/plain'));
                        if (payload.type === 'field-reorder' && payload.templateId === tpl.id) {
                            pushUndo();
                            const [removed] = tpl.fields.splice(payload.fieldIndex, 1);
                            tpl.fields.splice(fieldIdx, 0, removed);
                            save();
                            renderAll();
                        }
                    } catch (err) {
                        console.error('Field reorder failed', err);
                    }
                };

                // Field name
                const inputName = document.createElement('input');
                inputName.value = f.name;
                inputName.style.flex = '1';
                inputName.onfocus = () => pushUndo();
                inputName.oninput = () => { f.name = inputName.value; save(); };
                inputName.onblur = () => { save(); renderAll(); };
                fd.appendChild(inputName);

                // Field kind
                const kindSel = document.createElement('select');
                [FIELD_KIND.PRIMITIVE, FIELD_KIND.CARD_REF, FIELD_KIND.LIST_OF_CARDS, FIELD_KIND.ENTITY_REF, FIELD_KIND.LIST_ENTITY_REF].forEach(k => {

                    const o = document.createElement('option');
                    o.value = k;
                    o.textContent = k;
                    kindSel.appendChild(o);
                });
                kindSel.value = f.fieldKind;
                kindSel.onchange = () => {
                    pushUndo();

                    const oldKind = f.fieldKind;
                    const newKind = kindSel.value;

                    // HARDENING: Check if data will be lost and warn user
                    let hasData = false;
                    let affectedCount = 0;

                    for (const instId in state.instances) {
                        const inst = state.instances[instId];
                        if (inst.templateId === tpl.id) {
                            const val = inst.fieldValues[f.id];

                            if (oldKind === FIELD_KIND.LIST_ENTITY_REF && newKind === FIELD_KIND.CARD_REF) {
                                if (Array.isArray(val) && val.length > 0) {
                                    hasData = true;
                                    affectedCount++;
                                }
                            }
                        }
                    }

                    // Show warning if data will be lost
                    if (hasData) {
                        alert(`‚ö†Ô∏è Changing field kind will clear data in ${affectedCount} instance(s).`);
                    }

                    // Change field kind
                    f.fieldKind = newKind;

                    // Update field properties based on new kind
                    if (f.fieldKind === FIELD_KIND.PRIMITIVE) {
                        delete f.cardTypeFilter;
                        delete f.fieldMode;
                        f.primitiveType = f.primitiveType || PRIMITIVE_TYPE.TEXT;
                    } else if (f.fieldKind === FIELD_KIND.ENTITY_REF || f.fieldKind === FIELD_KIND.LIST_ENTITY_REF) {
                        delete f.primitiveType;
                        delete f.fieldMode;
                        f.cardTypeFilter = f.cardTypeFilter || 'Generic';
                    } else {
                        delete f.primitiveType;
                        f.cardTypeFilter = f.cardTypeFilter || 'Generic';
                        f.fieldMode = f.fieldMode || FIELD_MODE.CONTAIN;
                    }

                    // HARDENING: Normalize all instance field values to match new kind
                    for (const instId in state.instances) {
                        const inst = state.instances[instId];
                        if (inst.templateId !== tpl.id) continue;

                        const val = inst.fieldValues[f.id];

                        // LIST ‚Üí SINGLE
                        if (
                            oldKind === FIELD_KIND.LIST_ENTITY_REF &&
                            newKind === FIELD_KIND.CARD_REF
                        ) {
                            if (Array.isArray(val) && val.length > 0) {
                                hasData = true;
                                affectedCount++;
                            }
                        }

                        // ENTITY/LIST ‚Üí PRIMITIVE
                        else if (
                            (oldKind === FIELD_KIND.ENTITY_REF || oldKind === FIELD_KIND.LIST_ENTITY_REF) &&
                            newKind === FIELD_KIND.PRIMITIVE
                        ) {
                            if (Array.isArray(val) && val.length > 0) {
                                hasData = true;
                                affectedCount++;
                            }
                        }

                        // PRIMITIVE ‚Üí ANY REF
                        else if (
                            oldKind === FIELD_KIND.PRIMITIVE &&
                            (newKind === FIELD_KIND.CARD_REF ||
                                newKind === FIELD_KIND.LIST_OF_CARDS ||
                                newKind === FIELD_KIND.ENTITY_REF ||
                                newKind === FIELD_KIND.LIST_ENTITY_REF)
                        ) {
                            if (val !== null && val !== '' && val !== 0) {
                                hasData = true;
                                affectedCount++;
                            }
                        }

                        // REF ‚Üî REF transitions
                        else if (
                            (oldKind === FIELD_KIND.CARD_REF ||
                                oldKind === FIELD_KIND.LIST_OF_CARDS ||
                                oldKind === FIELD_KIND.ENTITY_REF ||
                                oldKind === FIELD_KIND.LIST_ENTITY_REF) &&
                            (newKind === FIELD_KIND.CARD_REF ||
                                newKind === FIELD_KIND.LIST_OF_CARDS ||
                                newKind === FIELD_KIND.ENTITY_REF ||
                                newKind === FIELD_KIND.LIST_ENTITY_REF)
                        ) {
                            if (
                                (typeof val === 'string' && val) ||
                                (Array.isArray(val) && val.length > 0)
                            ) {
                                hasData = true;
                                affectedCount++;
                            }
                        }
                    }

                    // CRITICAL: Initialize field values for new kind
                    for (const instId in state.instances) {
                        const inst = state.instances[instId];
                        if (inst.templateId !== tpl.id) continue;

                        // Initialize based on new field kind
                        if (newKind === FIELD_KIND.PRIMITIVE) {
                            // Primitive: empty string or 0
                            const primType = f.primitiveType || PRIMITIVE_TYPE.TEXT;
                            inst.fieldValues[f.id] = primType === PRIMITIVE_TYPE.NUMBER ? 0 : '';
                        } else if (newKind === FIELD_KIND.LIST_OF_CARDS || newKind === FIELD_KIND.LIST_ENTITY_REF) {
                            // Lists: empty array
                            inst.fieldValues[f.id] = [];
                        } else if (newKind === FIELD_KIND.CARD_REF || newKind === FIELD_KIND.ENTITY_REF) {
                            // Single references: null
                            inst.fieldValues[f.id] = null;
                        }
                    }

                    save();
                    renderAll();
                };
                fd.appendChild(kindSel);

                // Additional controls based on field kind
                if (f.fieldKind === FIELD_KIND.PRIMITIVE) {
                    const psel = document.createElement('select');
                    [PRIMITIVE_TYPE.TEXT, PRIMITIVE_TYPE.NUMBER].forEach(p => {
                        const o = document.createElement('option');
                        o.value = p;
                        o.textContent = p;
                        psel.appendChild(o);
                    });
                    psel.value = f.primitiveType || PRIMITIVE_TYPE.TEXT;
                    psel.onchange = () => {
                        pushUndo();
                        f.primitiveType = psel.value;
                        save();
                        renderAll();
                    };
                    fd.appendChild(psel);
                } else if (f.fieldKind !== FIELD_KIND.ENTITY_REF && f.fieldKind !== FIELD_KIND.LIST_ENTITY_REF) {  // ‚Üê MODIFIED
                    // instantiation/instantiationList: type filter + mode
                    const filterSel = document.createElement('select');
                    const types = Array.from(new Set(state.blueprints.map(tt => tt.type || 'Generic'))).filter(t => t !== 'Root');
                    for (const ty of types) {
                        const o = document.createElement('option');
                        o.value = ty;
                        o.textContent = ty;
                        filterSel.appendChild(o);
                    }
                    filterSel.value = f.cardTypeFilter || types[0] || 'Generic';
                    filterSel.onchange = () => {
                        pushUndo();
                        f.cardTypeFilter = filterSel.value;
                        save();
                        renderAll();
                    };
                    fd.appendChild(filterSel);

                    const modeSel = document.createElement('select');
                    modeSel.title = 'Contain: owns children | Reference: links to existing';
                    const containOpt = document.createElement('option');
                    containOpt.value = FIELD_MODE.CONTAIN;
                    containOpt.textContent = 'Contain';
                    const refOpt = document.createElement('option');
                    refOpt.value = FIELD_MODE.REFERENCE;
                    refOpt.textContent = 'Reference';
                    modeSel.appendChild(containOpt);
                    modeSel.appendChild(refOpt);
                    modeSel.value = f.fieldMode || FIELD_MODE.CONTAIN;
                    modeSel.onchange = () => {
                        pushUndo();
                        f.fieldMode = modeSel.value;
                        save();
                        renderAll();
                    };
                    fd.appendChild(modeSel);
                } else {
                    // instanceReference or instanceReferenceList: just type filter
                    const filterSel = document.createElement('select');
                    const types = Array.from(new Set(state.blueprints.map(tt => tt.type || 'Generic'))).filter(t => t !== 'Root');
                    for (const ty of types) {
                        const o = document.createElement('option');
                        o.value = ty;
                        o.textContent = ty;
                        filterSel.appendChild(o);
                    }
                    filterSel.value = f.cardTypeFilter || types[0] || 'Generic';
                    filterSel.onchange = () => {
                        pushUndo();
                        f.cardTypeFilter = filterSel.value;
                        save();
                        renderAll();
                    };
                    fd.appendChild(filterSel);
                }

                // Remove button
                const rm = document.createElement('button');
                rm.className = 'btn small danger';
                rm.textContent = '√ó';
                rm.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm(`Remove field ${f.name}?`)) removeField(tpl.id, f.id);
                };
                fd.appendChild(rm);

                fieldList.appendChild(fd);
            }

            wrap.appendChild(fieldList);

            // Add field button
            const addBtn = document.createElement('button');
            addBtn.className = 'btn small primary';
            addBtn.textContent = 'Add Field';
            addBtn.onclick = () => {
                const newF = {
                    id: generateUUID(),
                    name: 'field',
                    fieldKind: FIELD_KIND.PRIMITIVE,
                    primitiveType: PRIMITIVE_TYPE.TEXT
                };
                addField(tpl.id, newF);
            };

            wrap.appendChild(addBtn);

            // Delete template button
            if (!isRootBlueprintId(tpl.id)) {
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn small danger';
                deleteBtn.textContent = 'üóëÔ∏è Delete Blueprint';
                deleteBtn.style.marginTop = '16px';

                deleteBtn.onclick = () => {
                    if (isRootBlueprintId(tpl.id)) {
                        alert('Cannot delete root template');
                        return;
                    }

                    // HARD CONTRACT: Block deletion if instances exist
                    const instances = Object.values(state.instances).filter(inst =>
                        inst.templateId === tpl.id
                    );

                    if (instances.length > 0) {
                        console.log('üö´ BLOCKING: Found', instances.length, 'instances');
                        // ... build instanceList ...

                        alert(
                            `Cannot delete template ${tpl.name}\n\n` +
                            `${instances.length} instance(s) still exist:\n\n${instanceList}\n\n` +
                            `Delete all instances first, then delete the template.`
                        );

                        console.log('üö´ RETURNED - deletion blocked');
                        return; // BLOCK deletion
                    }

                    console.log('‚úÖ NO INSTANCES - showing confirm');

                    // No instances - safe to delete
                    if (confirm(`Delete template ${tpl.name}?`)) {
                        console.log('‚úÖ CONFIRMED - deleting');
                        pushUndo();
                        state.blueprints = state.blueprints.filter(t => t.id !== tpl.id);
                        save();
                        renderAll();
                    }
                };

                wrap.appendChild(deleteBtn);
            }

            wrapper.appendChild(wrap);
        }

        function renderInstanceEditor(wrapper) {
            const inst = findInstanceById(selected.id);
            if (!inst) {
                wrapper.innerHTML = '<div class="muted">Instance not found.</div>';
                return;
            }

            const card = renderInstanceBlueprint(inst, null, null, 'dynamic', new Set());
            wrapper.appendChild(card);
        }

        // ============================================================================
        // INSTANCE CARD RENDERING (HARDENED)
        // ============================================================================

        function renderInstanceBlueprint(inst, parentInst, parentField, origin, visited) {
            if (visited.has(inst.id)) {
                const card = document.createElement('div');
                card.className = 'instance-card';
                card.style.borderColor = 'var(--danger)';
                card.innerHTML = '<div style="padding:10px;color:var(--danger)">‚ö†Ô∏è Circular reference</div>';
                return card;
            }
            visited.add(inst.id);

            const tpl = findBlueprintById(inst.templateId);
            if (!tpl) {
                // Blueprint was deleted - render error state
                const errorBlueprint = document.createElement('div');
                errorBlueprint.className = 'instance-card';
                errorBlueprint.style.borderColor = 'var(--danger)';
                errorBlueprint.innerHTML = `
        <div class="card-header" style="color: var(--danger);">
            ‚ö†Ô∏è Blueprint Deleted
        </div>
        <div class="muted" style="padding: 12px;">
            Instance ${inst.id.slice(0, 8)} references deleted template ${inst.templateId.slice(0, 8)}.
            This instance cannot be edited.
        </div>
    `;
                return errorBlueprint;
            }
            const templateDeleted = !tpl;
            const templateData = tpl || { name: '', type: '', fields: [] };

            const card = document.createElement('div');
            card.className = 'instance-card';
            if (origin === 'static') card.classList.add('static-child');
            if (origin === 'reference') card.classList.add('reference-child');
            if (templateDeleted) card.classList.add('deleted-template');

            // HARDENING: Mark static ghosts (should not appear in runtime)
            if (isStaticInstanceShape(inst)) {
                card.classList.add('static-ghost');
                card.title = 'CRITICAL: Static shape in runtime (should not happen)';
                card.style.borderColor = 'var(--danger)';
            }

            if (editorCollapsed[inst.id] === undefined) {
                editorCollapsed[inst.id] = true;
            }
            const isCollapsed = editorCollapsed[inst.id];

            // Header
            const header = document.createElement('div');
            header.className = 'instance-header';

            const headerLeft = document.createElement('div');
            headerLeft.className = 'instance-header-left';
            headerLeft.onclick = (e) => {
                e.stopPropagation();
                editorCollapsed[inst.id] = !editorCollapsed[inst.id];
                renderEditor();
            };

            const twisty = document.createElement('span');
            twisty.textContent = isCollapsed ? '‚ñ∏' : '‚ñæ';
            twisty.style.cursor = 'pointer';
            headerLeft.appendChild(twisty);

            const nameSpan = document.createElement('span');
            nameSpan.className = 'card-name';

            if (templateDeleted) {
                // Gentler styling for deleted blueprints
                nameSpan.textContent = '(Blueprint Deleted)';
                nameSpan.style.fontStyle = 'italic';
                nameSpan.style.opacity = '0.6';

                headerLeft.appendChild(nameSpan);

                const idSpan = document.createElement('span');
                idSpan.className = 'muted';
                idSpan.style.fontSize = '0.85em';
                idSpan.textContent = ` ‚Ä¢ ${inst.templateId.slice(0, 8)}`;
                headerLeft.appendChild(idSpan);

                // Add explanatory hint
                const hintSpan = document.createElement('div');
                hintSpan.style.fontSize = '0.75em';
                hintSpan.style.opacity = '0.5';
                hintSpan.style.marginTop = '2px';
                hintSpan.textContent = 'Blueprint was deleted. Instance data preserved.';
                headerLeft.appendChild(hintSpan);
            } else {
                // Normal template rendering
                nameSpan.textContent = templateData.name;
                headerLeft.appendChild(nameSpan);

                const typeSpan = document.createElement('span');
                typeSpan.className = 'muted';
                typeSpan.textContent = ' (' + templateData.type + ')';
                headerLeft.appendChild(typeSpan);
            }

            if (origin === 'static') {
                const lockIcon = document.createElement('span');
                lockIcon.className = 'lock-icon';
                lockIcon.textContent = 'üîí';
                lockIcon.title = 'Defined by template';
                headerLeft.appendChild(lockIcon);
            }

            if (origin === 'reference') {
                const refIcon = document.createElement('span');
                refIcon.className = 'reference-icon';
                refIcon.textContent = 'üîó';
                refIcon.title = 'Referenced instance';
                headerLeft.appendChild(refIcon);
            }

            const headerActions = document.createElement('div');
            headerActions.className = 'instance-header-actions';

            const editBtn = document.createElement('button');
            editBtn.className = 'btn small';
            editBtn.textContent = 'Edit Blueprint';
            editBtn.onclick = (e) => {
                e.stopPropagation();
                navigateTo('template', inst.templateId);
            };
            headerActions.appendChild(editBtn);

            // HARDENING: Only allow removal if not static and not root
            if (parentInst && parentField && origin !== 'static' && inst.id !== state.rootInstanceId) {
                const rmBtn = document.createElement('button');
                rmBtn.className = 'btn small danger';
                rmBtn.textContent = origin === 'reference' ? 'Unlink' : '√ó';
                rmBtn.onclick = (e) => {
                    e.stopPropagation();

                    // HARDENING: Check for references before deletion
                    let confirmMsg = origin === 'reference' ?
                        'Remove this reference? (Instance will not be deleted)' :
                        'Delete this instance? (Will cascade-delete owned children)';

                    if (origin !== 'reference') {
                        // Check if other instances reference this one
                        const referencingInstances = [];
                        for (const checkId in state.instances) {
                            const checkInst = state.instances[checkId];
                            const checkTpl = findBlueprintById(checkInst.templateId);
                            if (!checkTpl) continue;

                            for (const checkField of checkTpl.fields) {
                                if (isEntityRefField(checkField)) {
                                    const val = checkInst.fieldValues[checkField.id];
                                    if (Array.isArray(val) && val.includes(inst.id)) {
                                        referencingInstances.push({
                                            instanceId: checkId,
                                            fieldName: checkField.name,
                                            fieldKind: checkField.fieldKind
                                        });
                                    }
                                }

                                if (isReferenceField(checkField)) {
                                    const val = checkInst.fieldValues[checkField.id];
                                    if (checkField.fieldKind === FIELD_KIND.CARD_REF && val === inst.id) {
                                        referencingInstances.push({
                                            instanceId: checkId,
                                            fieldName: checkField.name,
                                            fieldKind: checkField.fieldKind
                                        });
                                    } else if (checkField.fieldKind === FIELD_KIND.LIST_OF_CARDS && Array.isArray(val) && val.includes(inst.id)) {
                                        referencingInstances.push({
                                            instanceId: checkId,
                                            fieldName: checkField.name,
                                            fieldKind: checkField.fieldKind
                                        });
                                    }
                                }
                            }
                        }

                        if (referencingInstances.length > 0) {
                            const refList = referencingInstances.slice(0, 5).map(ref =>
                                `  ‚Ä¢ Instance ${ref.instanceId.slice(0, 8)} (${ref.fieldName} field)`
                            ).join('\n');
                            const more = referencingInstances.length > 5 ?
                                `\n  ... and ${referencingInstances.length - 5} more` : '';

                            confirmMsg = `‚ö†Ô∏è WARNING: This instance is referenced by ${referencingInstances.length} other instance(s):\n\n${refList}${more}\n\nDeleting will leave broken references. Continue?`;
                        }
                    }

                    if (confirm(confirmMsg)) {
                        pushUndo();

                        if (parentField.fieldKind === FIELD_KIND.CARD_REF) {
                            parentInst.fieldValues[parentField.id] = null;
                        } else if (parentField.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                            const arr = parentInst.fieldValues[parentField.id];
                            if (Array.isArray(arr)) {
                                if (isReferenceField(parentField)) {
                                    // HARDENING: Reference removal only
                                    parentInst.fieldValues[parentField.id] = arr.filter(id => id !== inst.id);
                                } else {
                                    // FIXED: Array contains IDs now, not objects
                                    parentInst.fieldValues[parentField.id] = arr.filter(id => id !== inst.id);
                                    // HARDENING: Delete instance only if contain-mode
                                    if (origin !== 'reference') deleteInstance(inst.id);
                                }
                            }
                        }

                        save();
                        renderAll();
                    }
                };
                headerActions.appendChild(rmBtn);
            }

            header.appendChild(headerLeft);
            header.appendChild(headerActions);
            card.appendChild(header);

            // STATIC FEATURE: Reset all overrides button
            if (tpl.isStatic) {
                // Count how many fields are overridden
                const overriddenFields = tpl.fields.filter(f =>
                    f.fieldKind === FIELD_KIND.PRIMITIVE &&
                    tpl.staticValues?.[f.id] !== undefined &&
                    inst.fieldValues[f.id] !== undefined
                );

                if (overriddenFields.length > 0) {
                    const resetAllContainer = document.createElement('div');
                    resetAllContainer.style.padding = '8px 12px';
                    resetAllContainer.style.background = 'rgba(59, 130, 246, 0.05)';
                    resetAllContainer.style.borderBottom = '1px solid var(--border)';
                    resetAllContainer.style.display = 'flex';
                    resetAllContainer.style.alignItems = 'center';
                    resetAllContainer.style.gap = '8px';

                    const resetInfo = document.createElement('div');
                    resetInfo.className = 'muted';
                    resetInfo.style.fontSize = '11px';
                    resetInfo.style.flex = '1';
                    resetInfo.textContent = `${overriddenFields.length} field(s) customized`;

                    const resetAllBtn = document.createElement('button');
                    resetAllBtn.className = 'btn small';
                    resetAllBtn.textContent = '‚éå Reset All to Defaults';
                    resetAllBtn.title = `Revert ${overriddenFields.length} field(s) to template defaults`;
                    resetAllBtn.onclick = () => {
                        const fieldNames = overriddenFields.map(f => f.name).join(', ');
                        if (confirm(
                            `Reset ${overriddenFields.length} field(s) to template defaults?\n\n` +
                            `Fields: ${fieldNames}\n\n` +
                            `This can be undone.`
                        )) {
                            pushUndo();
                            for (const field of overriddenFields) {
                                delete inst.fieldValues[field.id];
                            }
                            save();
                            renderAll();
                        }
                    };

                    resetAllContainer.appendChild(resetInfo);
                    resetAllContainer.appendChild(resetAllBtn);
                    card.appendChild(resetAllContainer);
                }
            }

            // Body
            const body = document.createElement('div');
            body.className = 'instance-body' + (isCollapsed ? ' collapsed' : '');

            for (const f of templateData.fields) {
                const row = document.createElement('div');
                row.className = 'field-line';

                const label = document.createElement('div');
                label.className = 'field-key';
                label.textContent = f.name;

                if (isFieldStatic(tpl, f)) {
                    const lockIcon = document.createElement('span');
                    lockIcon.className = 'lock-icon';
                    lockIcon.textContent = 'üîí';
                    lockIcon.title = 'Defined by template';
                    lockIcon.style.marginLeft = '4px';
                    label.appendChild(lockIcon);
                }

                const control = document.createElement('div');
                control.style.flex = '1';
                control.style.minWidth = '0';

                // Render field based on kind
                if (f.fieldKind === FIELD_KIND.PRIMITIVE) {
                    const isStaticBlueprint = tpl.isStatic && tpl.staticValues?.[f.id] !== undefined;
                    const isOverridden = inst.fieldValues[f.id] !== undefined;

                    if (isStaticBlueprint && !isOverridden) {
                        // STATE: Using template default (not overridden)
                        const defaultValue = tpl.staticValues[f.id];

                        const defaultDisplay = document.createElement('div');
                        defaultDisplay.style.display = 'flex';
                        defaultDisplay.style.alignItems = 'center';
                        defaultDisplay.style.gap = '8px';
                        defaultDisplay.style.marginBottom = '8px';

                        const valueText = document.createElement('div');
                        valueText.textContent = String(defaultValue) + ' (template default)';
                        valueText.className = 'muted';
                        valueText.style.flex = '1';

                        const overrideBtn = document.createElement('button');
                        overrideBtn.className = 'btn small';
                        overrideBtn.textContent = 'Override';
                        overrideBtn.title = 'Customize this value for this instance';
                        overrideBtn.onclick = () => {
                            pushUndo();
                            // Copy template default to instance (makes it editable)
                            inst.fieldValues[f.id] = defaultValue;
                            save();
                            renderAll();
                        };

                        defaultDisplay.appendChild(valueText);
                        defaultDisplay.appendChild(overrideBtn);
                        control.appendChild(defaultDisplay);

                        const hintRow = document.createElement('div');
                        hintRow.style.display = 'flex';
                        hintRow.style.alignItems = 'center';
                        hintRow.style.gap = '8px';
                        hintRow.style.marginTop = '4px';

                        const hint = document.createElement('div');
                        hint.className = 'muted';
                        hint.style.fontSize = '11px';
                        hint.textContent = 'Click Override to customize';

                        const templateLink = document.createElement('button');
                        templateLink.className = 'btn small';
                        templateLink.style.fontSize = '10px';
                        templateLink.style.padding = '2px 6px';
                        templateLink.textContent = 'üîó Edit defaults';
                        templateLink.title = 'Go to template editor to change default values';
                        templateLink.onclick = (e) => {
                            e.stopPropagation();
                            navigateTo('template', tpl.id);
                        };

                        hintRow.appendChild(hint);
                        hintRow.appendChild(templateLink);
                        control.appendChild(hintRow);

                    } else {
                        // STATE: Normal input (no template default, or overridden)
                        const inp = document.createElement('input');
                        inp.type = f.primitiveType === PRIMITIVE_TYPE.NUMBER ? 'number' : 'text';

                        // Get value from instance or use default
                        let currentValue;
                        if (isOverridden) {
                            currentValue = inst.fieldValues[f.id];
                        } else {
                            currentValue = f.primitiveType === PRIMITIVE_TYPE.NUMBER ? 0 : '';
                        }
                        inp.value = currentValue;

                        inp.onfocus = () => pushUndo();
                        inp.oninput = () => {
                            if (f.primitiveType === PRIMITIVE_TYPE.NUMBER) {
                                inst.fieldValues[f.id] = inp.value === '' ? 0 : Number(inp.value);
                            } else {
                                inst.fieldValues[f.id] = inp.value;
                            }
                            save();
                        };
                        inp.onblur = () => {
                            console.log('üî• INPUT BLUR - rendering all');
                            save();
                            renderAll();
                        };
                        control.appendChild(inp);

                        // If overridden, show indicator + revert button
                        if (isStaticBlueprint && isOverridden) {
                            const overrideIndicator = document.createElement('div');
                            overrideIndicator.className = 'override-indicator';

                            const badge = document.createElement('span');
                            badge.className = 'override-badge';
                            badge.textContent = '‚úèÔ∏è Overridden';

                            const originalText = document.createElement('span');
                            originalText.className = 'override-original';
                            originalText.textContent = `Blueprint default: ${tpl.staticValues[f.id]}`;

                            const revertBtn = document.createElement('button');
                            revertBtn.className = 'btn small';
                            revertBtn.textContent = '‚éå Revert';
                            revertBtn.title = 'Restore template default';
                            revertBtn.onclick = () => {
                                const currentValue = inst.fieldValues[f.id];
                                const defaultValue = tpl.staticValues[f.id];

                                if (confirm(`Replace "${currentValue}" with template default "${defaultValue}"?`)) {
                                    pushUndo();
                                    delete inst.fieldValues[f.id];
                                    save();
                                    renderAll();
                                }
                            };

                            overrideIndicator.appendChild(badge);
                            overrideIndicator.appendChild(originalText);
                            overrideIndicator.appendChild(revertBtn);
                            control.appendChild(overrideIndicator);
                        }
                    }
                } else if (f.fieldKind === FIELD_KIND.ENTITY_REF) {
                    if (isFieldStatic(tpl, f)) {
                        const txt = document.createElement('div');
                        txt.textContent = '(static instanceReference)';
                        txt.className = 'muted';
                        control.appendChild(txt);
                    } else {
                        const ids = inst.fieldValues?.[f.id] || [];

                        // Render existing chips
                        const chipsContainer = document.createElement('div');
                        chipsContainer.style.display = 'flex';
                        chipsContainer.style.flexWrap = 'wrap';
                        chipsContainer.style.gap = '4px';
                        chipsContainer.style.marginBottom = '6px';

                        for (const refId of ids) {
                            const chip = document.createElement('div');
                            chip.className = 'entityref-chip';
                            const target = findInstanceById(refId);
                            if (!target) chip.classList.add('broken');

                            const targetTpl = target ? findBlueprintById(target.templateId) : null;

                            const chipContent = document.createElement('span');

                            // Chip labeling: template name + ID
                            let chipLabel = '???';
                            if (target && targetTpl) {
                                chipLabel = `${targetTpl.name} ${refId.slice(0, 6)}`;
                            } else {
                                chipLabel = 'Deleted instance';
                            }

                            chipContent.textContent = chipLabel;
                            chipContent.style.cursor = target ? 'pointer' : 'default';
                            chipContent.style.flex = '1';

                            // PHASE 1: Add click navigation to chip content
                            if (target) {
                                chipContent.onclick = (e) => {
                                    e.stopPropagation();
                                    handleEntityRefNavigate(refId);
                                };
                                chipContent.onmouseenter = () => {
                                    chipContent.style.textDecoration = 'underline';
                                };
                                chipContent.onmouseleave = () => {
                                    chipContent.style.textDecoration = 'none';
                                };
                            }

                            // Create remove button
                            const removeBtn = document.createElement('span');
                            removeBtn.className = 'remove';
                            removeBtn.textContent = '√ó';
                            removeBtn.onclick = (e) => {
                                e.stopPropagation();
                                // HARDENING: instanceReference removal only affects pointer, never deletes target
                                pushUndo();
                                inst.fieldValues[f.id] = ids.filter(id => id !== refId);
                                save();
                                renderAll();
                            };

                            chip.appendChild(chipContent);
                            chip.appendChild(removeBtn);

                            chip.title = target ?
                                `Click to navigate to ${targetTpl.name} (${refId.slice(0, 8)})` :
                                `‚ö†Ô∏è Broken reference to ${refId.slice(0, 8)}`;
                            chipsContainer.appendChild(chip);
                        }

                        control.appendChild(chipsContainer);

                        // Add reference button
                        const addBtn = document.createElement('button');
                        addBtn.className = 'btn small primary';
                        addBtn.textContent = 'üîó Add Reference';
                        addBtn.onclick = () => {
                            // HARDENING: Pass current instance to exclude self and descendants
                            showInstancePicker(f.cardTypeFilter, (selectedId) => {
                                pushUndo();
                                if (!ids.includes(selectedId)) {
                                    ids.push(selectedId);
                                    inst.fieldValues[f.id] = ids;
                                }
                                save();
                                renderAll();
                            }, inst.id);
                        };
                        control.appendChild(addBtn);
                    }
                } else if (f.fieldKind === FIELD_KIND.LIST_ENTITY_REF) {
                    // LIST_ENTITY_REF: Ordered list of entity references (reuses ENTITY_REF chip semantics)
                    if (isFieldStatic(tpl, f)) {
                        const txt = document.createElement('div');
                        txt.textContent = '(static instanceReferenceList)';
                        txt.className = 'muted';
                        control.appendChild(txt);
                    } else {
                        let ids = inst.fieldValues?.[f.id] || [];

                        // HARDENING: Ensure ids is always an array of strings (not objects)
                        if (Array.isArray(ids)) {
                            ids = ids.map(item => {
                                if (typeof item === 'object' && item !== null && item.id) {
                                    return item.id; // Extract ID from object
                                }
                                return item; // Already a string
                            }).filter(id => typeof id === 'string');

                            // Fix the corruption in the instance permanently
                            if (JSON.stringify(ids) !== JSON.stringify(inst.fieldValues[f.id])) {
                                inst.fieldValues[f.id] = ids;
                                save();
                            }
                        }

                        // Render existing chips (same as ENTITY_REF)
                        const chipsContainer = document.createElement('div');
                        chipsContainer.style.display = 'flex';
                        chipsContainer.style.flexDirection = 'column';  // ‚Üê VERTICAL
                        chipsContainer.style.gap = '4px';
                        chipsContainer.style.marginBottom = '6px';

                        for (let refId of ids) {
                            // HARDENING: Ensure refId is a string (extract ID from object if needed)
                            if (typeof refId === 'object' && refId !== null && refId.id) {
                                refId = refId.id; // Extract ID from instance object
                            }
                            if (typeof refId !== 'string') {
                                console.error('Invalid refId in LIST_ENTITY_REF:', refId);
                                continue; // Skip invalid entries
                            }

                            const chip = document.createElement('div');
                            chip.className = 'entityref-chip';
                            chip.style.display = 'flex';
                            chip.style.alignItems = 'center';
                            chip.style.gap = '4px';
                            const target = findInstanceById(refId);
                            if (!target) chip.classList.add('broken');

                            const targetTpl = target ? findBlueprintById(target.templateId) : null;

                            // STEP 6: Add drag handle
                            const dragHandle = document.createElement('span');
                            dragHandle.className = 'drag-handle';
                            dragHandle.textContent = '‚ãÆ‚ãÆ';
                            dragHandle.draggable = true;
                            dragHandle.style.cursor = 'grab';
                            dragHandle.title = 'Drag to reorder';

                            const chipIndex = ids.indexOf(refId);

                            dragHandle.ondragstart = (e) => {
                                e.stopPropagation();
                                dragHandle.style.cursor = 'grabbing';
                                e.dataTransfer.effectAllowed = 'move';
                                e.dataTransfer.setData('text/plain', JSON.stringify({
                                    type: 'list-entity-ref-reorder',
                                    instanceId: inst.id,
                                    fieldId: f.id,
                                    sourceIndex: chipIndex,
                                    refId: refId
                                }));
                            };

                            dragHandle.ondragend = (e) => {
                                dragHandle.style.cursor = 'grab';
                            };

                            chip.ondragover = (e) => {
                                e.preventDefault();
                                e.dataTransfer.dropEffect = 'move';
                                chip.style.borderTop = '2px solid var(--accent)';
                            };

                            chip.ondragleave = (e) => {
                                chip.style.borderTop = '';
                            };

                            chip.ondrop = (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                chip.style.borderTop = '';

                                try {
                                    const data = JSON.parse(e.dataTransfer.getData('text/plain'));

                                    // STEP 6: Validate same field only
                                    if (data.type !== 'list-entity-ref-reorder') return;
                                    if (data.instanceId !== inst.id) return;
                                    if (data.fieldId !== f.id) return;

                                    const sourceIndex = data.sourceIndex;
                                    const targetIndex = chipIndex;

                                    if (sourceIndex === targetIndex) return;

                                    // Reorder array
                                    pushUndo();
                                    const newIds = [...ids];
                                    const [movedItem] = newIds.splice(sourceIndex, 1);
                                    newIds.splice(targetIndex, 0, movedItem);
                                    inst.fieldValues[f.id] = newIds;
                                    save();
                                    renderAll();

                                } catch (err) {
                                    console.error('Drop failed:', err);
                                }
                            };

                            chip.appendChild(dragHandle);

                            // Create chip content wrapper (clickable)
                            const chipContent = document.createElement('span');

                            // Chip labeling: template name + ID
                            let chipLabel = '???';
                            if (target && targetTpl) {
                                chipLabel = `${targetTpl.name} ${refId.slice(0, 6)}`;
                            } else {
                                chipLabel = 'Deleted instance';
                            }

                            // Add number prefix for ordered list
                            chipContent.textContent = `${chipIndex + 1}. ${chipLabel}`;

                            chipContent.textContent = chipLabel;
                            chipContent.style.cursor = target ? 'pointer' : 'default';
                            chipContent.style.flex = '1';

                            // Click navigation (same as ENTITY_REF)
                            if (target) {
                                chipContent.onclick = (e) => {
                                    e.stopPropagation();
                                    handleEntityRefNavigate(refId);
                                };
                                chipContent.onmouseenter = () => {
                                    chipContent.style.textDecoration = 'underline';
                                };
                                chipContent.onmouseleave = () => {
                                    chipContent.style.textDecoration = 'none';
                                };
                            }

                            // Create remove button
                            const removeBtn = document.createElement('span');
                            removeBtn.className = 'remove';
                            removeBtn.textContent = '√ó';
                            removeBtn.onclick = (e) => {
                                e.stopPropagation();
                                console.log('üóëÔ∏è Remove button clicked');
                                console.log('  refId to remove:', refId);
                                console.log('  Current ids array:', ids);
                                console.log('  Field ID:', f.id);

                                // Remove only this reference from the list
                                pushUndo();
                                const newIds = ids.filter(id => id !== refId);
                                console.log('  New ids array:', newIds);
                                inst.fieldValues[f.id] = newIds;
                                save();
                                renderAll();
                            };

                            chip.appendChild(chipContent);
                            chip.appendChild(removeBtn);

                            chip.title = target ?
                                `Click to navigate to ${targetTpl.name} (${refId.slice(0, 8)})` :
                                `‚ö†Ô∏è Broken reference to ${refId.slice(0, 8)}`;
                            chipsContainer.appendChild(chip);
                        }

                        control.appendChild(chipsContainer);

                        // Add reference button (with duplicate prevention)
                        const addBtn = document.createElement('button');
                        addBtn.className = 'btn small primary';
                        addBtn.textContent = 'üîó Add Reference';
                        addBtn.onclick = () => {
                            console.log('üîµ Add Reference button clicked');
                            console.log('Field:', f.name);
                            console.log('BlueprintTypeFilter:', f.cardTypeFilter);
                            console.log('Current instance ID:', inst.id);

                            showInstancePicker(f.cardTypeFilter, (selectedId) => {
                                console.log('üü¢ Picker callback executed with selectedId:', selectedId);
                                console.log('Current IDs array:', ids);
                                console.log('Duplicate check:', ids.includes(selectedId));

                                if (!ids.includes(selectedId)) {
                                    console.log('‚úÖ Adding new reference');
                                    pushUndo();
                                    ids.push(selectedId);
                                    inst.fieldValues[f.id] = ids;
                                    save();
                                    renderAll();
                                } else {
                                    console.log('‚ùå DUPLICATE DETECTED');
                                    alert('This reference already exists in the list.');
                                }
                            }, inst.id);

                            console.log('üîµ showInstancePicker called');
                        };
                        control.appendChild(addBtn);
                    }
                } else if (f.fieldKind === FIELD_KIND.CARD_REF || f.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                    const merged = getMergedChildrenWithProvenance(tpl, inst, f.id);

                    for (const item of merged) {
                        // HARDENING: Skip static shapes in runtime rendering
                        if (isStaticInstanceShape(item.child)) {
                            const ghost = document.createElement('div');
                            ghost.className = 'instance-card static-ghost';
                            ghost.textContent = 'üëª Static template default';
                            ghost.title = 'Static children are defined in template, not runtime';
                            control.appendChild(ghost);
                            continue;
                        }

                        const childBlueprint = renderInstanceBlueprint(
                            item.child, inst, f, item.origin, new Set(visited)
                        );
                        control.appendChild(childBlueprint);
                    }

                    if (!isFieldStatic(tpl, f)) {
                        if (f.fieldKind === FIELD_KIND.CARD_REF && merged.length === 0) {
                            const btnRow = document.createElement('div');
                            btnRow.style.display = 'flex';
                            btnRow.style.gap = '6px';

                            if (isContainField(f)) {
                                const moveBtn = document.createElement('button');
                                moveBtn.className = 'btn small';
                                moveBtn.textContent = '‚Ü™Ô∏è Move Existing';
                                moveBtn.title = 'Move an orphaned instance here';
                                moveBtn.onclick = () => {
                                    showInstancePicker(f.cardTypeFilter, (selectedId) => {
                                        pushUndo();
                                        const result = moveInstance(selectedId, inst.id, f.id);
                                        if (!result.success) {
                                            alert('Move failed: ' + result.error);
                                        } else {
                                            console.log(`Moved instance ${selectedId.slice(0, 8)} to ${inst.id.slice(0, 8)}.${f.name}`);
                                        }
                                        save();
                                        renderAll();
                                    }, inst.id, true);  // showOnlyOrphans = true
                                };
                                btnRow.appendChild(moveBtn);
                            }

                            if (isReferenceField(f)) {
                                const linkBtn = document.createElement('button');
                                linkBtn.className = 'btn small primary';
                                linkBtn.textContent = 'üîó Link Existing';
                                linkBtn.onclick = () => {
                                    // HARDENING: Exclude self and descendants
                                    showInstancePicker(f.cardTypeFilter, (selectedId) => {
                                        pushUndo();
                                        inst.fieldValues[f.id] = selectedId;
                                        save();
                                        renderAll();
                                    }, inst.id);
                                };
                                btnRow.appendChild(linkBtn);
                            }

                            const sel = document.createElement('select');
                            sel.classList.add('valueInputDark');
                            const emptyOpt = document.createElement('option');
                            emptyOpt.value = '';
                            emptyOpt.textContent = isReferenceField(f) ? 'Create New...' : 'Add...';
                            sel.appendChild(emptyOpt);
                            for (const cand of state.blueprints.filter(tt => tt.type === f.cardTypeFilter && tt.type !== 'Root')) {
                                const o = document.createElement('option');
                                o.value = cand.id;
                                o.textContent = cand.name;
                                sel.appendChild(o);
                            }
                            sel.onchange = () => {
                                if (!sel.value) return;
                                pushUndo();
                                const newInst = createInstance(sel.value, inst.id, f.id);

                                // HARDENING: Always modify registry instance, not embedded copy
                                const registryParent = state.instances[inst.id];

                                // FIXED: Both contain and reference mode now store IDs
                                registryParent.fieldValues[f.id] = newInst.id;
                                if (newInst) editorCollapsed[newInst.id] = true;
                                save();
                                renderAll();
                            };
                            btnRow.appendChild(sel);
                            control.appendChild(btnRow);
                        } else if (f.fieldKind === FIELD_KIND.LIST_OF_CARDS) {
                            const addRow = document.createElement('div');
                            addRow.style.display = 'flex';
                            addRow.style.gap = '6px';
                            addRow.style.marginTop = '6px';

                            if (isReferenceField(f)) {
                                const linkBtn = document.createElement('button');
                                linkBtn.className = 'btn small primary';
                                linkBtn.textContent = 'üîó Link Existing';
                                linkBtn.onclick = () => {
                                    // HARDENING: Exclude self and descendants
                                    showInstancePicker(f.cardTypeFilter, (selectedId) => {
                                        pushUndo();
                                        const arr = inst.fieldValues[f.id] || [];
                                        if (!arr.includes(selectedId)) {
                                            arr.push(selectedId);
                                            inst.fieldValues[f.id] = arr;
                                        }
                                        save();
                                        renderAll();
                                    }, inst.id);
                                };
                                addRow.appendChild(linkBtn);
                            }

                            const addSel = document.createElement('select');
                            addSel.classList.add('valueInputDark');
                            const emptyOpt = document.createElement('option');
                            emptyOpt.value = '';
                            emptyOpt.textContent = isReferenceField(f) ? 'Create New...' : 'Add...';
                            addSel.appendChild(emptyOpt);
                            for (const cand of state.blueprints.filter(tt => tt.type === f.cardTypeFilter && tt.type !== 'Root')) {
                                const o = document.createElement('option');
                                o.value = cand.id;
                                o.textContent = cand.name;
                                addSel.appendChild(o);
                            }
                            addSel.onchange = () => {
                                if (!addSel.value) return;
                                pushUndo();
                                const ni = createInstance(addSel.value, inst.id, f.id);
                                if (ni) {
                                    editorCollapsed[ni.id] = true;

                                    // HARDENING: Always modify registry instance, not embedded copy
                                    const registryParent = state.instances[inst.id];

                                    // HARDENING: Initialize field as array if missing or invalid
                                    if (!Array.isArray(registryParent.fieldValues[f.id])) {
                                        registryParent.fieldValues[f.id] = [];
                                    }

                                    // Push new instance ID
                                    registryParent.fieldValues[f.id].push(ni.id);
                                }
                                save();
                                renderAll();
                            };
                            addRow.appendChild(addSel);
                            control.appendChild(addRow);
                        }
                    }
                }

                row.appendChild(label);
                row.appendChild(control);
                body.appendChild(row);
            }

            card.appendChild(body);
            return card;
        }



        // ============================================================================
        // ORPHAN CLEANUP
        // ============================================================================

        /**
         * Delete all orphaned instances from the registry.
         * Orphaned instances exist in registry but are unreachable from root.
         */
        function cleanupOrphans() {
            const reachable = collectReachableInstances();
            const orphans = Object.keys(state.instances).filter(id =>
                id !== state.rootInstanceId && !reachable.has(id)
            );

            if (orphans.length === 0) {
                alert('‚úÖ No orphaned instances found!\n\nThe registry is clean.');
                return;
            }

            // Show orphan details
            const orphanDetails = orphans.map(id => {
                const inst = state.instances[id];
                const tpl = findBlueprintById(inst.templateId);
                return `  ‚Ä¢ ${tpl?.name || 'Unknown'} (${id.slice(0, 8)})`;
            }).join('\n');

            const confirmMsg =
                `Found ${orphans.length} orphaned instance(s):\n\n${orphanDetails}\n\n` +
                `Delete these instances?\n\n` +
                `‚ö†Ô∏è This cannot be undone (except via Undo).`;

            if (confirm(confirmMsg)) {
                pushUndo();
                orphans.forEach(id => delete state.instances[id]);
                save();
                renderAll();
                alert(`‚úÖ Deleted ${orphans.length} orphaned instance(s).`);
            }
        }

        // ============================================================================
        // EVENT HANDLERS (HARDENED)
        // ============================================================================

        document.getElementById('newBlueprintBtn').addEventListener('click', () => {
            const t = createBlueprint('New', 'Generic');
            navigateTo('template', t.id);
        });

        document.getElementById('exportBtn').addEventListener('click', exportJSON);

        document.getElementById('importBtn').addEventListener('click', () =>
            document.getElementById('fileInput').click()
        );

        document.getElementById('fileInput').addEventListener('change', (ev) => {
            const f = ev.target.files[0];
            if (f) importJSONFile(f);
            ev.target.value = '';
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('undoBtn').addEventListener('click', () => undo());

        document.getElementById('redoBtn').addEventListener('click', () => redo());

        document.getElementById('backBtn').addEventListener('click', () => navigateBack());

        document.getElementById('forwardBtn').addEventListener('click', () => navigateForward());

        document.getElementById('cleanupOrphansBtn').addEventListener('click', () => {
            cleanupOrphans();
        });

        // HARDENING: Enhanced validation display
        document.getElementById('validateBtn').addEventListener('click', () => {
            const result = validateState();
            lastValidationResult = result;

            const msg = [];

            if (result.valid) {
                msg.push('‚úÖ VALIDATION PASSED!\n\nNo errors found.');
                validationWarningsVisible = false;
            } else {
                msg.push('‚ùå VALIDATION FAILED\n');
                msg.push(`Found ${result.errors.length} error(s)\n`);
                msg.push('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
                msg.push('ERRORS:\n');
                msg.push(result.errors.slice(0, 15).join('\n'));
                if (result.errors.length > 15) {
                    msg.push(`\n... and ${result.errors.length - 15} more errors`);
                }
                validationWarningsVisible = true;
            }

            if (result.warnings.length > 0) {
                msg.push('\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
                msg.push(`WARNINGS (${result.warnings.length}):\n`);
                msg.push(result.warnings.slice(0, 10).join('\n'));
                if (result.warnings.length > 10) {
                    msg.push(`\n... and ${result.warnings.length - 10} more warnings`);
                }
            }

            // HARDENING: Additional integrity checks
            const reachable = collectReachableInstances();
            const registryIds = Object.keys(state.instances);
            const orphaned = registryIds.filter(id => id !== state.rootInstanceId && !reachable.has(id));

            if (orphaned.length > 0) {
                msg.push('\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
                msg.push(`ORPHANED INSTANCES: ${orphaned.length}\n`);
                msg.push('(Instances in registry but unreachable from root)\n');
                msg.push(orphaned.slice(0, 5).map(id => `  ‚Ä¢ ${id.slice(0, 8)}`).join('\n'));
                if (orphaned.length > 5) {
                    msg.push(`\n  ... and ${orphaned.length - 5} more`);
                }
            }

            alert(msg.join('\n'));
            renderAll();
        });

        el.templateSearch.addEventListener('input', () => renderLibrary());

        el.verboseToggle.addEventListener('change', () => {
            verboseMode = el.verboseToggle.checked;
            renderHierarchy();
        });

        // HARDENING: Keyboard shortcuts
        window.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) {
                e.preventDefault();
                redo();
            }
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
                e.preventDefault();
                save();
                alert('Saved');
            }
            if (e.altKey && e.key === 'ArrowLeft') {
                e.preventDefault();
                navigateBack();
            }
            if (e.altKey && e.key === 'ArrowRight') {
                e.preventDefault();
                navigateForward();
            }
            // HARDENING: Ctrl+Shift+V for validation
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'v') {
                e.preventDefault();
                document.getElementById('validateBtn').click();
            }
        });

        // HARDENING: Drag & Drop for instance moves
        document.addEventListener('dragover', (e) => {
            // Allow drop on specific targets only
            e.preventDefault();
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();

            try {
                const data = JSON.parse(e.dataTransfer.getData('text/plain'));

                // HARDENING: Only handle instance moves, never blueprints
                if (data.type !== 'instance-move') {
                    return;
                }

                // HARDENING: Implement explicit move validation
                // For now, drag & drop in tree is disabled for safety
                // User must use explicit "Move" operations if we add them
                console.log('Drag & drop moves disabled for integrity. Use explicit move operations.');

            } catch (err) {
                // Invalid drag data, ignore
            }
        });

        // HARDENING: Detailed duplicate analysis
        function analyzeDuplicates() {
            console.group('Duplicate Analysis');

            // Check registry
            const registryIds = Object.keys(state.instances);
            console.log('Registry IDs:', registryIds);
            console.log('Registry size:', registryIds.length);
            console.log('Unique registry IDs:', new Set(registryIds).size);

            // Check for object identity duplicates (same UUID, different objects)
            const idToObjects = {};
            for (const id in state.instances) {
                const inst = state.instances[id];
                if (!idToObjects[inst.id]) {
                    idToObjects[inst.id] = [];
                }
                idToObjects[inst.id].push(inst);
            }

            const identityDuplicates = [];
            for (const id in idToObjects) {
                if (idToObjects[id].length > 1) {
                    identityDuplicates.push({
                        id: id,
                        count: idToObjects[id].length,
                        objects: idToObjects[id]
                    });
                }
            }

            if (identityDuplicates.length > 0) {
                console.error('Identity duplicates found:', identityDuplicates);
            } else {
                console.log('‚úÖ No identity duplicates');
            }

            console.groupEnd();
        }

        // ============================================================================
        // BOOT (HARDENED)
        // ============================================================================

        (function boot() {
            console.log('DharmaForge v1.0 - Booting...');

            const ok = load();
            if (!ok) {
                console.log('No saved state, initializing sample data...');
                initSampleIfEmpty();
                // HARDENING: Do NOT call migrateState on fresh init
            } else {
                if (!state.rootInstanceId) {
                    console.warn('Loaded state has no root, initializing...');
                    initSampleIfEmpty();
                } else {
                    migrateState(state); // Only migrate loaded state
                }

                // HARDENING: Auto-validate on boot
                console.log('Running integrity validation on boot...');
                const validation = validateState();
                // ... validation logic
            }

            // HARDENING: Check for duplicate IDs
            const duplicates = findDuplicateIds();
            if (duplicates.length > 0) {
                console.error('‚ö†Ô∏è BOOT: Duplicate instance IDs detected:', duplicates);
            }

            if (state.rootInstanceId) {
                navigateTo('instance', state.rootInstanceId, false);
            }

            analyzeDuplicates();
            renderAll();
            updateUndoButtons();
            updateNavButtons();

            console.log('DharmaForge v1.0 - Ready');
        })();

    </script>
</body>

</html>