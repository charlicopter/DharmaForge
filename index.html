<!doctype html>
<html lang="en">

<head>

    <script src="https://cdn.jsdelivr.net/npm/marked@15/lib/marked.umd.js"></script>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>DharmaForge ‚Äî v1.0 ‚Äî By Charles Cushing</title>
    <style>
        :root {
            --bg: #0b0f13;
            --panel: #0f1518;
            --panel-2: #0c1113;
            --muted: #9aa6b0;
            --text: #e6eef6;
            --accent: #4da3ff;
            --glow: rgba(77, 163, 255, 0.12);
            --border: rgba(255, 255, 255, 0.06);
            --danger: #ff6b6b;
            --success: #6ee7b7;
            --reference: #fbbf24;
            --warning: #fbbf24;
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: linear-gradient(180deg, #071018 0%, #0b0f13 100%);
            color: var(--text);
            font-size: 13px
        }

        .app {
            height: 100vh;
            display: flex;
            flex-direction: column
        }

        header {
            padding: 10px 14px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), transparent);
        }

        header h1 {
            flex: 0 0 auto;
        }

        header .nav-buttons {
            flex: 1;
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        header .top-controls {
            flex: 0 0 auto;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        h1 {
            margin: 0;
            font-size: 15px
        }

        .top-controls {
            margin-left: auto;
            display: flex;
            gap: 8px;
            align-items: center
        }

        main {
            flex: 1;
            display: flex;
            gap: 4px;
            padding: 8px;
            box-sizing: border-box;
            min-height: 0
        }

        .pane {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), transparent);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 6px 30px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            min-width: 0;
            overflow: hidden
        }

        .left {
            width: var(--left-width, 410px);
            flex: 0 0 var(--left-width, 410px);
            min-width: 200px;
            max-width: 800px
        }

        .center {
            flex: 1;
            min-width: 360px
        }

        .right {
            width: var(--right-width, 220px);
            flex: 0 0 var(--right-width, 220px);
            min-width: 180px;
            max-width: 600px
        }

        .pane .title {
            font-size: 13px;
            color: var(--muted);
            margin-bottom: 8px;
            flex-shrink: 0
        }

        .tree {
            overflow: auto;
            flex: 1;
            padding-right: 6px;
            min-height: 0;
            overflow-x: auto;
            overflow-y: auto
        }

        .blueprint-list {
            overflow: auto;
            flex: 1;
            min-height: 0
        }

        .card-row {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), transparent);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer
        }

        .card-row:hover {
            box-shadow: 0 0 0 6px var(--glow)
        }

        .card-row.selected {
            box-shadow: 0 0 0 8px rgba(77, 163, 255, 0.14);
            outline: 2px solid rgba(77, 163, 255, 0.06)
        }

        .card-row.has-warnings {
            background: rgba(251, 191, 36, 0.08) !important;
            border-color: rgba(251, 191, 36, 0.3) !important;
        }

        .card-row.has-errors {
            background: rgba(255, 107, 107, 0.08) !important;
            border-color: rgba(255, 107, 107, 0.3) !important;
        }

        .issue-badge {
            font-size: 11px;
            margin-left: 6px;
            opacity: 0.9;
        }

        .card-name {
            font-weight: 600
        }

        .card-type {
            font-size: 12px;
            color: var(--muted);
            margin-left: 6px
        }

        .btn.warning {
            background: #f5c542;
            color: #333;
            border: 1px solid #d4a832;
        }

        .btn.disabled {
            opacity: 0.6;
            cursor: not-allowed;
            pointer-events: none;
        }

        .field-line {
            background: transparent;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            z-index: 1;
            display: flex;
            gap: 6px;
            align-items: center;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .field-key {
            min-width: 100px;
            max-width: 180px;
            color: var(--muted);
            font-size: 12px;
            flex-shrink: 0;

            /* critical */
            display: block;
            padding-top: 0;
        }

        .field-control {
            flex: 1;
            min-width: 0;
        }

        .field-control-inner {
            display: flex;
            flex-direction: column;

            /* THIS is the alignment anchor */
            padding-top: 0;
        }

        /* HARD RULE: first visible control line starts at 0 */
        .field-control-inner>*:first-child {
            margin-top: 0 !important;
        }

        .field-toggle-btn {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text);
        }

        .field-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            opacity: 1 !important;
        }

        input[type=text],
        input[type=number],
        select,
        textarea {
            background: #071018;
            border: 1px solid var(--border);
            padding: 4px 6px;
            border-radius: 4px;
            color: var(--text);
            outline: none;
            min-width: 0;
            width: 100%;
            box-sizing: border-box;
            line-height: 1.2;
            font-size: 13px;
            height: auto;
            margin: 0;
        }

        select option {
            background: #071018;
            color: var(--text)
        }

        /* Textarea editor */
        /* Textarea editor - matches DF aesthetic */
        textarea {
            background: var(--panel-2);
            color: var(--text);
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
            line-height: 1.4;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid var(--border);
            width: 100%;
            box-sizing: border-box;
            font-size: 13px;
            resize: none;
            /* Disable default resize */
            transition: all 0.2s ease;
        }

        textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(77, 163, 255, 0.1);
        }

        /* Collapsed state - compact like instance card */
        textarea.collapsed {
            height: 60px;
            overflow: hidden;
        }

        /* Expanded state - large working area */
        textarea.expanded {
            min-height: 200px;
            max-height: 70vh;
            /* Can grow to 70% of viewport */
            overflow-y: auto;
        }

        /* ============================================================================
   MARKDOWN PREVIEW
   ============================================================================ */

        .markdown-preview {
            background: var(--panel-2);
            color: var(--text);
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
            padding: 6px;
            border-radius: 6px;
            border: 1px solid var(--border);
            line-height: 1.3;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 13px;
            transition: all 0.2s ease;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* Markdown content styling */
        .markdown-preview p {
            margin: 0 0 0.25em 0;
        }

        .markdown-preview p:last-child {
            margin-bottom: 0;
        }

        .markdown-preview strong {
            font-weight: 600;
            color: #fff;
        }

        .markdown-preview em {
            font-style: italic;
        }

        .markdown-preview code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .markdown-preview pre {
            background: rgba(0, 0, 0, 0.3);
            padding: 6px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 0.2em 0;
        }

        .markdown-preview pre code {
            background: none;
            padding: 0;
        }

        .markdown-preview a {
            color: var(--accent);
            text-decoration: none;
        }

        .markdown-preview a:hover {
            text-decoration: underline;
        }

        .markdown-preview ul,
        .markdown-preview ol {
            margin: 0.2em 0;
            padding-left: 1.2em;
        }

        .markdown-preview li {
            margin: 0.1em 0;
        }

        .markdown-preview h1,
        .markdown-preview h2,
        .markdown-preview h3 {
            margin: 0.15em 0 0.1em 0;
            color: #fff;
            font-weight: 600;
            line-height: 1.1;
        }

        .markdown-preview h1 {
            font-size: 1.6em;
        }

        .markdown-preview h2 {
            font-size: 1.3em;
        }

        .markdown-preview h3 {
            font-size: 1.15em;
        }

        .markdown-preview blockquote {
            border-left: 3px solid var(--accent);
            padding-left: 10px;
            margin: 0.2em 0;
            color: var(--muted);
        }

        /* ============================================================================
   EXPAND/COLLAPSE BUTTON
   ============================================================================ */

        .expand-toggle {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            font-size: 11px;
            padding: 4px 8px;
            margin-top: 4px;
            cursor: pointer;
            color: var(--muted);
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .expand-toggle:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text);
            border-color: rgba(255, 255, 255, 0.12);
        }

        /* ============================================================================
   RESIZE HANDLES
   ============================================================================ */

        .resize-container {
            position: relative;
            width: 100%;
        }

        .resize-handle {
            position: absolute;
            background: rgba(255, 255, 255, 0.03);
            /* More subtle default */
            transition: background 0.15s ease;
            /* Slightly faster, smoother */
            z-index: 5;
        }

        .resize-handle:hover {
            background: rgba(255, 255, 255, 0.10);
            /* Slightly less bright on hover */
        }

        /* Top handle */
        .resize-handle.top {
            width: 100%;
            height: 4px;
            top: 0;
            left: 0;
            cursor: ns-resize;
            border-radius: 3px 3px 0 0;
            /* Slightly smaller radius */
        }

        .resize-handle.top::before {
            content: '‚ãÆ';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            color: var(--muted);
            font-size: 7px;
            /* Slightly smaller */
            letter-spacing: 1px;
            opacity: 0.6;
            /* More subtle */
        }

        .resize-handle.top:hover::before {
            opacity: 1;
            /* Full opacity on hover */
        }

        /* Bottom handle */
        .resize-handle.bottom {
            width: 100%;
            height: 4px;
            bottom: 0;
            left: 0;
            cursor: ns-resize;
            border-radius: 0 0 3px 3px;
        }

        .resize-handle.bottom::before {
            content: '‚ãÆ';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) rotate(90deg);
            color: var(--muted);
            font-size: 7px;
            letter-spacing: 1px;
            opacity: 0.6;
        }

        .resize-handle.bottom:hover::before {
            opacity: 1;
        }

        /* Right handle */
        .resize-handle.right {
            width: 3px;
            /* Slightly thicker - easier to grab */
            height: 60px;
            /* Shorter - less intrusive */
            top: 50%;
            transform: translateY(-50%);
            right: 0px;
            cursor: ew-resize;
            border-radius: 2px 0 0 2px;
            /* Rounded on left side only */
        }

        .resize-handle.right:hover {
            width: 4px;
            /* Expands slightly on hover */
        }

        /* Corner handle */
        .resize-handle.corner.bottom-right {
            width: 10px;
            /* Slightly larger - easier to grab */
            height: 10px;
            bottom: 0;
            right: 0;
            cursor: se-resize;
            background: rgba(255, 255, 255, 0.06);
            /* Slightly more visible */
            border-radius: 0 0 3px 0;
            z-index: 10;
        }

        .resize-handle.corner.bottom-right:hover {
            background: rgba(255, 255, 255, 0.18);
            /* More obvious on hover */
            width: 12px;
            /* Grows on hover */
            height: 12px;
        }

        /* Textarea */
        .resize-container textarea {
            width: 100%;
            box-sizing: border-box;
        }


        .valueInputDark {
            background: #061018 !important;
            color: #f6fbff !important;
            border: 1px solid rgba(255, 255, 255, 0.08) !important;
            padding: 6px 8px !important;
            border-radius: 6px !important;
            min-width: 0 !important;
            width: 100% !important;
            box-sizing: border-box !important;
        }

        .muted {
            color: var(--muted)
        }

        .btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.06);
            padding: 8px 10px;
            border-radius: 8px;
            cursor: pointer;
            color: var(--text)
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed
        }

        .btn.primary {
            background: linear-gradient(90deg, rgba(77, 163, 255, 0.08), rgba(99, 102, 241, 0.06));
            border-color: rgba(77, 163, 255, 0.18)
        }

        .btn.danger {
            border-color: rgba(255, 107, 107, 0.18)
        }

        .small {
            font-size: 12px;
            padding: 6px 8px
        }

        .editor {
            overflow-x: auto;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
            min-width: 0
        }

        .editor-content {
            min-width: max-content;
            padding-right: 20px
        }

        .editor-mode-indicator {
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 12px;
            font-size: 12px;
            font-weight: 600;
            display: inline-block
        }

        .editor-mode-hierarchy {
            background: rgba(77, 163, 255, 0.08);
            color: var(--accent);
            border: 1px solid rgba(77, 163, 255, 0.12)
        }

        .editor-mode-library {
            background: rgba(110, 231, 183, 0.08);
            color: var(--success);
            border: 1px solid rgba(110, 231, 183, 0.12)
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 6px
        }

        .field-list {
            margin-top: 8px
        }

        .field-def {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.01);
            margin-bottom: 6px;
            border: 1px solid var(--border)
        }

        /* Static default indicator */
        .field-def.has-default {
            border-left: 3px solid rgba(251, 191, 36, 0.6);
            padding-left: 8px;
            transition: background 0.15s ease;
        }

        .field-def.has-default:hover {
            background: rgba(251, 191, 36, 0.05);
        }

        .field-value {
            display: flex;
            align-items: center;
            /* or flex-start if multiline text */
            min-height: 20px;
            /* stabilizes baseline */
        }

        .search {
            display: flex;
            align-items: center;
            gap: 8px
        }

        .search input {
            flex: 1
        }

        .footer {
            padding: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.02);
            display: flex;
            gap: 8px;
            align-items: center
        }

        .drag-handle {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.06);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            flex-shrink: 0;
            font-size: 10px;
            color: var(--muted)
        }

        .drag-over {
            outline: 2px dashed rgba(77, 163, 255, 0.22) !important;
            background: rgba(77, 163, 255, 0.05) !important
        }

        .list-item {
            border: 1px solid var(--border);
            background: #071018;
            padding: 8px;
            border-radius: 6px;
            color: var(--text);
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px
        }

        .reference-icon {
            color: var(--success);
            font-size: 14px;
            cursor: help;
            flex-shrink: 0;
        }

        .tree-root {
            font-family: inherit;
            user-select: none;
            min-width: min-content;
        }

        .tree-node {
            position: relative;
            padding: 6px 8px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-radius: 6px;
            cursor: pointer;
            min-width: max-content;
        }

        .tree-node:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .tree-node.selected {
            background: rgba(77, 163, 255, 0.08);
            border-radius: 6px;
        }

        .twisty {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--muted);
            flex-shrink: 0
        }

        .twisty:hover {
            color: var(--text);
        }

        .node-label {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
            min-width: 0;
        }

        .tree-branch {
            margin: 0;
            padding: 0;
            list-style: none;
            position: relative;
        }

        .tree-branch>li {
            position: relative;
            padding-left: 18px;
        }

        .tree-branch>li::before {
            content: "";
            position: absolute;
            left: 6px;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(255, 255, 255, 0.03);
        }

        .tree-branch>li>.tree-node::before {
            content: "";
            position: absolute;
            left: 6px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 1px;
            background: rgba(255, 255, 255, 0.03);
        }

        .tree-branch>li:last-child::before {
            bottom: 50%;
        }

        .instance-card {
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.01);
            margin-left: 0 !important;
            min-width: max-content;
            box-sizing: border-box;
        }

        .instance-card.deleted-blueprint {
            border-color: var(--border);
            opacity: 0.8;
        }

        .instance-card.deleted-blueprint .instance-header {
            background: rgba(128, 128, 128, 0.1);
        }

        .instance-card.static-child {
            border-color: rgba(167, 139, 250, 0.2);
            background: rgba(167, 139, 250, 0.02);
        }

        .instance-card.reference-child {
            border-style: dashed;
            border-color: rgba(110, 231, 183, 0.4);
            background: rgba(110, 231, 183, 0.02);
        }

        .broken-reference-child {
            border-style: dashed !important;
            border-color: rgba(251, 191, 36, 0.6) !important;
            background: rgba(251, 191, 36, 0.08) !important;
        }

        .instance-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px;
            border-radius: 6px;
        }

        .instance-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            cursor: pointer;
            min-width: 0;
        }

        .instance-header-left:hover {
            background: rgba(255, 255, 255, 0.02);
        }

        .instance-header-actions {
            display: flex;
            gap: 6px;
            flex-shrink: 0;
        }

        .instance-body {
            margin-top: 8px;
            padding-left: 12px;
            border-left: 2px solid rgba(255, 255, 255, 0.03);
            min-width: max-content;
        }

        .instance-body.collapsed {
            display: none;
        }

        .nav-buttons {
            display: flex;
            gap: 4px;
            margin-right: 8px;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            max-width: 500px;
            max-height: 70vh;
            overflow: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        }

        .modal-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 16px;
        }

        .modal-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 400px;
            overflow: auto;
        }

        .modal-item {
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.01);
        }

        .modal-item:hover {
            background: rgba(77, 163, 255, 0.08);
            border-color: rgba(77, 163, 255, 0.2);
        }

        .modal-item:disabled,
        .modal-item.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            pointer-events: none;
        }

        .modal-footer {
            margin-top: 16px;
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .btn-warning-disabled {
            color: #f5c542 !important;
            border-color: #f5c542 !important;
            background: rgba(245, 197, 66, 0.08) !important;
            cursor: not-allowed;
        }

        .btn-warning-disabled:hover {
            background: rgba(245, 197, 66, 0.08) !important;
        }

        .warning-banner {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 12px;
            font-size: 12px;
            color: var(--warning);
        }

        /* HARDENING: Validation error banner */
        .error-banner {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 12px;
            font-size: 12px;
            color: var(--danger);
        }

        .validation-error {
            background: rgba(255, 80, 80, 0.12);
            border: 1px solid rgba(255, 80, 80, 0.35);
            color: rgb(255, 120, 120);
        }

        .validation-error::before {
            content: '‚óè';
            color: rgb(255, 80, 80);
        }

        .validation-warning {
            background: rgba(255, 200, 0, 0.12);
            border: 1px solid rgba(255, 200, 0, 0.35);
            color: rgb(255, 220, 120);
        }

        .validation-warning::before {
            content: '‚óè';
            color: rgb(255, 200, 0);
        }

        .entityref-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: rgba(77, 163, 255, 0.1);
            border: 1px solid rgba(77, 163, 255, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            margin: 4px 2px;
            font-size: 13px;
            color: var(--accent);
            min-height: 32px;
        }

        .entityref-chip.broken {
            background: rgba(255, 107, 107, 0.15);
            border-color: rgba(255, 107, 107, 0.5);
            color: var(--danger);
            opacity: 1;
            cursor: not-allowed;
        }

        .entityref-chip.broken::before {
            content: '';
            margin-right: 2px;
        }

        .entityref-chip.orphaned {
            background: rgba(251, 191, 36, 0.15);
            border-color: rgba(251, 191, 36, 0.5);
            color: var(--warning);
            opacity: 1;
            cursor: pointer;
        }

        .entityref-chip.orphaned::before {
            content: '';
            margin-right: 2px;
        }

        .entityref-chip.orphaned {
            background: rgba(251, 191, 36, 0.15);
            border-color: rgba(251, 191, 36, 0.5);
            color: var(--warning);
            opacity: 1;
            cursor: pointer;
        }

        .orphaned-reference-child {
            border-style: dashed !important;
            border-color: rgba(251, 191, 36, 0.6) !important;
            background: rgba(251, 191, 36, 0.08) !important;
        }

        .broken-reference-child {
            border-style: dashed !important;
            border-color: rgba(255, 107, 107, 0.6) !important;
            background: rgba(255, 107, 107, 0.08) !important;
        }

        /* Override indicator styling */
        .override-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 6px;
            padding: 6px 8px;
            background: rgba(59, 130, 246, 0.05);
            border-left: 2px solid var(--primary);
            border-radius: 3px;
            font-size: 11px;
        }

        .override-badge {
            color: var(--primary);
            font-weight: 600;
        }

        .override-original {
            color: var(--muted);
            flex: 1;
        }

        .entityref-chip .remove {
            cursor: pointer;
            margin-left: 4px;
            font-weight: bold;
        }

        /* Expandable chip styles */
        .chip-container {
            margin-bottom: 4px;
            width: 100%;
        }

        .chip-twisty {
            display: inline-block;
            width: 14px;
            text-align: center;
            font-size: 11px;
            margin-right: 4px;
            user-select: none;
            transition: transform 0.15s ease;
        }

        .chip-twisty.expandable {
            cursor: pointer;
        }

        .chip-twisty.expandable:hover {
            color: var(--accent);/
        }

        .chip-expanded-view {
            margin-left: 20px;
            padding: 10px;
            margin-top: 6px;
            border-left: 2px solid var(--border);
            background: linear-gradient(180deg, rgba(77, 163, 255, 0.02), transparent);
            border-radius: 6px;
            font-size: 12px;
        }

        @keyframes expandIn {
            from {
                opacity: 0;
                max-height: 0;
                overflow: hidden;
                padding-top: 0;
                padding-bottom: 0;
            }

            to {
                opacity: 1;
                max-height: 600px;
                padding-top: 10px;
                padding-bottom: 10px;
            }
        }

        .chip-field-line {
            display: flex;
            gap: 8px;
            margin-bottom: 4px;
            align-items: baseline;
        }

        .chip-field-key {
            min-width: 90px;
            max-width: 120px;
            color: var(--muted);
            font-weight: 500;
            flex-shrink: 0;
            font-size: 11px;
        }

        .chip-field-value {
            color: var(--text);
            flex: 1;
            word-break: break-word;
        }

        .chip-field-value.clickable {
            cursor: pointer;
            color: var(--accent);
        }

        .chip-field-value.clickable:hover {
            text-decoration: underline;
        }

        .chip-expanded-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border);
        }

        .chip-expanded-title {
            font-weight: 600;
            font-size: 12px;
            color: var(--accent);
        }

        @media(max-width:980px) {
            .left {
                display: none
            }

            .right {
                display: none
            }

            .center {
                flex: 1
            }
        }

        /* ======= DARK SCROLLBARS (Chrome, Edge, Safari) ======= */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.14);
        }

        /* ======= DARK SCROLLBARS (Firefox) ======= */
        * {
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.12) rgba(255, 255, 255, 0.03);
        }

        header .btn:hover {
            background: rgba(255, 255, 255, 0.06);
            border-color: rgba(255, 255, 255, 0.12);
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.08);
            transition: background 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
        }

        /* === RESIZABLE DIVIDERS === */
        .divider {
            width: 4px;
            background: transparent;
            cursor: col-resize;
            position: relative;
            flex-shrink: 0;
            transition: background 0.15s ease;
        }

        .divider:hover {
            background: rgba(77, 163, 255, 0.2);
        }

        .divider:active {
            background: rgba(77, 163, 255, 0.4);
        }

        .divider::before {
            content: '';
            position: absolute;
            top: 0;
            left: -2px;
            right: -2px;
            bottom: 0;
            cursor: col-resize;
        }

        body.resizing {
            cursor: col-resize;
            user-select: none;
        }

        body.resizing * {
            cursor: col-resize !important;
        }
    </style>
</head>

<body>
    <div class="app">
        <header>
            <h1>
                <a href="https://github.com/charlicopter/DharmaForge/tree/WIP?tab=readme-ov-file#a-note-before-you-begin"
                    target="_blank" style="color: inherit; text-decoration: none; cursor: pointer;"
                    title="Learn more about DharmaForge">
                    DharmaForge ‚Äî v1.0 ‚Äî By Charles Cushing
                </a>
            </h1>
            <div class="nav-buttons">
                <button id="backBtn" class="btn small" title="Back">‚óÄ</button>
                <button id="forwardBtn" class="btn small" title="Forward">‚ñ∂</button>
            </div>

            <div class="top-controls">
                <button id="undoBtn" class="btn small">Undo (Ctrl+Z)</button>
                <button id="redoBtn" class="btn small">Redo (Ctrl+Y)</button>
                <button id="exportBtn" class="btn small">Export JSON</button>
                <button id="importBtn" class="btn small">Import JSON</button>
                <button id="validateBtn" class="btn small">Validate</button>
                <button id="cleanupOrphansBtn" class="btn small">Clean Orphans</button>
                <button id="resetBtn" class="btn small">Reset</button>
                <a id="Discord" href="https://discord.gg/NnP3tyG8gQ" target="_blank" class="btn small"
                    style="text-decoration:none;">
                    Discord
                </a>
                <button id="manualBtn" class="btn small">Manual</button>
            </div>
        </header>

        <main>
            <!-- LEFT PANE -->
            <div class="pane left">
                <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
                    <div class="title" style="margin-bottom:0">Instance Hierarchy</div>
                    <label style="display:flex;align-items:center;gap:4px;margin:0;font-size:11px">
                        <input type="checkbox" id="verboseToggle" style="width:auto">
                        <span class="muted">Verbose</span>
                    </label>
                </div>

                <!-- SCROLL CONTAINER -->
                <div class="tree" id="hierarchy" data-scroll-key="hierarchy">
                </div>

                <div class="footer">
                    <div class="muted">
                        Selected: <span id="selectedSummary">‚Äî</span>
                    </div>
                </div>
            </div>

            <!-- DIVIDER -->
            <div class="divider" id="divider-left"></div>

            <!-- CENTER PANE -->
            <div class="pane center">
                <div class="title">Workspace</div>

                <!-- SCROLL CONTAINER -->
                <div class="editor" id="editor" data-scroll-key="editor">
                </div>
            </div>

            <!-- DIVIDER -->
            <div class="divider" id="divider-right"></div>

            <!-- RIGHT PANE -->
            <div class="pane right">
                <div style="display:flex;align-items:center;justify-content:space-between;flex-shrink:0">
                    <div class="title">Blueprint Library</div>
                    <button id="newBlueprintBtn" class="btn small primary">+ New</button>
                </div>

                <div class="search" style="margin:8px 0;flex-shrink:0">
                    <input id="templateSearch" type="text" placeholder="Search blueprints" />
                </div>

                <!-- SCROLL CONTAINER -->
                <div class="blueprint-list" id="templateList" data-scroll-key="library">
                </div>
            </div>
        </main>
    </div>


    <input id="fileInput" type="file" style="display:none" accept="application/json" />

    <script>


        'use strict';

        // Generic top-bar link configuration
        const genericLink = document.getElementById('genericLink');

        // Easy one-liner reconfiguration
        function setTopLink(label, url) {
            genericLink.textContent = label;
            genericLink.href = url;
        }

        // ============================================================================
        // CONSTANTS & ENUMS
        // ============================================================================

        const FIELD_KIND = {
            PRIMITIVE: 'primitive',
            INSTANTIATOR: 'instantiator',
            INSTANTIATOR_LIST: 'instantiatorList',
            INSTANCE_REFERENCE: 'instanceReference',
            INSTANCE_REFERENCE_LIST: 'instanceReferenceList'
        };

        const FIELD_MODE = {
            CONTAIN: 'contain',
            REFERENCE: 'reference'
        };

        const PRIMITIVE_TYPE = {
            TEXT: 'text',
            NUMBER: 'number'
        };

        const STORAGE_KEY = 'DharmaForge_v1';
        const MAX_UNDO = 200;
        const SCHEMA_VERSION = 8; // HARDENING: Bumped for hardened version

        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================

        /**
         * Generate a new UUID v4.
         */
        function generateUUID() {
            if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                return crypto.randomUUID();
            }
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // ============================================================================
        // BLUEPRINT GENERATOR
        // ============================================================================

        function generateBlueprintFromTemplate(instanceId) {
            const inst = findInstanceById(instanceId);
            if (!inst) {
                alert('Template instance not found');
                return;
            }

            const blueprint = findBlueprintById(inst.templateId);
            if (!blueprint || blueprint.name !== 'Blueprint Generator') {
                alert('This is not a Blueprint Generator instance');
                return;
            }

            // Extract blueprint_name and blueprint_type
            let blueprintName = '';
            let blueprintType = '';
            let fieldsFieldId = null;

            for (const field of blueprint.fields) {
                const value = inst.fieldValues[field.id];
                if (field.name === 'blueprint_name') {
                    blueprintName = value || '';
                }
                if (field.name === 'blueprint_type') {
                    blueprintType = value || '';
                }
                if (field.name === 'fields') {
                    fieldsFieldId = field.id;
                }
            }

            // Validate basic fields
            if (!blueprintName.trim()) {
                alert('Blueprint name is required');
                return;
            }
            if (!fieldsFieldId) {
                alert('Fields configuration not found');
                return;
            }

            // Get Field Spec instances
            const fieldSpecIds = inst.fieldValues[fieldsFieldId] || [];
            if (!Array.isArray(fieldSpecIds) || fieldSpecIds.length === 0) {
                alert('No fields defined. Add Field Spec instances first.');
                return;
            }

            // Read each Field Spec
            const fieldSpecs = [];
            for (const specId of fieldSpecIds) {
                const specInst = findInstanceById(specId);
                if (!specInst) continue;

                const specBlueprint = findBlueprintById(specInst.templateId);
                if (!specBlueprint) continue;

                let fieldName = '';
                let fieldType = 'text'; // default
                let allowedTypes = '';

                for (const f of specBlueprint.fields) {
                    const val = specInst.fieldValues[f.id];
                    if (f.name === 'field_name') fieldName = val || '';
                    if (f.name === 'field_type') fieldType = val || 'text';
                    if (f.name === 'allowed_types') allowedTypes = val || '';
                }

                if (!fieldName.trim()) {
                    alert(`Field Spec ${specId.slice(0, 8)} has no field_name`);
                    return;
                }

                fieldSpecs.push({
                    name: fieldName.trim(),
                    type: fieldType.trim().toLowerCase(),
                    allowedTypes: allowedTypes.trim()
                });
            }

            // Check for duplicate blueprint name
            const existing = state.blueprints.find(bp => bp.name === blueprintName.trim());
            if (existing) {
                if (!confirm(`Blueprint "${blueprintName}" already exists. Overwrite?`)) {
                    return;
                }
                state.blueprints = state.blueprints.filter(bp => bp.id !== existing.id);
            }

            // Map field types to DharmaForge field kinds
            const newFields = [];
            for (const spec of fieldSpecs) {
                const fieldDef = {
                    id: generateUUID(),
                    name: spec.name
                };

                // Map type string to field kind
                switch (spec.type) {
                    case '[txt]':
                        fieldDef.fieldKind = FIELD_KIND.PRIMITIVE;
                        fieldDef.primitiveType = PRIMITIVE_TYPE.TEXT;
                        break;
                    case '[num]':
                        fieldDef.fieldKind = FIELD_KIND.PRIMITIVE;
                        fieldDef.primitiveType = PRIMITIVE_TYPE.NUMBER;
                        break;
                    case '[ref]':
                        fieldDef.fieldKind = FIELD_KIND.INSTANCE_REFERENCE;
                        fieldDef.allowedTemplateIds = parseAllowedTypes(spec.allowedTypes);
                        fieldDef.blueprintTypeFilter = inferBlueprintType(spec.allowedTypes);
                        break;
                    case '[ref_list]':
                        fieldDef.fieldKind = FIELD_KIND.INSTANCE_REFERENCE_LIST;
                        fieldDef.allowedTemplateIds = parseAllowedTypes(spec.allowedTypes);
                        break;
                    case '[inst]':
                        fieldDef.fieldKind = FIELD_KIND.INSTANTIATOR;
                        fieldDef.allowedTemplateIds = parseAllowedTypes(spec.allowedTypes);
                        fieldDef.blueprintTypeFilter = inferBlueprintType(spec.allowedTypes);
                        break;
                    case '[inst_list]':
                        fieldDef.fieldKind = FIELD_KIND.INSTANTIATOR_LIST;
                        fieldDef.allowedTemplateIds = parseAllowedTypes(spec.allowedTypes);
                        break;
                    default:
                        alert(`Unknown field type: ${spec.type}. Using text.`);
                        fieldDef.fieldKind = FIELD_KIND.PRIMITIVE;
                        fieldDef.primitiveType = PRIMITIVE_TYPE.TEXT;
                }

                newFields.push(fieldDef);
            }

            // Create blueprint
            const newBlueprint = {
                id: generateUUID(),
                name: blueprintName.trim(),
                type: blueprintType.trim() || 'Generated',
                isStatic: false,
                staticValues: {},
                fields: newFields
            };

            // Add to state
            pushUndo();
            state.blueprints.push(newBlueprint);
            invalidateBlueprintMap();
            save();
            renderAll();

            alert(`‚úÖ Blueprint "${blueprintName}" created with ${newFields.length} fields!`);
        }

        // Helper: Create type filter dropdown with validation
        function createTypeFilterDropdown(field, parentInst, isList = false) {
            const sel = document.createElement('select');
            sel.classList.add('valueInputDark');

            const emptyOpt = document.createElement('option');
            emptyOpt.value = '';
            const filterType = field.blueprintTypeFilter;

            // Check filter validity
            const validTypes = new Set(
                state.blueprints
                    .map(t => t.type)
                    .filter(t => t && typeof t === 'string' && t.trim() !== '' && t !== 'Root')
            );

            const hasNoFilter = !filterType || filterType === null || filterType === '';
            const filterOrphaned = filterType && !validTypes.has(filterType);

            if (hasNoFilter) {
                emptyOpt.textContent = '‚ö†Ô∏è No type selected';
                emptyOpt.style.color = 'var(--warning)';
                sel.disabled = true;
                sel.style.cssText = 'border: 1px solid var(--warning) !important; background: rgba(251, 191, 36, 0.08) !important;';
                sel.title = 'Blueprint field has no type filter - edit blueprint to fix';
            } else if (filterOrphaned) {
                emptyOpt.textContent = `üî¥ Category "${filterType}" not found`;
                emptyOpt.style.color = 'var(--danger)';
                sel.disabled = true;
                sel.style.cssText = 'border: 1px solid var(--danger) !important; background: rgba(255, 107, 107, 0.08) !important;';
                sel.title = `Blueprint type "${filterType}" no longer exists - edit blueprint to fix`;
            } else {
                emptyOpt.textContent = `Create new instance of category: "${filterType}"`;
            }

            sel.appendChild(emptyOpt);

            // Add blueprint options
            for (const cand of state.blueprints.filter(tt => tt.type === field.blueprintTypeFilter && tt.type !== 'Root')) {
                const o = document.createElement('option');
                o.value = cand.id;
                o.textContent = cand.name;
                sel.appendChild(o);
            }

            // Attach onchange handler
            sel.onchange = () => {
                if (!sel.value) return;
                pushUndo();
                const newInst = createInstance(sel.value, parentInst.id, field.id);
                if (newInst) editorCollapsed[newInst.id] = true;

                const registryParent = state.instances[parentInst.id];

                if (isList) {
                    if (!Array.isArray(registryParent.fieldValues[field.id])) {
                        registryParent.fieldValues[field.id] = [];
                    }
                    registryParent.fieldValues[field.id].push(newInst.id);
                } else {
                    registryParent.fieldValues[field.id] = newInst.id;
                }

                save();
                renderAll();
            };

            return sel;
        }

        function cloneBlueprint(blueprintId) {
            const original = findBlueprintById(blueprintId);
            if (!original) {
                alert('Blueprint not found');
                return;
            }

            // Create deep copy
            const clone = {
                id: generateUUID(),
                name: original.name + ' (Copy)',
                type: original.type,
                isStatic: original.isStatic,
                staticValues: JSON.parse(JSON.stringify(original.staticValues || {})),
                fields: original.fields.map(f => ({
                    ...f,
                    id: generateUUID() // New IDs for fields
                }))
            };

            pushUndo();
            state.blueprints.push(clone);
            invalidateBlueprintMap();
            save();
            renderAll();

            alert(`‚úÖ Cloned "${original.name}" as "${clone.name}"`);
        }

        // Helper: Parse comma-separated blueprint names into IDs
        function parseAllowedTypes(allowedTypesText) {
            if (!allowedTypesText || !allowedTypesText.trim()) {
                return [];
            }

            const names = allowedTypesText.split(',').map(s => s.trim()).filter(s => s);
            const ids = [];

            for (const name of names) {
                const bp = state.blueprints.find(b => b.name === name);
                if (bp) {
                    ids.push(bp.id);
                } else {
                    console.warn(`Blueprint "${name}" not found for allowed types`);
                }
            }

            return ids;
        }

        // Helper: Infer blueprint type from allowed types list
        function inferBlueprintType(allowedTypesText) {
            if (!allowedTypesText || !allowedTypesText.trim()) {
                return null;
            }

            const names = allowedTypesText.split(',').map(s => s.trim()).filter(s => s);
            if (names.length === 0) return null;

            // Get the type from the first blueprint in the list
            const firstBlueprint = state.blueprints.find(b => b.name === names[0]);
            return firstBlueprint ? firstBlueprint.type : null;
        }

        /**
         * Deep clone an object using JSON serialization.
         * WARNING: Not suitable for instance hydration (does not regenerate UUIDs).
         */
        function deepClone(obj) {
            return JSON.parse(JSON.stringify(obj));
        }

        /**
         * Check if a value is a valid UUID string.
         */
        function isValidUUID(value) {
            return (
                typeof value === 'string' &&
                /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)
            );
        }

        // ============================================================================
        // TYPE GUARDS
        // ============================================================================

        /**
         * Check if a field is a contain-mode field (creates ownership).
         */
        function isContainField(field) {
            return false;
            /*return (field.fieldKind === FIELD_KIND.INSTANTIATOR ||
                    field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) &&
                field.fieldMode === FIELD_MODE.REFERENCE);*/
        }

        /**
         * Check if a field is a reference-mode field (non-owning).
         */
        function isReferenceField(field) {
            /*return (
                ((field.fieldKind === FIELD_KIND.INSTANTIATOR ||    
                    field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) && 
                (field.fieldMode === FIELD_MODE.CONTAIN || field.fieldMode === FIELD_MODE.REFERENCE))
            );
            */
            return true;
        }

        /**
         * Check if a field is an instanceReference field (always non-owning).
         */
        function isInstanceReferenceField(field) {
            return field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE || field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE_LIST;
        }

        /**
         * DEPRECATED Check if a field is static (defined by blueprint, not instance). DEPRECATED.
         */
        function isFieldStatic(blueprint, field) {
            return blueprint.isStatic === true || field.isFieldStatic === true;
        }

        /**
         * Check if an object is a StaticInstanceShape (pre-hydration blueprint).
         * StaticInstanceShape has NO id, NO _parent, NO _parentField.
         */
        function isStaticInstanceShape(obj) {
            return false; //(
            //obj !== null &&
            //typeof obj === 'object' &&
            //typeof obj.templateId === 'string' &&
            //typeof obj.fieldValues === 'object' &&
            //obj._isStaticShape === true &&
            //obj.id === undefined
            //);
        }

        // HARDENING: Check if an object is a runtime instance (has ID)
        function isRuntimeInstance(obj) {
            return (
                obj !== null &&
                typeof obj === 'object' &&
                isValidUUID(obj.id) &&
                typeof obj.templateId === 'string' &&
                typeof obj.fieldValues === 'object'
            );
        }

        // ============================================================================
        // STATE MANAGEMENT
        // ============================================================================

        let state = {
            schemaVersion: SCHEMA_VERSION,
            blueprints: [],
            instances: {},
            rootInstanceId: null
        };

        // ============================================================================
        // PERFORMANCE CACHING
        // ============================================================================

        // Cache for blueprint lookups (invalidated when blueprints change)
        let blueprintMap = null;

        // Cache for reachability checks (invalidated when structure changes)
        let reachabilityCache = null;
        let reachabilityCacheDirty = true;

        // Debounce timer for saves
        let saveTimeout = null;

        // Last saved state (for skip-if-unchanged optimization)
        let lastSavedStateStr = null;

        let undoStack = [];
        let redoStack = [];
        let navHistory = [];
        let navHistoryIndex = -1;
        let selected = { kind: 'instance', id: null };
        let collapsed = {};
        let expandedTextFields = {};
        let textFieldHeights = {};  // Store custom heights per field
        let textFieldWidths = {};   // Store custom widths per field
        let editorCollapsed = {};
        let verboseMode = false;

        // HARDENING: Track validation state
        let lastValidationResult = null;
        let validationWarningsVisible = false;

        // EXPANDABLE CHIPS: Track which chips are expanded
        // Key format: "instanceId::fieldId::refId"
        let expandedChips = new Set();

        // ============================================================================
        // INTEGRITY HELPERS
        // ============================================================================

        // HARDENING: Check if instance exists in registry
        function isInstanceInRegistry(instanceId) {
            return state.instances.hasOwnProperty(instanceId);
        }

        /**
 * Check if an instance is orphaned (exists but not reachable from root).
 */
        function isInstanceOrphaned(instanceId) {
            if (!instanceId || instanceId === state.rootInstanceId) return false;
            if (!state.instances[instanceId]) return false; // Doesn't exist = deleted, not orphaned

            const reachable = collectReachableInstances();
            return !reachable.has(instanceId);
        }

        function renderMarkdown(text) {
            if (!text || text.trim() === '') return '';

            try {
                // Configure marked for safe rendering
                marked.setOptions({
                    breaks: true,        // Convert \n to <br>
                    gfm: true,          // GitHub Flavored Markdown
                    headerIds: false,   // Don't generate header IDs
                    mangle: false       // Don't escape email addresses
                });

                return marked.parse(text);
            } catch (error) {
                console.error('Markdown parse error:', error);
                return text; // Fallback to plain text
            }
        }

        function autoResizeTextarea(el) {
            el.style.height = 'auto';
            el.style.height = el.scrollHeight + 'px';
        }

        /**
         * Check if text contains Markdown formatting.
         * Returns true if text has markdown syntax.
         */
        function hasMarkdownSyntax(text) {
            if (!text) return false;

            // Multi-line content is always markdown-worthy
            if (text.includes('\n')) return true;

            // Check for common markdown patterns
            const markdownPatterns = [
                /\*\*.*?\*\*/,          // **bold**
                /__.*?__/,              // __bold__
                /\*.*?\*/,              // *italic*
                /_.*?_/,                // _italic_
                /\[.*?\]\(.*?\)/,       // [link](url)
                /`.*?`/,                // `code`
                /^#+\s/m,               // # headers
                /^[-*+]\s/m,            // - lists
                /^\d+\.\s/m             // 1. numbered lists
            ];

            return markdownPatterns.some(pattern => pattern.test(text));
        }


        // HARDENING: Collect all reachable instance IDs from containment graph
        function collectReachableInstances() {
            const reachable = new Set();
            const visited = new Set();

            function traverse(instId) {
                if (!instId || visited.has(instId)) return;
                visited.add(instId);

                const inst = state.instances[instId];
                if (!inst) return;

                reachable.add(instId);

                const blueprint = findBlueprintById(inst.templateId);
                if (!blueprint) return;

                for (const field of blueprint.fields) {
                    if (false) continue;

                    const val = inst.fieldValues[field.id];
                    if (!val) continue;

                    // FIXED: Contain mode now stores IDs (strings), not objects
                    if (field.fieldKind === FIELD_KIND.INSTANTIATOR) {
                        if (typeof val === 'string') {
                            traverse(val);
                        }
                    } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                        if (Array.isArray(val)) {
                            for (const childId of val) {
                                if (typeof childId === 'string') {
                                    traverse(childId);
                                }
                            }
                        }
                    }
                }
            }

            if (state.rootInstanceId) {
                traverse(state.rootInstanceId);
            }

            return reachable;
        }

        // HARDENING: Check for duplicate IDs in state (registry only)
        function findDuplicateIds() {
            const registryIds = Object.keys(state.instances);
            const uniqueIds = new Set(registryIds);

            // Check if any registry key points to an instance with a different ID
            const idMismatches = [];
            for (const registryKey in state.instances) {
                const inst = state.instances[registryKey];
                if (inst && inst.id && inst.id !== registryKey) {
                    idMismatches.push({
                        registryKey: registryKey,
                        instanceId: inst.id
                    });
                }
            }

            if (idMismatches.length > 0) {
                console.error('Registry key/instance ID mismatches:', idMismatches);
                return idMismatches.map(m => m.instanceId);
            }

            // JavaScript objects cannot have duplicate keys, so if we got here, no duplicates
            return [];
        }

        // HARDENING: Check if an instance has multiple owners
        function findMultiOwnership() {
            const ownershipMap = new Map(); // instanceId -> array of parent references

            function scanInstance(inst, parentId, parentFieldId) {
                if (!inst || !inst.id) return;

                if (!ownershipMap.has(inst.id)) {
                    ownershipMap.set(inst.id, []);
                }

                if (parentId && parentFieldId) {
                    ownershipMap.get(inst.id).push({ parentId, parentFieldId });
                }

                const blueprint = findBlueprintById(inst.templateId);
                if (!blueprint) return;
            }

            if (state.rootInstanceId) {
                const root = state.instances[state.rootInstanceId];
                if (root) scanInstance(root, null, null);
            }

            const violations = [];
            for (const [instId, owners] of ownershipMap.entries()) {
                if (owners.length > 1) {
                    violations.push({
                        instanceId: instId,
                        owners: owners
                    });
                }
            }

            return violations;
        }

        // HARDENING: Get all descendant IDs of an instance (for cycle prevention)
        function getDescendantIds(instanceId) {
            const descendants = new Set();
            const visited = new Set();

            function traverse(instId) {
                if (!instId || visited.has(instId)) return;
                visited.add(instId);

                const inst = state.instances[instId];
                if (!inst) return;

                descendants.add(instId);

                const blueprint = findBlueprintById(inst.templateId);
                if (!blueprint) return;
            }

            traverse(instanceId);
            descendants.delete(instanceId); // Don't include self

            return descendants;
        }

        // HARDENING: Check if blueprint has any instances depending on it
        function getBlueprintInstanceCount(templateId) {
            let count = 0;
            for (const instId in state.instances) {
                if (state.instances[instId].templateId === templateId) {
                    count++;
                }
            }
            return count;
        }

        // HARDENING: Check if field has owned children
        function getFieldOwnedChildrenCount(templateId, fieldId) {
            let count = 0;

            for (const instId in state.instances) {
                const inst = state.instances[instId];
                if (inst.templateId !== templateId) continue;

                const val = inst.fieldValues[fieldId];
                if (!val) continue;

                const blueprint = findBlueprintById(templateId);
                if (!blueprint) continue;

                const field = blueprint.fields.find(f => f.id === fieldId);
                if (!field) continue;

                if (field.fieldKind === FIELD_KIND.INSTANTIATOR && val.id) {
                    count++;
                } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST && Array.isArray(val)) {
                    count += val.filter(c => c?.id).length;
                }
            }

            return count;
        }

        // ============================================================================
        // UNDO/REDO (HARDENED)
        // ============================================================================

        // HARDENING: Push state snapshot with validation
        function pushUndo() {
            undoStack.push(deepClone(state));
            if (undoStack.length > MAX_UNDO) undoStack.shift();
            redoStack = [];
            updateUndoButtons();
        }

        function undo() {
            if (!undoStack.length) return;

            redoStack.push(deepClone(state));
            state = deepClone(undoStack.pop());

            // Invalidate all caches after state restore
            invalidateBlueprintMap();
            invalidateReachabilityCache();

            // HARDENING: Validate restored state
            const validation = validateState();
            if (!validation.valid) {
                console.warn('Undo restored invalid state:', validation.errors);
                showValidationWarning('Undo restored state with issues. Run Validate for details.');
            }

            save();
            renderAll();
            updateUndoButtons();
        }

        // HARDENING: Redo with post-restore validation
        function redo() {
            if (!redoStack.length) return;

            undoStack.push(deepClone(state));
            state = deepClone(redoStack.pop());

            // Invalidate all caches after state restore
            invalidateBlueprintMap();
            invalidateReachabilityCache();

            // HARDENING: Validate restored state
            const validation = validateState();
            if (!validation.valid) {
                console.warn('Redo restored invalid state:', validation.errors);
                showValidationWarning('Redo restored state with issues. Run Validate for details.');
            }

            save();
            renderAll();
            updateUndoButtons();
        }

        function updateUndoButtons() {
            document.getElementById('undoBtn').disabled = undoStack.length === 0;
            document.getElementById('redoBtn').disabled = redoStack.length === 0;
        }

        // ============================================================================
        // PERSISTENCE (HARDENED)
        // ============================================================================

        function save() {
            console.log('üíæ SAVE() called from:', new Error().stack.split('\n')[2]);

            const stateStr = JSON.stringify(state);

            // Skip if nothing changed
            if (stateStr === lastSavedStateStr) {
                console.log('üíæ SAVE skipped - no changes');
                return;
            }

            localStorage.setItem(STORAGE_KEY, stateStr);
            lastSavedStateStr = stateStr;
        }

        function debouncedSave(delay = 300) {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                save();
            }, delay);
        }

        function load() {
            const raw = localStorage.getItem(STORAGE_KEY);
            if (!raw) return false;
            try {
                state = JSON.parse(raw);
                migrateState(state);

                invalidateBlueprintMap();
                invalidateReachabilityCache();
                lastSavedStateStr = raw;

                // HARDENING: Ensure all field values match their field kinds + normalize to IDs
                for (const instId in state.instances) {
                    const inst = state.instances[instId];
                    const blueprint = state.blueprints.find(t => t.id === inst.templateId);
                    if (!blueprint) continue;

                    for (const field of blueprint.fields || []) {
                        if (!inst.fieldValues) inst.fieldValues = {};
                        const val = inst.fieldValues[field.id];

                        // FIXED: Normalize contain-mode fields to store IDs (migration from old format)
                        if (field.fieldKind === FIELD_KIND.INSTANTIATOR) {
                            if (val && typeof val === 'object' && val.id) {
                                // Old format: stored full object, convert to ID
                                inst.fieldValues[field.id] = val.id;
                            } else if (Array.isArray(val)) {
                                // Wrong type: array for single field
                                inst.fieldValues[field.id] = val.length > 0 && val[0]?.id ? val[0].id : null;
                            }
                        }

                        if (field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                            if (!Array.isArray(val)) {
                                // Wrong type: not an array
                                if (val && typeof val === 'object' && val.id) {
                                    inst.fieldValues[field.id] = [val.id];
                                } else {
                                    inst.fieldValues[field.id] = [];
                                }
                            } else {
                                // Normalize array items to IDs
                                inst.fieldValues[field.id] = val.map(item => {
                                    if (typeof item === 'string') return item; // Already ID
                                    if (item && typeof item === 'object' && item.id) return item.id; // Extract ID
                                    return null;
                                }).filter(id => id !== null);
                            }
                        }

                        // Ensure entity ref fields are arrays of IDs
                        if (field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE ||
                            field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE_LIST) {
                            if (!Array.isArray(val)) {
                                inst.fieldValues[field.id] = [];
                            }
                        }
                    }
                }

                save();

                // HARDENING: Validate loaded state
                const validation = validateState();
                if (!validation.valid) {
                    console.warn('Loaded state has validation errors:', validation.errors);
                    showValidationWarning('Loaded state has integrity issues. Run Validate for details.');
                }

                return true;
            } catch (e) {
                console.error('Load error:', e);
                return false;
            }
        }

        function exportJSON() {
            // HARDENING: Validate before export
            const validation = validateState();
            if (!validation.valid) {
                if (!confirm('State has validation errors. Export anyway?\n\nErrors:\n' +
                    validation.errors.slice(0, 5).join('\n') +
                    (validation.errors.length > 5 ? '\n... and more' : ''))) {
                    return;
                }
            }

            const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'DharmaForge_export.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // HARDENING: Import with automatic validation
        // HARDENING: Import with pre-migration validation and user confirmation
        function importJSONFile(file) {
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const parsed = JSON.parse(reader.result);

                    if (!Array.isArray(parsed.blueprints)) {
                        alert('Invalid JSON: missing blueprints array');
                        return;
                    }

                    // PRE-MIGRATION SCAN: Detect issues that will be auto-fixed
                    const migrationIssues = [];

                    // Check for null/empty blueprint types
                    for (const blueprint of parsed.blueprints || []) {
                        const hasValidType = blueprint.type &&
                            typeof blueprint.type === 'string' &&
                            blueprint.type.trim() !== '' &&
                            blueprint.type !== 'null';

                        if (!hasValidType) {
                            const typeDesc = blueprint.type === null ? 'null' :
                                blueprint.type === undefined ? 'undefined' :
                                    blueprint.type === 'null' ? 'string "null"' :
                                        'empty';
                            migrationIssues.push(`‚Ä¢ Blueprint "${blueprint.name || 'unnamed'}" has ${typeDesc} type ‚Üí will set to "Generic"`);
                        }
                    }

                    // If migration fixes are needed, warn user and ask for confirmation
                    if (migrationIssues.length > 0) {
                        const confirmMsg = [
                            '‚ö†Ô∏è IMPORT VALIDATION',
                            '',
                            'Found data quality issues that will be automatically fixed:',
                            '',
                            ...migrationIssues.slice(0, 10),
                            migrationIssues.length > 10 ? `... and ${migrationIssues.length - 10} more issues` : '',
                            '',
                            'Continue import with these automatic fixes?',
                            '',
                            '(You can undo after import if needed)'
                        ].filter(Boolean).join('\n');

                        if (!confirm(confirmMsg)) {
                            console.log('Import cancelled by user');
                            return;
                        }
                    }

                    // User confirmed (or no issues found), proceed with import
                    pushUndo();
                    state = parsed;
                    migrateState(state);

                    invalidateBlueprintMap();
                    invalidateReachabilityCache();

                    // HARDENING: Validate imported state
                    const validation = validateState();

                    if (!validation.valid) {
                        const errorReport = [
                            '‚ö†Ô∏è IMPORTED STATE HAS ERRORS:',
                            '',
                            'ERRORS:',
                            ...validation.errors.slice(0, 10),
                            validation.errors.length > 10 ? `... and ${validation.errors.length - 10} more errors` : '',
                            '',
                            validation.warnings.length > 0 ? 'WARNINGS:' : '',
                            ...validation.warnings.slice(0, 5),
                            validation.warnings.length > 5 ? `... and ${validation.warnings.length - 5} more warnings` : '',
                            '',
                            'The import completed, but the state is not valid.',
                            'You may need to fix issues manually or restore from backup.'
                        ].filter(Boolean).join('\n');

                        alert(errorReport);
                        lastValidationResult = validation;
                    } else if (validation.warnings.length > 0) {
                        alert(`Import successful with ${validation.warnings.length} warning(s).\n\nRun Validate to see details.`);
                        lastValidationResult = validation;
                    } else {
                        // Show success with summary of fixes if any were applied
                        if (migrationIssues.length > 0) {
                            alert(`‚úÖ Import successful!\n\nApplied ${migrationIssues.length} automatic fix(es).\nState is valid.`);
                        } else {
                            alert('‚úÖ Import successful - state is valid!');
                        }
                        lastValidationResult = null;
                    }

                    navigateTo('instance', state.rootInstanceId);
                    save();
                    renderAll();
                } catch (e) {
                    alert('Parse error: ' + e.message);
                }
            };
            reader.readAsText(file);
        }

        function reset() {
            if (confirm('Reset all data? This will delete everything and start fresh.')) {
                localStorage.removeItem(STORAGE_KEY);
                location.reload();
            }
        }

        // HARDENING: Show validation warning banner
        function showValidationWarning(message) {
            validationWarningsVisible = true;
            renderAll();
        }

        // ============================================================================
        // STATE MIGRATION (HARDENED)
        // ============================================================================

        function migrateState(st) {
            // HARDENING: Ensure all blueprints have a valid type
            // HARDENING: Ensure all blueprints have a valid type
            for (const blueprint of st.blueprints || []) {
                // Check if type is null, undefined, empty string, or the string "null"
                const hasValidType = blueprint.type &&
                    typeof blueprint.type === 'string' &&
                    blueprint.type.trim() !== '' &&
                    blueprint.type !== 'null';  // Catch string "null"

                if (!hasValidType) {
                    const typeDesc = blueprint.type === null ? 'null' :
                        blueprint.type === undefined ? 'undefined' :
                            blueprint.type === 'null' ? 'string "null"' : 'empty';
                    console.log(`Migration: Fixed ${typeDesc} type for blueprint "${blueprint.name || 'unnamed'}" ‚Üí "Generic"`);
                    blueprint.type = 'Generic';
                }
            }

            // HARDENING: Ensure all reachable instances are in registry
            ensureRegistryConsistency(st);

            // HARDENING: Ensure blueprint static properties exist
            for (const blueprint of st.blueprints || []) {
                if (blueprint.isStatic === undefined) blueprint.isStatic = false;
                if (!blueprint.staticValues) blueprint.staticValues = {};
            }
        }

        // HARDENING: Ensure all reachable instances are in registry (defensive)
        function ensureRegistryConsistency(st) {
            if (!st.instances) st.instances = {};
            const registryIds = new Set(Object.keys(st.instances));
            const missingFromRegistry = [];

            function scanTree(inst, visited = new Set()) {
                if (!inst || !inst.id) return;
                if (visited.has(inst.id)) return; // HARDENING: Prevent infinite loops
                visited.add(inst.id);

                // HARDENING: Only add if truly missing from registry
                if (!registryIds.has(inst.id)) {
                    missingFromRegistry.push(inst);
                    st.instances[inst.id] = inst;
                    registryIds.add(inst.id);
                }

                const blueprint = st.blueprints.find(t => t.id === inst.templateId);
                if (!blueprint) return;
            }

            if (st.rootInstanceId) {
                const root = st.instances[st.rootInstanceId];
                if (root) scanTree(root);
            }

            if (missingFromRegistry.length > 0) {
                console.warn(`Registry consistency: Added ${missingFromRegistry.length} missing instance(s) to registry`);
            }
        }

        /**
         * Flatten instance tree into registry.
         * HARDENING: Skip instances already in registry to prevent duplicates.
         */
        function flattenInstanceTree(inst, registry, visited = new Set()) {
            if (!inst || !inst.id) return;
            if (visited.has(inst.id)) return; // HARDENING: Cycle protection
            visited.add(inst.id);

            // HARDENING: Only add if not already in registry
            if (!registry[inst.id]) {
                registry[inst.id] = inst;
            }

            const blueprint = findBlueprintById(inst.templateId);
            if (!blueprint) return;

            for (const field of blueprint.fields || []) {
                const val = inst.fieldValues?.[field.id];
                if (!val) continue;

                /*if (field.fieldKind === FIELD_KIND.INSTANTIATOR && field.fieldMode === FIELD_MODE.CONTAIN) {
                    if (val && typeof val === 'object' && val.id) {
                        flattenInstanceTree(val, registry, visited);
                    }
                } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST && field.fieldMode === FIELD_MODE.CONTAIN) {
                    if (Array.isArray(val)) {
                        for (const child of val) {
                            if (child && typeof child === 'object' && child.id) {
                                flattenInstanceTree(child, registry, visited);
                            }
                        }
                    }
                }*/
            }
        }

        // ============================================================================
        // BLUEPRINT HELPERS
        // ============================================================================

        function findBlueprintById(id) {
            // Use cached map for O(1) lookup instead of O(n) linear search
            if (!blueprintMap) {
                rebuildBlueprintMap();
            }
            return blueprintMap.get(id);
        }

        //??? Unused?
        function addBlueprint(blueprint) {
            state.blueprints.push(blueprint);
            invalidateBlueprintMap();
            save();
            renderAll();
        }

        function rebuildBlueprintMap() {
            blueprintMap = new Map();
            for (const bp of state.blueprints) {
                blueprintMap.set(bp.id, bp);
            }
        }

        function invalidateBlueprintMap() {
            blueprintMap = null;
        }

        /**
         * Scan a blueprint for field configuration issues.
         * Returns counts of warnings (unselected types) and errors (orphaned types).
         */
        function scanBlueprintIssues(blueprint) {
            let warnings = 0;  // Unselected type filters
            let errors = 0;    // Orphaned type references

            // Get list of valid types
            const validTypes = new Set(
                state.blueprints
                    .map(t => t.type)
                    .filter(t => t && typeof t === 'string' && t.trim() !== '' && t !== 'Root')
            );

            for (const field of blueprint.fields || []) {
                // Only check fields that have type filters
                if (field.fieldKind === FIELD_KIND.INSTANTIATOR ||
                    field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST ||
                    field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE ||
                    field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE_LIST) {

                    const filterType = field.blueprintTypeFilter;

                    // Yellow warning: No type selected
                    if (!filterType || filterType === null || filterType === '') {
                        warnings++;
                    }
                    // Red error: Type selected but doesn't exist
                    else if (!validTypes.has(filterType)) {
                        errors++;
                    }
                }
            }

            return { warnings, errors };
        }

        function scanInstanceIssues(inst) {
            const errors = [];
            const warnings = [];

            const blueprint = findBlueprintById(inst.templateId);
            if (!blueprint) {
                errors.push('missing_blueprint');
                return { errors, warnings };
            }

            for (const field of blueprint.fields) {
                const val = inst.fieldValues[field.id];

                // Check reference fields (single)
                if (field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE && val) {
                    // Handle both correct (string) and corrupted (array) data
                    const ids = typeof val === 'string' ? [val] : (Array.isArray(val) ? val : []);
                    for (const id of ids) {
                        if (!findInstanceById(id)) {
                            errors.push(`broken_ref:${field.name}`);
                        } else if (isInstanceOrphaned(id)) {
                            warnings.push(`orphaned_ref:${field.name}`);
                        }
                    }
                }

                // Check instantiator fields (single)
                if (field.fieldKind === FIELD_KIND.INSTANTIATOR && val && typeof val === 'string') {
                    if (!findInstanceById(val)) {
                        errors.push(`broken_link:${field.name}`);
                    } else if (isInstanceOrphaned(val)) {
                        warnings.push(`orphaned_link:${field.name}`);
                    }
                }

                // Check type filters
                if ((field.fieldKind === FIELD_KIND.INSTANTIATOR ||
                    field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) &&
                    !field.blueprintTypeFilter) {
                    warnings.push(`no_filter:${field.name}`);
                }

                // Lists - check each element
                if (field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE_LIST && Array.isArray(val)) {
                    for (const id of val) {
                        if (!findInstanceById(id)) {
                            errors.push(`broken_ref:${field.name}`);
                        } else if (isInstanceOrphaned(id)) {
                            warnings.push(`orphaned_ref:${field.name}`);
                        }
                    }
                }

                // Check primitive type mismatches
                if (field.fieldKind === FIELD_KIND.PRIMITIVE && val !== undefined && val !== null && val !== '') {
                    if (field.primitiveType === PRIMITIVE_TYPE.NUMBER) {
                        if (typeof val !== 'number' || isNaN(val)) {
                            errors.push(`type_mismatch:${field.name} (expected number, got ${typeof val})`);
                        }
                    } else if (field.primitiveType === PRIMITIVE_TYPE.TEXT) {
                        if (typeof val !== 'string') {
                            errors.push(`type_mismatch:${field.name} (expected text, got ${typeof val})`);
                        }
                    }
                }

                // Check if value exists for reference/instantiator fields but field kind changed
                if (field.fieldKind === FIELD_KIND.PRIMITIVE &&
                    (typeof val === 'object' || (Array.isArray(val) && val.length > 0))) {
                    errors.push(`type_mismatch:${field.name} (has reference/list data but field is now primitive)`);
                }

                // Check type filter violations for reference/instantiator fields
                if ((field.fieldKind === FIELD_KIND.INSTANTIATOR ||
                    field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST ||
                    field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE ||
                    field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE_LIST) &&
                    field.blueprintTypeFilter && val) {

                    // Get referenced instance IDs
                    let refIds = [];
                    if (field.fieldKind === FIELD_KIND.INSTANTIATOR ||
                        field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE) {
                        if (typeof val === 'string') refIds = [val];
                        else if (Array.isArray(val)) refIds = val; // Handle legacy array format
                    } else {
                        refIds = Array.isArray(val) ? val : [];
                    }

                    // Check each referenced instance's blueprint type
                    for (const refId of refIds) {
                        const refInst = findInstanceById(refId);
                        if (refInst) {
                            const refBlueprint = findBlueprintById(refInst.templateId);
                            if (refBlueprint && refBlueprint.type !== field.blueprintTypeFilter) {
                                errors.push(`filter_mismatch:${field.name} (${refBlueprint.name} is type "${refBlueprint.type}", expected "${field.blueprintTypeFilter}")`);
                            }
                        }
                    }
                }
            }

            return {
                errorCount: errors.length,
                warningCount: warnings.length,
                details: { errors, warnings }
            };
        }

        function isRootBlueprintId(id) {
            const rt = state.blueprints[0];
            return rt && rt.id === id && rt.type === 'Root';
        }

        function createBlueprint(name = 'New', type = 'Generic') {
            pushUndo();
            const t = {
                id: generateUUID(),
                name,
                type: type || 'Generic', // HARDENING: Never allow null/empty type
                fields: [],
            };
            state.blueprints.push(t);
            invalidateBlueprintMap();
            save();
            renderAll();
            return t;
        }

        // ============================================================================
        // INSTANCE HELPERS
        // ============================================================================

        function findInstanceById(id) {
            return state.instances[id];
        }

        function getRootInstance() {
            return state.instances[state.rootInstanceId];
        }

        // HARDENING: Register instance with validation
        function registerInstance(inst) {
            if (!inst || !inst.id) {
                console.error('Cannot register instance without ID');
                return;
            }
            state.instances[inst.id] = inst;
            invalidateReachabilityCache();  // ADD THIS LINE
        }

        // ============================================================================
        // BLUEPRINT GENERATION
        // ============================================================================

        function quickGenerateBlueprint(instanceId) {
            const inst = findInstanceById(instanceId);
            const name = inst.fieldValues['blueprint_name_field_id'];
            const type = inst.fieldValues['blueprint_type_field_id'];
            const fieldNames = inst.fieldValues['field_names_field_id'].split(',');

            const newBlueprint = {
                id: generateUUID(),
                name: name.trim(),
                type: type.trim(),
                isStatic: false,
                staticValues: {},
                fields: fieldNames.map(fname => ({
                    id: generateUUID(),
                    name: fname.trim(),
                    fieldKind: FIELD_KIND.PRIMITIVE,
                    primitiveType: PRIMITIVE_TYPE.TEXT
                }))
            };

            pushUndo();
            state.blueprints.push(newBlueprint);
            invalidateBlueprintMap();
            save();
            renderAll();
            alert(`Blueprint "${name}" created!`);
        }

        // ============================================================================
        // INSTANCE CREATION
        // ============================================================================

        function createInstance(templateId, parentId = null, parentFieldId = null) {
            const blueprint = findBlueprintById(templateId);
            if (!blueprint) return null;

            const inst = {
                id: generateUUID(),
                templateId: blueprint.id,
                fieldValues: {},
                _parent: parentId,
                _parentField: parentFieldId
            };

            // Initialize field values
            for (const field of blueprint.fields) {
                // STATIC REIMPLEMENTATION: Skip primitives with defaults (leave undefined)
                if (blueprint.isStatic &&
                    field.fieldKind === FIELD_KIND.PRIMITIVE &&
                    blueprint.staticValues?.[field.id] !== undefined &&
                    blueprint.staticValues[field.id] !== null &&
                    blueprint.staticValues[field.id] !== '') {
                    // Don't initialize - leave undefined to use blueprint default
                    continue;
                }

                // Default initialization for all field kinds
                if (field.fieldKind === FIELD_KIND.PRIMITIVE) {
                    inst.fieldValues[field.id] = field.primitiveType === PRIMITIVE_TYPE.NUMBER ? 0 : '';
                } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR) {
                    inst.fieldValues[field.id] = null;
                } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                    inst.fieldValues[field.id] = [];
                } else if (field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE) {
                    inst.fieldValues[field.id] = [];
                } else if (field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE_LIST) {
                    inst.fieldValues[field.id] = [];
                }
            }

            registerInstance(inst);
            return inst;
        }

        /**
 * Check if an instance is orphaned (exists but not reachable from root).
 */
        function isInstanceOrphaned(instanceId) {
            if (!instanceId || instanceId === state.rootInstanceId) return false;
            if (!state.instances[instanceId]) return false;

            const reachable = getReachableInstances();  // Use cache!
            return !reachable.has(instanceId);
        }

        function getReachableInstances() {
            if (reachabilityCacheDirty || !reachabilityCache) {
                reachabilityCache = collectReachableInstances();
                reachabilityCacheDirty = false;
            }
            return reachabilityCache;
        }

        function invalidateReachabilityCache() {
            reachabilityCacheDirty = true;
        }

        // ============================================================================
        // INSTANCE DELETION (HARDENED)
        // ============================================================================

        /**
         * Delete an instance and all owned descendants.
         * Synchronously cleans all references (instanceReference, reference-mode).
         * 
         * INVARIANTS ENFORCED:
         * - Deletion cascades to owned children only
         * - Non-owning references do not block deletion
         * - All references to deleted instances are cleaned
         * - No dangling IDs remain after deletion
         * - Instances removed from registry
         */
        function deleteInstance(instanceId) {
            console.log('üóëÔ∏è deleteInstance called for:', instanceId?.slice(0, 8));

            const inst = findInstanceById(instanceId);
            if (!inst) return;

            // HARDENING: Check if instance is root
            if (instanceId === state.rootInstanceId) {
                alert('Cannot delete root instance');
                return;
            }

            // Step 1: Compute deletion set (owned descendants)
            const deletionSet = new Set();
            const visited = new Set();

            function collectOwnedDescendants(id) {
                if (visited.has(id)) return; // Cycle protection
                visited.add(id);
                deletionSet.add(id);

                const current = findInstanceById(id);
                if (!current) return;

                const blueprint = findBlueprintById(current.templateId);
                if (!blueprint) return;

                // CRITICAL: Recursively collect owned children
                for (const field of blueprint.fields || []) {
                    if (field.fieldKind === FIELD_KIND.INSTANTIATOR ||
                        field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {

                        const val = current.fieldValues[field.id];

                        if (field.fieldKind === FIELD_KIND.INSTANTIATOR && val) {
                            const child = findInstanceById(val);
                            if (child && child._parent === id) {
                                // Only cascade if we own it
                                collectOwnedDescendants(val);
                            }
                        } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST && Array.isArray(val)) {
                            for (const childId of val) {
                                const child = findInstanceById(childId);
                                if (child && child._parent === id) {
                                    // Only cascade if we own it
                                    collectOwnedDescendants(childId);
                                }
                            }
                        }
                    }
                }
            }

            collectOwnedDescendants(instanceId);

            // HARDENING: Step 2: Detach from parent containment field
            if (inst._parent) {
                const parent = findInstanceById(inst._parent);
                if (parent && inst._parentField) {
                    const parentBlueprint = findBlueprintById(parent.templateId);
                    if (parentBlueprint) {
                        const parentField = parentBlueprint.fields.find(f => f.id === inst._parentField);
                        if (parentField && isContainField(parentField)) {
                            if (parentField.fieldKind === FIELD_KIND.INSTANTIATOR) {
                                parent.fieldValues[parentField.id] = null;
                            } else if (parentField.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                                const arr = parent.fieldValues[parentField.id];
                                if (Array.isArray(arr)) {
                                    // FIXED: Array contains IDs (strings), not objects
                                    parent.fieldValues[parentField.id] = arr.filter(id => !deletionSet.has(id));
                                }
                            }
                        }
                    }
                }
            }

            // Step 3: Delete all instances in deletion set from registry
            for (const id of deletionSet) {
                delete state.instances[id];
            }

            // Step 4: Clean all references (synchronous)
            try {
                cleanupReferences(deletionSet);
            } catch (err) {
                console.error('üö® cleanupReferences failed:', err);
            }

            invalidateReachabilityCache();  // ADD THIS LINE
            save();
            renderAll();
        }

        function cleanupReferences(deletedIds) {
            /*console.log('üßπ cleanupReferences called with', deletedIds.size, 'deleted IDs:', Array.from(deletedIds));

            for (const instId in state.instances) {
                const inst = state.instances[instId];
                const blueprint = findBlueprintById(inst.templateId);
                if (!blueprint) continue;

                for (const field of blueprint.fields) {
                    if (isFieldStatic(blueprint, field)) continue;

                    const val = inst.fieldValues[field.id];

                    // INSTANCE_REFERENCE and INSTANCE_REFERENCE_LIST: Do NOT clean broken references
                    // Broken references are valid states - users see ‚ö†Ô∏è broken chips

                    // Clean reference-mode instantiator
                    if (field.fieldKind === FIELD_KIND.INSTANTIATOR) {
                        if (val && deletedIds.has(val)) {
                            inst.fieldValues[field.id] = null;
                            console.log(`  ‚úÇÔ∏è Cleaned instantiator field "${field.name}" in instance ${instId.slice(0, 8)}`);
                        }
                    }

                    // Clean reference-mode instantiatorList
                    if (field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                        if (Array.isArray(val)) {
                            const before = val.length;
                            inst.fieldValues[field.id] = val.filter(id => !deletedIds.has(id));
                            const after = inst.fieldValues[field.id].length;
                            if (before !== after) {
                                console.log(`  ‚úÇÔ∏è Cleaned instantiatorList field "${field.name}" in instance ${instId.slice(0, 8)}: ${before} ‚Üí ${after} refs`);
                            }
                        }
                    }
                }
            }

            console.log('üßπ cleanupReferences complete');
            */

            console.log('üßπ cleanupReferences called with', deletedIds.size, 'deleted IDs:', Array.from(deletedIds));

            // NO LONGER CLEANING ANY REFERENCES
            // All broken references (instantiator, instantiatorList, instanceReference, instanceReferenceList)
            // are preserved and shown as broken/red to the user
            // User must explicitly clear broken references if desired

            console.log('üßπ cleanupReferences complete (no cleaning - broken refs preserved)');
        }

        // ============================================================================
        // INSTANCE MOVE (REPARENTING) - HARDENED
        // ============================================================================

        /**
         * Move an instance to a new parent (reparenting).
         * This is an explicit, atomic operation.
         * 
         * INVARIANTS ENFORCED:
         * - Instance must exist
         * - New parent must exist
         * - New field must be contain-mode
         * - Cannot create multi-ownership
         * - Cannot create cycles
         * - Operation is atomic (all or nothing)
         * 
         * @param instanceId - Instance to move
         * @param newParentId - New parent instance ID
         * @param newFieldId - Field ID in new parent
         * @returns Success/failure with error message
         */
        function moveInstance(instanceId, newParentId, newFieldId) {
            const inst = findInstanceById(instanceId);
            if (!inst) return { success: false, error: 'Instance not found' };

            const newParent = findInstanceById(newParentId);
            if (!newParent) return { success: false, error: 'New parent not found' };

            const newParentBlueprint = findBlueprintById(newParent.templateId);
            if (!newParentBlueprint) return { success: false, error: 'New parent blueprint not found' };

            const newField = newParentBlueprint.fields.find(f => f.id === newFieldId);
            if (!newField) return { success: false, error: 'New field not found' };

            /*if (!isContainField(newField)) {
                return { success: false, error: 'New field must be contain-mode' };
            }*/

            // HARDENING: Prevent moving root
            if (instanceId === state.rootInstanceId) {
                return { success: false, error: 'Cannot move root instance' };
            }

            // HARDENING: Prevent cycle creation (cannot move into own descendants)
            const descendants = getDescendantIds(instanceId);
            if (descendants.has(newParentId)) {
                return { success: false, error: 'Cannot move instance into its own descendant (would create cycle)' };
            }

            // HARDENING: Prevent moving to same parent/field (no-op)
            if (inst._parent === newParentId && inst._parentField === newFieldId) {
                return { success: false, error: 'Instance already in this location' };
            }

            // Check type compatibility
            if (newField.blueprintTypeFilter) {
                const instBlueprint = findBlueprintById(inst.templateId);
                if (instBlueprint && instBlueprint.type !== newField.blueprintTypeFilter) {
                    return { success: false, error: `Type mismatch: expected ${newField.blueprintTypeFilter}, got ${instBlueprint.type}` };
                }
            }

            // Step 1: Remove from old parent
            if (inst._parent) {
                const oldParent = findInstanceById(inst._parent);
                if (oldParent && inst._parentField) {
                    const oldParentBlueprint = findBlueprintById(oldParent.templateId);
                    if (oldParentBlueprint) {
                        const oldField = oldParentBlueprint.fields.find(f => f.id === inst._parentField);
                        if (oldField) {
                            if (oldField.fieldKind === FIELD_KIND.INSTANTIATOR) {
                                oldParent.fieldValues[oldField.id] = null;
                            } else if (oldField.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                                const arr = oldParent.fieldValues[oldField.id];
                                if (Array.isArray(arr)) {
                                    const idx = arr.indexOf(instanceId);
                                    if (idx >= 0) arr.splice(idx, 1);
                                }
                            }
                        }
                    }
                }
            }

            // Step 2: Add to new parent
            if (newField.fieldKind === FIELD_KIND.INSTANTIATOR) {
                if (newParent.fieldValues[newFieldId]) {
                    return { success: false, error: 'Target instantiator field already occupied' };
                }
                newParent.fieldValues[newFieldId] = inst.id;
            } else if (newField.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                if (!Array.isArray(newParent.fieldValues[newFieldId])) {
                    newParent.fieldValues[newFieldId] = [];
                }
                newParent.fieldValues[newFieldId].push(inst.id);
            }

            // Step 3: Update instance ownership
            inst._parent = newParentId;
            inst._parentField = newFieldId;

            return { success: true };
        }

        // ============================================================================
        // INSTANCE COPY (DEEP CLONE) - HARDENED
        // ============================================================================

        /**
         * Deep copy an instance with fresh UUIDs.
         * Recursively clones all owned descendants.
         * instanceReferences are copied as IDs (pointing to same targets).
         * 
         * INVARIANTS ENFORCED:
         * - All clones receive fresh UUIDs
         * - Ownership structure is preserved
         * - instanceReferences remain IDs (not cloned)
         * - No shared ownership created
         * - All clones registered in state.instances
         * 
         * @param instanceId - Instance to copy
         * @param targetParentId - Target parent instance ID
         * @param targetFieldId - Target field ID in parent
         * @returns New instance or null
         */
        function copyInstance(instanceId, targetParentId, targetFieldId) {
            const inst = findInstanceById(instanceId);
            if (!inst) return null;

            const targetParent = findInstanceById(targetParentId);
            if (!targetParent) return null;

            const targetParentBlueprint = findBlueprintById(targetParent.templateId);
            if (!targetParentBlueprint) return null;

            const targetField = targetParentBlueprint.fields.find(f => f.id === targetFieldId);
            if (!targetField) return null;

            // HARDENING: Prevent copying root
            if (instanceId === state.rootInstanceId) {
                alert('Cannot copy root instance');
                return null;
            }

            // Deep clone with fresh UUIDs
            const cloned = deepCloneInstance(inst, targetParentId, targetFieldId);
            if (!cloned) return null;

            // Add to target parent
            if (targetField.fieldKind === FIELD_KIND.INSTANTIATOR) {
                targetParent.fieldValues[targetFieldId] = cloned;
            } else if (targetField.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                if (!Array.isArray(targetParent.fieldValues[targetFieldId])) {
                    targetParent.fieldValues[targetFieldId] = [];
                }
                targetParent.fieldValues[targetFieldId].push(cloned);
            }

            return cloned;
        }

        /**
         * Recursively deep clone an instance with fresh UUIDs.
         * HARDENING: Ensures all clones are registered.
         */
        function deepCloneInstance(inst, newParentId, newParentFieldId) {
            const blueprint = findBlueprintById(inst.templateId);
            if (!blueprint) return null;

            const cloned = {
                id: generateUUID(), // HARDENING: Always fresh UUID
                templateId: inst.templateId,
                fieldValues: {},
                _parent: newParentId,
                _parentField: newParentFieldId
            };

            // Clone field values
            for (const field of blueprint.fields) {
                if (isFieldStatic(blueprint, field)) continue;

                const val = inst.fieldValues[field.id];

                if (field.fieldKind === FIELD_KIND.PRIMITIVE) {
                    cloned.fieldValues[field.id] = val;
                } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR) {
                    // Reference mode: copy ID verbatim
                    cloned.fieldValues[field.id] = val;
                } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                    // Reference mode: copy IDs verbatim
                    cloned.fieldValues[field.id] = Array.isArray(val) ? [...val] : [];
                } else if (field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE) {
                    // instanceReference: copy IDs verbatim
                    cloned.fieldValues[field.id] = Array.isArray(val) ? [...val] : [];
                }
            }

            registerInstance(cloned); // HARDENING: Register immediately
            return cloned;
        }

        // ============================================================================
        // VALIDATION (COMPREHENSIVE)
        // ============================================================================

        /**
         * Validate entire state for invariant violations.
         * Returns { valid: boolean, errors: string[], warnings: string[] }
         * 
         * HARDENING: Comprehensive integrity checks
         */
        function validateState() {
            const errors = [];
            const warnings = [];

            // Check root exists
            if (!state.rootInstanceId) {
                errors.push('No root instance defined');
            } else if (!state.instances[state.rootInstanceId]) {
                errors.push('Root instance does not exist in registry');
            }

            // HARDENING: Check for duplicate IDs
            const duplicates = findDuplicateIds();
            if (duplicates.length > 0) {
                errors.push(`Duplicate instance IDs found: ${duplicates.join(', ')}`);
            }

            // HARDENING: Check for multi-ownership
            const multiOwnership = findMultiOwnership();
            if (multiOwnership.length > 0) {
                for (const violation of multiOwnership) {
                    errors.push(
                        `Instance ${violation.instanceId} has multiple owners: ${violation.owners.length} parents`
                    );
                }
            }

            // HARDENING: Check for orphaned instances in registry
            const reachable = collectReachableInstances();
            const registryIds = Object.keys(state.instances);
            const orphaned = registryIds.filter(
                id => id !== state.rootInstanceId && !reachable.has(id)
            );
            if (orphaned.length > 0) {
                warnings.push(
                    `${orphaned.length} orphaned instance(s) in registry (unreachable from root)`
                );
            }

            // Check all instances
            for (const instId in state.instances) {
                const inst = state.instances[instId];

                // Check valid UUID
                if (!isValidUUID(inst.id)) {
                    errors.push(`Instance ${instId} has invalid UUID`);
                }

                // Check blueprint exists
                const blueprint = findBlueprintById(inst.templateId);
                if (!blueprint) {
                    errors.push(
                        `Instance ${instId} references missing blueprint: ${inst.templateId}`
                    );
                    continue;
                }

                // Check ownership
                if (inst._parent !== null) {
                    if (!isValidUUID(inst._parent)) {
                        errors.push(
                            `Instance ${instId} has invalid parent ID: ${inst._parent}`
                        );
                    }
                    const parent = findInstanceById(inst._parent);
                    if (!parent) {
                        errors.push(
                            `Instance ${instId} references missing parent: ${inst._parent}`
                        );
                    }
                } else if (inst.id !== state.rootInstanceId) {
                    errors.push(
                        `Instance ${instId} has no parent but is not root`
                    );
                }

                // Check field values
                for (const field of blueprint.fields) {
                    if (isFieldStatic(blueprint, field)) continue;

                    const val = inst.fieldValues[field.id];

                    // Check instanceReference and instanceReferenceList
                    if (isInstanceReferenceField(field)) {
                        if (!Array.isArray(val)) {
                            errors.push(
                                `Instance ${instId}, field ${field.name}: ${field.fieldKind} must be array`
                            );
                        } else {
                            for (const refId of val) {
                                if (!isValidUUID(refId)) {
                                    errors.push(
                                        `Instance ${instId}, field ${field.name}: invalid UUID in ${field.fieldKind}: ${refId}`
                                    );
                                }
                                if (!findInstanceById(refId)) {
                                    warnings.push(
                                        `Instance ${instId}, field ${field.name}: broken ${field.fieldKind} to ${refId}`
                                    );
                                }
                            }

                            // SEMANTIC WARNING: instanceReference ambiguity
                            if (
                                field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE &&
                                val.length > 1
                            ) {
                                warnings.push(
                                    `Instance ${instId}, field ${field.name}: instanceReference has ${val.length} candidates (ambiguous reference)`
                                );
                            }
                        }
                    }

                    // Check reference-mode fields
                    if (field.fieldKind === FIELD_KIND.INSTANTIATOR) {
                        if (val !== null && !isValidUUID(val)) {
                            errors.push(
                                `Instance ${instId}, field ${field.name}: reference instantiator must be UUID or null`
                            );
                        }
                        if (val && !findInstanceById(val)) {
                            warnings.push(
                                `Instance ${instId}, field ${field.name}: broken reference to ${val}`
                            );
                        }
                    } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                        if (!Array.isArray(val)) {
                            errors.push(
                                `Instance ${instId}, field ${field.name}: reference instantiatorList must be array`
                            );
                        } else {
                            for (const refId of val) {
                                if (!isValidUUID(refId)) {
                                    errors.push(
                                        `Instance ${instId}, field ${field.name}: invalid UUID in instantiatorList: ${refId}`
                                    );
                                }
                                if (!findInstanceById(refId)) {
                                    warnings.push(
                                        `Instance ${instId}, field ${field.name}: broken reference to ${refId}`
                                    );
                                }
                            }
                        }
                    }

                    // FIXED: Check contain-mode fields (now store IDs like reference mode)
                    if (false) {
                        if (field.fieldKind === FIELD_KIND.INSTANTIATOR) {
                            if (val !== null && !isValidUUID(val)) {
                                errors.push(
                                    `Instance ${instId}, field ${field.name}: contain instantiator must be valid UUID or null`
                                );
                            }
                            if (val && !findInstanceById(val)) {
                                warnings.push(
                                    `Instance ${instId}, field ${field.name}: contain instantiator references missing instance ${val}`
                                );
                            }
                        } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                            if (!Array.isArray(val)) {
                                errors.push(
                                    `Instance ${instId}, field ${field.name}: contain instantiatorList must be array`
                                );
                            } else {
                                for (let i = 0; i < val.length; i++) {
                                    if (!isValidUUID(val[i])) {
                                        errors.push(
                                            `Instance ${instId}, field ${field.name}[${i}]: must be valid UUID`
                                        );
                                    }
                                    if (!findInstanceById(val[i])) {
                                        warnings.push(
                                            `Instance ${instId}, field ${field.name}[${i}]: references missing instance ${val[i]}`
                                        );
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // HARDENING: Check for ownership cycles (treat as corruption)
            const cycleResult = detectOwnershipCycles();
            errors.push(...cycleResult.errors);

            return {
                valid: errors.length === 0,
                errors,
                warnings
            };
        }


        /**
         * Detect ownership cycles in contain-mode graph.
         * HARDENING: Cycles are errors, not warnings.
         */
        function detectOwnershipCycles() {
            const errors = [];
            const visited = new Set();
            const recursionStack = new Set();

            function dfs(instId, path) {
                if (recursionStack.has(instId)) {
                    errors.push(`OWNERSHIP CYCLE: ${path.join(' -> ')} -> ${instId}`);
                    return;
                }
                if (visited.has(instId)) return;

                visited.add(instId);
                recursionStack.add(instId);
                path.push(instId);

                const inst = findInstanceById(instId);
                if (!inst) {
                    path.pop();
                    recursionStack.delete(instId);
                    return;
                }

                path.pop();
                recursionStack.delete(instId);
            }

            if (state.rootInstanceId) {
                dfs(state.rootInstanceId, []);
            }

            return { errors };
        }

        // ============================================================================
        // FIELD MANAGEMENT (HARDENED)
        // ============================================================================

        function addField(blueprintId, field) {
            pushUndo();
            const blueprint = findBlueprintById(blueprintId);
            if (!blueprint) return;

            blueprint.fields.push(field);

            // Initialize field in blueprint static values (primitives only)
            if (blueprint.isStatic && field.fieldKind === FIELD_KIND.PRIMITIVE) {
                blueprint.staticValues[field.id] = field.primitiveType === PRIMITIVE_TYPE.NUMBER ? 0 : '';
            } else {
                // Initialize in all existing instances
                for (const instId in state.instances) {
                    const inst = state.instances[instId];
                    if (inst.templateId !== blueprintId) continue;

                    if (field.fieldKind === FIELD_KIND.PRIMITIVE) {
                        inst.fieldValues[field.id] = field.primitiveType === PRIMITIVE_TYPE.NUMBER ? 0 : '';
                    } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR) {
                        inst.fieldValues[field.id] = null;
                    } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                        inst.fieldValues[field.id] = [];
                    } else if (field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE) {
                        inst.fieldValues[field.id] = [];
                    } else if (field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE_LIST) {
                        inst.fieldValues[field.id] = [];
                    }
                }
            }
            invalidateReachabilityCache();
            save();
            renderAll();
        }

        function removeField(templateId, fieldId) {
            pushUndo();
            const blueprint = findBlueprintById(templateId);
            if (!blueprint) return;

            // Remove field from blueprint
            blueprint.fields = blueprint.fields.filter(f => f.id !== fieldId);

            // Remove from blueprint static values if exists
            if (blueprint.staticValues && blueprint.staticValues[fieldId] !== undefined) {
                delete blueprint.staticValues[fieldId];
            }

            // Remove field data from all instances of this blueprint
            for (const instId in state.instances) {
                const inst = state.instances[instId];
                if (inst.templateId === templateId && inst.fieldValues[fieldId] !== undefined) {
                    delete inst.fieldValues[fieldId];
                }
            }

            save();
            renderAll();
        }

        // ============================================================================
        // FIELD MANAGEMENT - END
        // ============================================================================

        // ============================================================================
        // NAVIGATION
        // ============================================================================

        function navigateTo(kind, id, addToHistory = true) {
            // Force blur
            if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                document.activeElement.blur();
            }
            if (addToHistory) {
                navHistory = navHistory.slice(0, navHistoryIndex + 1);
                navHistory.push({ kind, id });
                navHistoryIndex = navHistory.length - 1;
            }
            selected = { kind, id };
            renderAll();
            updateNavButtons();
        }

        function navigateBack() {
            if (navHistoryIndex > 0) {
                navHistoryIndex--;
                const loc = navHistory[navHistoryIndex];
                selected = { kind: loc.kind, id: loc.id };
                renderAll();
                updateNavButtons();
            }
        }

        function navigateForward() {
            if (navHistoryIndex < navHistory.length - 1) {
                navHistoryIndex++;
                const loc = navHistory[navHistoryIndex];
                selected = { kind: loc.kind, id: loc.id };
                renderAll();
                updateNavButtons();
            }
        }

        function updateNavButtons() {
            document.getElementById('backBtn').disabled = navHistoryIndex <= 0;
            document.getElementById('forwardBtn').disabled =
                navHistory.length === 0 || navHistoryIndex >= navHistory.length - 1;
        }

        // ============================================================================
        // INSTANCE_REFERENCE NAVIGATION
        // ============================================================================

        /**
         * Navigate to a referenced instance from an instanceReference chip.
         * 
         * BEHAVIOR:
         * - If target exists: Navigate to it, expand in hierarchy, load in editor
         * - If target missing: No navigation, no error thrown (visual warning only)
         * 
         * @param targetInstanceId - Instance ID to navigate to
         * @returns Boolean indicating whether navigation succeeded
         */
        function handleEntityRefNavigate(targetInstanceId) {
            if (!targetInstanceId) {
                console.warn('handleEntityRefNavigate: No target ID provided');
                return false;
            }

            // Check if target exists in registry
            const targetInstance = findInstanceById(targetInstanceId);

            if (!targetInstance) {
                console.warn(`handleEntityRefNavigate: Target instance not found: ${targetInstanceId}`);
                // UI will show broken reference warning, no action needed here
                return false;
            }

            // Target exists - navigate to it
            console.log(`Navigating to instanceReference target: ${targetInstanceId.slice(0, 8)}`);

            // Expand parent chain in hierarchy (if collapsed)
            expandParentChain(targetInstanceId);

            // Navigate to the instance
            navigateTo('instance', targetInstanceId);

            return true;
        }

        /**
         * Expand all parent nodes in the hierarchy tree to make an instance visible.
         * This ensures the target instance is not hidden by collapsed ancestors.
         * 
         * @param instanceId - Instance ID to make visible
         */
        function expandParentChain(instanceId) {
            const chain = [];
            let currentId = instanceId;

            // Walk up the parent chain
            while (currentId) {
                const inst = findInstanceById(currentId);
                if (!inst) break;

                chain.push(currentId);
                currentId = inst._parent;
            }

            // Expand all ancestors (except the target itself)
            for (let i = chain.length - 1; i > 0; i--) {
                const ancestorId = chain[i];
                if (collapsed[ancestorId]) {
                    collapsed[ancestorId] = false;
                }
            }
        }

        // ============================================================================
        // EXPANDABLE CHIP MANAGEMENT
        // ============================================================================

        /**
         * Generate a unique key for tracking expanded chip state.
         */
        function getChipKey(instanceId, fieldId, refId) {
            return `${instanceId}::${fieldId}::${refId}`;
        }

        /**
         * Check if a chip is currently expanded.
         */
        function isChipExpanded(instanceId, fieldId, refId) {
            return expandedChips.has(getChipKey(instanceId, fieldId, refId));
        }

        /**
         * Toggle the expansion state of a chip.
         */
        function toggleChipExpansion(instanceId, fieldId, refId) {
            const key = getChipKey(instanceId, fieldId, refId);
            if (expandedChips.has(key)) {
                expandedChips.delete(key);
            } else {
                expandedChips.add(key);
            }
            renderAll();
        }

        /**
         * Render the expanded view of a referenced instance.
         * Shows all field values in a verbose, inline format.
         */
        function renderChipExpandedView(targetInstance, targetBlueprint, refId) {
            const expandedView = document.createElement('div');
            expandedView.className = 'chip-expanded-view';

            // Header with title and navigate button
            const header = document.createElement('div');
            header.className = 'chip-expanded-header';

            const title = document.createElement('div');
            title.className = 'chip-expanded-title';
            const label = getInstanceLabel(refId);
            title.textContent = `${label} ¬∑ ${targetBlueprint.name}`;
            header.appendChild(title);

            expandedView.appendChild(header);

            // Render all fields
            for (const field of targetBlueprint.fields || []) {
                const fieldLine = document.createElement('div');
                fieldLine.className = 'chip-field-line';

                const fieldKey = document.createElement('span');
                fieldKey.className = 'chip-field-key';
                fieldKey.textContent = field.name + ':';

                const fieldValue = document.createElement('span');
                fieldValue.className = 'chip-field-value';

                // Render field value based on kind
                if (field.fieldKind === FIELD_KIND.PRIMITIVE) {
                    const val = targetInstance.fieldValues?.[field.id];
                    if (val === null || val === undefined || val === '') {
                        fieldValue.textContent = '[empty]';
                        fieldValue.style.fontStyle = 'italic';
                        fieldValue.style.color = 'var(--muted)';
                    } else {
                        fieldValue.textContent = String(val);
                    }
                } else if (field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE) {
                    const refs = targetInstance.fieldValues?.[field.id] || [];
                    if (refs.length === 0) {
                        fieldValue.textContent = '[empty]';
                        fieldValue.style.fontStyle = 'italic';
                        fieldValue.style.color = 'var(--muted)';
                    } else {
                        // Show labels of referenced instances
                        const labels = refs.slice(0, 3).map(id => getInstanceLabel(id));
                        const displayText = labels.join(', ');
                        fieldValue.textContent = refs.length > 3 ?
                            `${displayText}... (+${refs.length - 3} more)` :
                            displayText;
                        fieldValue.classList.add('clickable');
                        fieldValue.title = 'Click to expand';
                        // Could make this recursive in the future
                    }
                } else if (field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE_LIST) {
                    const refs = targetInstance.fieldValues?.[field.id] || [];
                    if (refs.length === 0) {
                        fieldValue.textContent = '[empty]';
                        fieldValue.style.fontStyle = 'italic';
                        fieldValue.style.color = 'var(--muted)';
                    } else {
                        const labels = refs.slice(0, 3).map((id, idx) => `${idx + 1}. ${getInstanceLabel(id)}`);
                        const displayText = labels.join(', ');
                        fieldValue.textContent = refs.length > 3 ?
                            `${displayText}... (+${refs.length - 3} more)` :
                            displayText;
                    }
                } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR || field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                    const merged = getMergedChildrenWithProvenance(targetBlueprint, targetInstance, field.id);
                    if (merged.length === 0) {
                        fieldValue.textContent = '[empty]';
                        fieldValue.style.fontStyle = 'italic';
                        fieldValue.style.color = 'var(--muted)';
                    } else {
                        const childLabels = merged.slice(0, 3).map(x => getInstanceLabel(x.child.id));
                        const displayText = childLabels.join(', ');
                        fieldValue.textContent = merged.length > 3 ?
                            `${displayText}... (+${merged.length - 3} more)` :
                            displayText;
                    }
                }

                fieldLine.appendChild(fieldKey);
                fieldLine.appendChild(fieldValue);
                expandedView.appendChild(fieldLine);
            }

            return expandedView;
        }

        // ============================================================================
        // INSTANCE PICKER MODAL (HARDENED)
        // ============================================================================

        /**
         * Show modal to pick an instance for instanceReference or reference-mode field.
         * HARDENING: Exclude self and descendants to prevent cycles.
         */
        function showInstancePicker(filterType, onSelect, excludeInstanceId = null, showOnlyOrphans = false) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';

            const modal = document.createElement('div');
            modal.className = 'modal';

            const title = document.createElement('div');
            title.className = 'modal-title';
            title.textContent = showOnlyOrphans ?
                'Move Orphaned Instance Here' :
                'Select Instance to Reference';
            modal.appendChild(title);

            const listContainer = document.createElement('div');
            listContainer.className = 'modal-list';

            // HARDENING: Collect exclusion set (self + descendants)
            const exclusionSet = new Set();
            if (excludeInstanceId) {
                exclusionSet.add(excludeInstanceId);
                const descendants = getDescendantIds(excludeInstanceId);
                for (const descId of descendants) {
                    exclusionSet.add(descId);
                }
            }

            // PHASE 1: Optionally filter for orphans only
            const reachable = showOnlyOrphans ? collectReachableInstances() : null;

            // Find matching instances
            const candidates = [];
            for (const instId in state.instances) {
                // HARDENING: Skip excluded instances
                if (exclusionSet.has(instId)) continue;

                const inst = state.instances[instId];
                const blueprint = findBlueprintById(inst.templateId);

                // Filter by allowed blueprint IDs (if array) or blueprint type (if string)
                let matches = false;
                if (Array.isArray(filterType) && filterType.length > 0) {
                    // filterType is array of allowed blueprint IDs
                    matches = filterType.includes(inst.templateId);
                } else if (typeof filterType === 'string') {
                    // filterType is blueprint type string (legacy)
                    matches = blueprint && blueprint.type === filterType;
                } else {
                    // No filter - show all
                    matches = true;
                }

                if (matches) {
                    // PHASE 1: Filter for orphans if requested
                    if (showOnlyOrphans) {
                        if (!reachable.has(instId) && instId !== state.rootInstanceId) {
                            candidates.push(inst);
                        }
                    } else {
                        candidates.push(inst);
                    }
                }
            }

            if (candidates.length === 0) {
                const empty = document.createElement('div');
                empty.className = 'muted';
                empty.textContent = showOnlyOrphans ?
                    `No orphaned instances of type "${filterType}" found.` :
                    `No instances of type "${filterType}" available (excluding self and descendants).`;
                listContainer.appendChild(empty);
            } else {
                for (const inst of candidates) {
                    const item = document.createElement('div');
                    item.className = 'modal-item';
                    const blueprint = findBlueprintById(inst.templateId);

                    // Instance labeling: blueprint name
                    const displayLabel = blueprint?.name || 'Unknown';

                    item.innerHTML = `
    <div class="card-name">${displayLabel}</div>
    <div class="muted" style="font-size:11px">${inst.id.slice(0, 8)}</div>
  `;
                    item.onclick = () => {
                        onSelect(inst.id);
                        document.body.removeChild(overlay);
                    };
                    listContainer.appendChild(item);
                }
            }

            modal.appendChild(listContainer);

            const footer = document.createElement('div');
            footer.className = 'modal-footer';
            const cancelBtn = document.createElement('button');
            cancelBtn.className = 'btn small';
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => document.body.removeChild(overlay);
            footer.appendChild(cancelBtn);
            modal.appendChild(footer);

            overlay.appendChild(modal);
            overlay.onclick = (e) => {
                if (e.target === overlay) document.body.removeChild(overlay);
            };
            document.body.appendChild(overlay);
        }

        // ============================================================================
        // MERGED CHILDREN HELPER
        // ============================================================================

        function getMergedChildrenWithProvenance(blueprint, instance, fieldId) {
            const field = blueprint.fields.find(f => f.id === fieldId);
            if (!field) return [];

            if (!instance) return [];

            const result = [];
            const val = instance.fieldValues[fieldId];
            let children = [];

            if (field.fieldKind === FIELD_KIND.INSTANTIATOR) {
                // FIXED: Both modes now store IDs, resolve to instance
                if (val) {
                    const resolved = findInstanceById(val);
                    if (resolved) children = [resolved];
                }
            } else if (field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                // FIXED: Both modes now store IDs, resolve to instances
                if (Array.isArray(val)) {
                    children = val.map(id => findInstanceById(id)).filter(Boolean);
                }
            }

            // Add all children with provenance
            for (let i = 0; i < children.length; i++) {
                if (isRuntimeInstance(children[i])) {
                    // FIXED: Determine origin by checking _parent ownership, not field mode
                    const isOwned = children[i]._parent === instance.id;
                    result.push({
                        child: children[i],
                        origin: isOwned ? 'dynamic' : 'reference',
                        dynamicIndex: i
                    });
                }
            }

            return result;
        }

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        /**
         * Initialize sample data if state is empty.
         */
        function initSampleIfEmpty() {
            if (state.blueprints.length > 0 && state.rootInstanceId) return;

            state.blueprints = [];
            state.instances = {};

            const rootT = {
                id: generateUUID(),
                name: 'DharmaForge',
                type: 'Root',
                fields: [
                    {
                        id: generateUUID(),
                        name: 'Title',
                        fieldKind: FIELD_KIND.PRIMITIVE,
                        primitiveType: PRIMITIVE_TYPE.TEXT
                    }
                ]
            };

            state.blueprints.push(rootT);

            const rootInst = createInstance(rootT.id);
            rootInst.fieldValues[rootT.fields[0].id] = 'My Knowledge Base';
            state.rootInstanceId = rootInst.id;

            save();
        }

        // ============================================================================
        // RENDER ORCHESTRATION
        // ============================================================================

        function preserveScroll(fn) {
            const nodes = document.querySelectorAll('[data-scroll-key]');
            const scroll = {};

            nodes.forEach(el => {
                scroll[el.dataset.scrollKey] = el.scrollTop;
            });

            fn(); // destructive render

            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    nodes.forEach(el => {
                        const key = el.dataset.scrollKey;
                        if (scroll[key] !== undefined) {
                            el.scrollTop = scroll[key];
                        }
                    });
                });
            });
        }


        function renderAll() {
            preserveScroll(() => {
                renderHierarchy();
                renderLibrary();
                renderEditor();
            });
            updateUndoButtons();
            updateNavButtons();
        }

        const el = {
            hierarchy: document.getElementById('hierarchy'),
            templateList: document.getElementById('templateList'),
            editor: document.getElementById('editor'),
            selectedSummary: document.getElementById('selectedSummary'),
            templateSearch: document.getElementById('templateSearch'),
            verboseToggle: document.getElementById('verboseToggle'),
            backBtn: document.getElementById('backBtn'),
            forwardBtn: document.getElementById('forwardBtn')
        };

        /**
         * Smart instance label used throughout the UI.
         * Accepts either an instance object or an instance ID string.
         *
         * Lookup rules (in order):
         *  1. If instance.fieldValues has a common "name/title/label" primitive -> use it.
         *  2. If the blueprint defines a labelField -> use that field's value.
         *  3. If the blueprint has a first primitive field -> use that.
         *  4. Fallback to "BlueprintName #<short-id>".
         *
         * Uses existing helpers: findInstanceById(id) and findBlueprintById(id).
         */
        function getInstanceLabel(idOrInst) {
            if (!idOrInst) return '<?>';

            // Accept either string id or instance object
            const inst = (typeof idOrInst === 'string') ? findInstanceById(idOrInst) : idOrInst;

            // If we were given a string id but instance is missing, return short id
            if (typeof idOrInst === 'string' && !inst) {
                return idOrInst.slice ? idOrInst.slice(0, 8) : String(idOrInst);
            }

            if (!inst) return '<?>';

            // 1) Explicit instance-level name stored as a primitive field (common keys)
            const fv = inst.fieldValues || {};
            //const commonNameKeys = ['name', 'title', 'label'];
            //for (const k of commonNameKeys) {
            //    if (fv[k] !== undefined && fv[k] !== null && fv[k] !== '') {
            //        return String(fv[k]);
            //    }
            //}

            // 2) Blueprint-aware label field
            const bp = findBlueprintById(inst.templateId);
            if (bp) {
                if (bp.labelField && fv[bp.labelField] !== undefined && fv[bp.labelField] !== null && fv[bp.labelField] !== '') {
                    return String(fv[bp.labelField]);
                }

                /*
                Use first primitive field value (if present)
                if (Array.isArray(bp.fields)) {
                    const firstPrim = bp.fields.find(f => f && f.fieldKind === FIELD_KIND.PRIMITIVE);
                    if (firstPrim && fv[firstPrim.id] !== undefined && fv[firstPrim.id] !== null && fv[firstPrim.id] !== '') {
                        return String(fv[firstPrim.id]);
                    }
                }*/
            }

            // 4) Fallback: blueprint name (if available) + short id
            const bpName = bp && bp.name ? bp.name : 'Blueprint';
            const shortId = inst.id ? inst.id.slice(0, 8) : '?';
            return `${bpName} #${shortId}`;
        }

        /**
         * Get the status of a referenced instance for chip rendering.
         * Returns: { exists, isOrphaned, cssClass, icon, tooltip, label }
         */
        function getReferenceStatus(refId, parentInst = null, field = null) {
            const target = findInstanceById(refId);
            const isOrphaned = target && isInstanceOrphaned(refId);

            // Check type filter mismatch
            let filterMismatch = false;
            if (target && field && field.blueprintTypeFilter) {
                const targetBlueprint = findBlueprintById(target.templateId);
                if (targetBlueprint && targetBlueprint.type !== field.blueprintTypeFilter) {
                    filterMismatch = true;
                }
            }

            if (!target) {
                return {
                    exists: false,
                    isOrphaned: false,
                    cssClass: 'broken',
                    icon: 'üî¥',
                    tooltip: 'Broken reference (deleted)',
                    labelSuffix: ' (deleted)'
                };
            } else if (filterMismatch) {
                return {
                    exists: true,
                    isOrphaned: false,
                    cssClass: 'broken',
                    icon: 'üî¥',
                    tooltip: 'Type filter mismatch',
                    labelSuffix: ' (wrong type)'
                };
            } else if (isOrphaned) {
                return {
                    exists: true,
                    isOrphaned: true,
                    cssClass: 'orphaned',
                    icon: '‚ö†Ô∏è',
                    tooltip: 'Orphaned instance (unreachable from root)',
                    labelSuffix: ' (orphaned)'
                };
            } else {
                return {
                    exists: true,
                    isOrphaned: false,
                    cssClass: null,
                    icon: null,
                    tooltip: null,
                    labelSuffix: ''
                };
            }
        }

        /**
         * Create twisty for reference chip.
         */
        function createReferenceTwisty(refId, refStatus, inst, f) {
            const isExpanded = isChipExpanded(inst.id, f.id, refId);

            const twisty = document.createElement('span');
            twisty.className = 'chip-twisty';

            if (refStatus.icon) {
                twisty.textContent = refStatus.icon;
                twisty.title = refStatus.tooltip;
                if (refStatus.isOrphaned) {
                    // Orphaned instances can still be expanded
                    twisty.classList.add('expandable');
                    twisty.onclick = (e) => {
                        e.stopPropagation();
                        toggleChipExpansion(inst.id, f.id, refId);
                    };
                }
            } else {
                twisty.classList.add('expandable');
                twisty.textContent = isExpanded ? '‚ñæ' : '‚ñ∏';
                twisty.title = isExpanded ? 'Click to collapse' : 'Click to expand';
                twisty.onclick = (e) => {
                    e.stopPropagation();
                    toggleChipExpansion(inst.id, f.id, refId);
                };
            }

            return twisty;
        }

        // ============================================================================
        // HIERARCHY RENDERING (HARDENED)
        // ============================================================================

        function renderHierarchy() {
            el.hierarchy.innerHTML = '';
            const root = getRootInstance();
            if (!root) return;

            // HARDENING: Show validation warnings if present
            if (validationWarningsVisible && lastValidationResult && !lastValidationResult.valid) {
                const banner = document.createElement('div');
                banner.className = 'warning-banner';
                banner.style.marginBottom = '8px';
                banner.innerHTML = `‚ö†Ô∏è State has validation issues. Click Validate for details.`;
                banner.style.cursor = 'pointer';
                banner.onclick = () => {
                    document.getElementById('validateBtn').click();
                };
                el.hierarchy.appendChild(banner);
            }

            const treeRoot = document.createElement('div');
            treeRoot.className = 'tree-root';
            const ul = document.createElement('ul');
            ul.className = 'tree-branch';

            function buildLi(inst, visited = new Set(), origin = 'dynamic') {
                if (visited.has(inst.id)) {
                    const li = document.createElement('li');
                    const node = document.createElement('div');
                    node.className = 'tree-node';
                    node.style.color = 'var(--danger)';
                    node.textContent = '‚ö†Ô∏è Circular reference';
                    li.appendChild(node);
                    return li;
                }
                visited.add(inst.id);

                const blueprint = findBlueprintById(inst.templateId) || { name: 'üì¶ (Blueprint Deleted)', type: '?', fields: [] };
                const li = document.createElement('li');
                const node = document.createElement('div');
                node.className = 'tree-node';
                if (selected.kind === 'instance' && selected.id === inst.id) {
                    node.classList.add('selected');
                }

                // HARDENING: Mark if instance is not in registry
                if (!isInstanceInRegistry(inst.id)) {
                    node.style.borderLeft = '3px solid var(--danger)';
                    node.title = 'Instance not in registry';
                }

                // Check if has children
                const hasChildren = (() => {
                    for (const f of blueprint.fields || []) {
                        if (f.fieldKind === FIELD_KIND.INSTANTIATOR || f.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                            const merged = getMergedChildrenWithProvenance(blueprint, inst, f.id);
                            if (merged.length > 0) return true;
                        }
                    }
                    return false;
                })();

                const expanded = !collapsed[inst.id];
                const twisty = document.createElement('div');
                twisty.className = 'twisty';
                twisty.innerHTML = hasChildren ? (expanded ? '‚ñæ' : '‚ñ∏') : '';
                twisty.onclick = (e) => {
                    e.stopPropagation();
                    if (!hasChildren) return;
                    collapsed[inst.id] = !collapsed[inst.id];
                    renderAll();
                };
                node.appendChild(twisty);

                const label = document.createElement('div');
                label.className = 'node-label';
                const nameSpan = document.createElement('div');
                nameSpan.className = 'card-name';

                // Show reference icon and green color for referenced instances
                if (origin === 'reference') {
                    const refIcon = document.createElement('span');
                    refIcon.textContent = 'üîó ';
                    refIcon.style.color = 'var(--success)';
                    nameSpan.appendChild(refIcon);

                    const nameText = document.createElement('span');
                    nameText.textContent = blueprint.name;
                    nameText.style.color = 'var(--success)';
                    nameSpan.appendChild(nameText);
                } else {
                    nameSpan.textContent = blueprint.name;
                }

                label.appendChild(nameSpan);

                const issues = scanInstanceIssues(inst);

                if (issues.errorCount > 0) {
                    const badge = document.createElement('span');
                    badge.textContent = `üî¥ ${issues.errorCount}`;
                    badge.style.fontSize = '11px';
                    badge.style.color = 'var(--danger)';
                    badge.style.marginLeft = '6px';
                    label.appendChild(badge);
                }

                if (issues.warningCount > 0) {
                    const badge = document.createElement('span');
                    badge.textContent = `‚ö†Ô∏è ${issues.warningCount}`;
                    badge.style.fontSize = '11px';
                    badge.style.color = 'var(--warning)';
                    badge.style.marginLeft = '6px';
                    label.appendChild(badge);
                }

                const typeSpan = document.createElement('div');
                typeSpan.className = 'card-type muted';
                typeSpan.textContent = blueprint.type;
                label.appendChild(typeSpan);

                const idSpan = document.createElement('div');
                idSpan.className = 'muted';
                idSpan.style.marginLeft = 'auto';
                idSpan.textContent = inst.id ? inst.id.slice(0, 8) : '';
                label.appendChild(idSpan);

                node.appendChild(label);
                node.onclick = (e) => {
                    e.stopPropagation();

                    // Force save of any active input before navigation
                    const activeInput = document.querySelector('input.valueInputDark:focus');
                    if (activeInput) {
                        // Manually trigger the input's save logic
                        activeInput.blur(); // Triggers onblur

                        // Also manually save to ensure it's immediate
                        // Find the instance and field being edited
                        // (The blur handler will also save, but this ensures immediate save)
                        save();
                    }

                    navigateTo('instance', inst.id);
                };

                // HARDENING: Prevent dragging root
                node.draggable = isRuntimeInstance(inst) && inst.id !== state.rootInstanceId;

                if (node.draggable) {
                    node.ondragstart = (e) => {
                        e.dataTransfer.setData('text/plain', JSON.stringify({
                            type: 'instance-move',
                            instanceId: inst.id
                        }));
                        e.dataTransfer.effectAllowed = 'move';
                    };
                }

                li.appendChild(node);

                // Verbose mode: show field values
                if (verboseMode) {
                    const details = document.createElement('div');
                    details.style.padding = '4px 8px';
                    details.style.marginLeft = '18px';

                    for (const f of blueprint.fields || []) {
                        const fLine = document.createElement('div');
                        fLine.style.display = 'flex';
                        fLine.style.gap = '8px';
                        fLine.style.alignItems = 'center';

                        const key = document.createElement('div');
                        key.className = 'field-key';
                        key.textContent = f.name;
                        key.style.width = '140px';

                        const valArea = document.createElement('div');
                        valArea.style.flex = '1';
                        valArea.className = 'muted';

                        if (f.fieldKind === FIELD_KIND.PRIMITIVE) {
                            let primVal;

                            const isStaticDefault =
                                blueprint.isStatic &&
                                blueprint.staticValues &&
                                blueprint.staticValues[f.id] !== undefined &&
                                inst.fieldValues?.[f.id] === undefined;

                            if (isStaticDefault) {
                                primVal = blueprint.staticValues[f.id];
                                valArea.textContent = `${String(primVal)} (default)`;
                                valArea.style.opacity = '0.7';
                            } else {
                                primVal = inst.fieldValues?.[f.id];
                                valArea.textContent =
                                    primVal === null ? '[NULL]' :
                                        primVal === undefined ? '[EMPTY]' :
                                            String(primVal);
                            }
                        } else if (f.fieldKind === FIELD_KIND.INSTANCE_REFERENCE) {
                            const ids = inst.fieldValues?.[f.id];
                            if (Array.isArray(ids)) {
                                valArea.textContent = `üîó ${ids.length} ref(s)`;
                            } else {
                                valArea.textContent = '[EMPTY]';
                            }
                        } else if (f.fieldKind === FIELD_KIND.INSTANCE_REFERENCE_LIST) {
                            // Show ordered list of referenced instance names (vertical, numbered)
                            let ids = inst.fieldValues?.[f.id];
                            if (Array.isArray(ids)) {
                                // Normalize to string IDs (in case of object corruption)
                                ids = ids.map(item => {
                                    if (typeof item === 'object' && item !== null && item.id) {
                                        return item.id;
                                    }
                                    return item;
                                }).filter(id => typeof id === 'string');

                                if (ids.length === 0) {
                                    valArea.textContent = '[EMPTY]';
                                } else {
                                    // Create vertical numbered list
                                    valArea.innerHTML = '';
                                    valArea.style.display = 'flex';
                                    valArea.style.flexDirection = 'column';
                                    valArea.style.gap = '2px';

                                    ids.forEach((refId, index) => {
                                        const refInst = findInstanceById(refId);
                                        const refBlueprint = refInst ? findBlueprintById(refInst.templateId) : null;

                                        // Use blueprint name
                                        const refName = refInst && refBlueprint ? refBlueprint.name : '‚ö†Ô∏è [missing]';

                                        const item = document.createElement('div');
                                        item.style.fontSize = '11px';
                                        item.style.display = 'flex';
                                        item.style.gap = '4px';

                                        const num = document.createElement('span');
                                        num.textContent = `${index + 1}.`;
                                        num.style.minWidth = '20px';
                                        num.style.color = 'var(--muted)';

                                        const name = document.createElement('span');
                                        name.textContent = refName;
                                        name.className = refInst ? '' : 'muted';

                                        item.appendChild(num);
                                        item.appendChild(name);
                                        valArea.appendChild(item);
                                    });
                                }
                            } else {
                                valArea.textContent = '[EMPTY]';
                            }
                        } else if (f.fieldKind === FIELD_KIND.INSTANTIATOR || f.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                            const merged = getMergedChildrenWithProvenance(blueprint, inst, f.id);
                            valArea.textContent = merged.map(x => {
                                const childBlueprint = findBlueprintById(x.child.templateId);
                                return childBlueprint?.name || 'üì¶ (Blueprint Deleted)';
                            }).join(', ');
                        }

                        fLine.appendChild(key);
                        fLine.appendChild(valArea);
                        details.appendChild(fLine);
                    }

                    li.appendChild(details);
                }

                // Render children
                if (hasChildren && expanded) {
                    const branch = document.createElement('ul');
                    branch.className = 'tree-branch';

                    for (const f of blueprint.fields || []) {
                        if (f.fieldKind === FIELD_KIND.INSTANTIATOR || f.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                            const merged = getMergedChildrenWithProvenance(blueprint, inst, f.id);
                            for (const item of merged) {
                                // CRITICAL: Only track visited for OWNED children (origin = 'dynamic')
                                // Referenced children should not contribute to cycle detection
                                const childVisited = item.origin === 'dynamic' ? visited : new Set();
                                const childLi = buildLi(item.child, childVisited, item.origin);
                                branch.appendChild(childLi);
                            }
                        }
                    }

                    li.appendChild(branch);
                }

                return li;
            }

            const rootLi = buildLi(root, new Set(), 'dynamic');
            ul.appendChild(rootLi);
            treeRoot.appendChild(ul);
            el.hierarchy.appendChild(treeRoot);
            el.selectedSummary.textContent = selected.id ?
                `${selected.kind}: ${selected.id.slice(0, 8)}` : '‚Äî';
        }

        // ============================================================================
        // LIBRARY RENDERING
        // ============================================================================

        function renderLibrary() {
            const q = (el.templateSearch.value || '').toLowerCase();
            el.templateList.innerHTML = '';
            const frag = document.createDocumentFragment();

            for (const t of state.blueprints) {
                if (q && !(t.name.toLowerCase().includes(q) || (t.type || '').toLowerCase().includes(q))) {
                    continue;
                }

                const row = document.createElement('div');
                row.className = 'card-row' +
                    (selected.kind === 'blueprint' && selected.id === t.id ? ' selected' : '');
                if (t.isStatic) row.classList.add('static-blueprint');

                row.onclick = (e) => {
                    e.stopPropagation();
                    navigateTo('blueprint', t.id);
                };

                // Scan for field issues
                const issues = scanBlueprintIssues(t);
                const hasIssues = issues.warnings > 0 || issues.errors > 0;

                // Add issue styling
                if (issues.errors > 0) {
                    row.classList.add('has-errors');
                } else if (issues.warnings > 0) {
                    row.classList.add('has-warnings');
                }

                const mid = document.createElement('div');
                mid.style.flex = '1';

                // Build issue badges
                let issueBadges = '';
                if (issues.warnings > 0) {
                    issueBadges += `<span class="issue-badge" title="${issues.warnings} unselected type filter(s)">‚ö†Ô∏è (${issues.warnings})</span>`;
                }
                if (issues.errors > 0) {
                    issueBadges += `<span class="issue-badge" title="${issues.errors} broken type reference(s)">üî¥ (${issues.errors})</span>`;
                }

                mid.innerHTML = `<div class='card-name'>${t.name}${t.isStatic ? ' (<span class="static-badge">static</span>)' : ''}${issueBadges}</div><div class='card-type muted'>${t.type}</div>`;
                row.appendChild(mid);

                const actions = document.createElement('div');
                actions.style.display = 'flex';
                actions.style.gap = '6px';

                if (!isRootBlueprintId(t.id)) {
                    // Clone button
                    const cloneBtn = document.createElement('button');
                    cloneBtn.className = 'btn small';
                    cloneBtn.textContent = 'üìã Clone';
                    cloneBtn.title = 'Create a copy of this blueprint';
                    cloneBtn.onclick = (e) => {
                        e.stopPropagation();
                        cloneBlueprint(t.id);
                    };
                    actions.appendChild(cloneBtn);

                    const delBtn = document.createElement('button');
                    delBtn.className = 'btn small danger';
                    delBtn.textContent = 'Delete';
                    delBtn.onclick = (e) => {
                        e.stopPropagation();  // Prevent row click

                        if (isRootBlueprintId(t.id)) {
                            alert('Cannot delete root blueprint');
                            return;
                        }

                        // HARD CONTRACT: Block deletion if instances exist
                        const instances = Object.values(state.instances).filter(inst =>
                            inst.templateId === t.id
                        );

                        if (instances.length > 0) {
                            const instanceList = instances.map(inst => {
                                const parent = findInstanceById(inst._parent);
                                const parentBlueprint = parent ? findBlueprintById(parent.templateId) : null;
                                const containerField = parentBlueprint?.fields.find(f => f.id === inst._parentField);

                                const location = containerField ?
                                    `${parentBlueprint.name}.${containerField.name}` :
                                    'Unknown location';

                                return `  ‚Ä¢ Instance ${inst.id.slice(0, 8)} in ${location}`;
                            }).join('\n');

                            alert(
                                `Cannot delete blueprint ${t.name}\n\n` +
                                `${instances.length} instance(s) still exist:\n\n${instanceList}\n\n` +
                                `Delete all instances first, then delete the blueprint.`
                            );
                            return;
                        }

                        if (confirm(`Delete blueprint ${t.name}?`)) {
                            pushUndo();
                            state.blueprints = state.blueprints.filter(blueprint => blueprint.id !== t.id);
                            invalidateBlueprintMap();

                            // Clear selection if deleted blueprint was selected
                            if (selected.kind === 'blueprint' && selected.id === t.id) {
                                selected = { kind: 'instance', id: state.rootInstanceId };
                                navigateTo('instance', state.rootInstanceId, false);
                            }

                            save();
                            renderAll();
                        }
                    };
                    actions.appendChild(delBtn);
                }

                row.appendChild(actions);
                frag.appendChild(row);
            }

            el.templateList.appendChild(frag);
        }

        // ============================================================================
        // EDITOR RENDERING (HARDENED)
        // ============================================================================

        function renderEditor() {
            const container = el.editor;
            container.innerHTML = '';

            if (!selected.id) {
                container.innerHTML = '<div class="muted">Select a blueprint or instance to edit.</div>';
                return;
            }

            const wrapper = document.createElement('div');
            wrapper.className = 'editor-content';

            const modeIndicator = document.createElement('div');
            modeIndicator.className = 'editor-mode-indicator ' +
                (selected.kind === 'instance' ? 'editor-mode-hierarchy' : 'editor-mode-library');
            modeIndicator.textContent = selected.kind === 'instance' ?
                'üìã Editing Instance (Hierarchy)' : 'üìö Editing Blueprint (Library)';
            wrapper.appendChild(modeIndicator);

            if (selected.kind === 'blueprint') {
                renderBlueprintEditor(wrapper);
            } else if (selected.kind === 'instance') {
                renderInstanceEditor(wrapper);
            }

            container.appendChild(wrapper);
        }

        /**
                 * Render blueprint type filter dropdown for instantiator/instanceReference fields.
                 * Handles orphaned blueprint types by showing a warning option.
                 * 
                 * @param {Object} field - The field definition
                 * @param {Object} blueprint - The parent blueprint
                 * @returns {HTMLSelectElement} The configured select element
                 */
        function renderBlueprintTypeFilterDropdown(field, blueprint) {

            console.log('üîç Filter dropdown:', {
                fieldName: field.name,
                blueprintTypeFilter: field.blueprintTypeFilter,
                typeOfFilter: typeof field.blueprintTypeFilter,
                isNull: field.blueprintTypeFilter === null,
                isEmpty: field.blueprintTypeFilter === ''
            });
            const filterSel = document.createElement('select');

            // Build list of all existing types (filter out null/undefined, don't inject "Generic")
            const types = Array.from(new Set(
                state.blueprints
                    .map(t => t.type)
                    .filter(t => t && typeof t === 'string' && t.trim() !== '')
            )).filter(t => t !== 'Root').sort();

            const filterType = field.blueprintTypeFilter;
            const hasNoSelection = !filterType || filterType === null || filterType === '';
            const filterTypeExists = filterType && types.includes(filterType);

            // CASE 1: No type selected yet (new field)
            if (hasNoSelection) {
                const placeholderOpt = document.createElement('option');
                placeholderOpt.value = '';
                placeholderOpt.textContent = '‚Äî Select Blueprint Type ‚Äî';
                placeholderOpt.disabled = true;
                placeholderOpt.selected = true;
                filterSel.appendChild(placeholderOpt);

                filterSel.classList.add('invalid');
                filterSel.style.cssText = 'border: 1px solid var(--warning) !important; background: rgba(251, 191, 36, 0.08) !important;';
                filterSel.title = 'Please select a blueprint type for this field';
            }
            // CASE 2: Type selected but blueprint deleted (broken reference)
            else if (filterType && !filterTypeExists) {
                const missingOpt = document.createElement('option');
                missingOpt.value = filterType;
                missingOpt.textContent = `‚ö† Filter type missing: ${filterType}`;
                missingOpt.disabled = true;
                missingOpt.selected = true;
                filterSel.appendChild(missingOpt);

                // Add separator
                const separator = document.createElement('option');
                separator.disabled = true;
                separator.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
                filterSel.appendChild(separator);

                filterSel.classList.add('invalid');
                filterSel.style.cssText = 'border: 1px solid var(--danger) !important; background: rgba(255, 107, 107, 0.08) !important;';
                filterSel.title = 'This field references a blueprint type that no longer exists. Select a new type from the list below.';

                // Add orphaned type to list so user can re-select it if desired
                if (!types.includes(filterType)) {
                    types.push(filterType);
                    types.sort();
                }
            }

            // Add all valid types
            for (const ty of types) {
                const o = document.createElement('option');
                o.value = ty;
                o.textContent = ty;
                filterSel.appendChild(o);
            }

            // Set current value (only if valid selection exists)
            if (!hasNoSelection && filterTypeExists) {
                filterSel.value = field.blueprintTypeFilter;
            }

            filterSel.onchange = () => {
                pushUndo();
                field.blueprintTypeFilter = filterSel.value;

                // Also update allowedTemplateIds to match all blueprints of this type
                if (filterSel.value) {
                    field.allowedTemplateIds = state.blueprints
                        .filter(bp => bp.type === filterSel.value)
                        .map(bp => bp.id);
                } else {
                    field.allowedTemplateIds = [];
                }

                save();
                renderAll();
            };

            return filterSel;
        }

        function updateFieldIndicators() {
            const blueprint = findBlueprintById(selected.id);
            if (!blueprint || selected.kind !== 'blueprint') return;

            // Find all field definition rows
            const fieldDefs = document.querySelectorAll('.field-def');

            fieldDefs.forEach((fd, idx) => {
                if (idx >= blueprint.fields.length) return;
                const field = blueprint.fields[idx];

                // Only update primitive fields
                if (field.fieldKind !== FIELD_KIND.PRIMITIVE) {
                    fd.classList.remove('has-default');
                    fd.title = '';
                    return;
                }

                // Check if field has a non-empty default value
                const hasDefault = blueprint.isStatic &&
                    blueprint.staticValues &&
                    blueprint.staticValues[field.id] !== undefined &&
                    blueprint.staticValues[field.id] !== null &&
                    blueprint.staticValues[field.id] !== '';

                if (hasDefault) {
                    fd.classList.add('has-default');
                    const defaultValue = blueprint.staticValues[field.id];
                    const displayValue = typeof defaultValue === 'number' ? defaultValue : `"${defaultValue}"`;
                    fd.title = `Default value: ${displayValue}`;
                } else {
                    fd.classList.remove('has-default');
                    fd.title = '';
                }
            });
        }

        function renderBlueprintEditor(wrapper) {
            const blueprint = findBlueprintById(selected.id);
            if (!blueprint) {
                wrapper.innerHTML = '<div class="muted">Blueprint not found.</div>';
                return;
            }

            const wrap = document.createElement('div');

            // Blueprint name
            const nameLabel = document.createElement('label');
            nameLabel.textContent = 'Blueprint Name';
            const nameInput = document.createElement('input');
            nameInput.value = blueprint.name;
            nameInput.disabled = isRootBlueprintId(blueprint.id);
            nameInput.onfocus = () => pushUndo();
            nameInput.oninput = () => {
                blueprint.name = nameInput.value;
                debouncedSave();  // Don't save on every keystroke
            };
            nameInput.onblur = () => {
                clearTimeout(saveTimeout);  // Cancel debounce
                save();  // Immediate save
                invalidateBlueprintMap();  // Blueprint name changed
                renderAll();  // Update library and hierarchy
            };

            wrap.appendChild(nameLabel);
            wrap.appendChild(nameInput);

            // Blueprint type
            const typeLabel = document.createElement('label');
            typeLabel.textContent = 'Blueprint Type';

            const typeSelect = document.createElement('select');
            typeSelect.classList.add('valueInputDark');
            typeSelect.disabled = isRootBlueprintId(blueprint.id);

            // Visual indicator if instances exist
            const instances = Object.values(state.instances).filter(inst =>
                inst.templateId === blueprint.id
            );
            if (instances.length > 0) {
                typeSelect.style.setProperty('border-style', 'dashed', 'important');
                typeSelect.style.setProperty('border-color', 'rgba(168, 85, 247, 0.4)', 'important');
                typeSelect.style.setProperty('border-width', '1px', 'important');
                typeSelect.style.setProperty('background', 'rgba(168, 85, 247, 0.02)', 'important');
                typeSelect.title = `‚ö†Ô∏è Type locked: ${instances.length} instance(s) exist`;
            }

            // Gather existing types (excluding Root)
            const existingTypes = Array.from(new Set(
                state.blueprints.map(t => t.type).filter(t => t && t !== 'Root')
            )).sort();

            // HARDENING: surface missing blueprintTypeFilte

            // Add existing types as options
            for (const type of existingTypes) {
                const opt = document.createElement('option');
                opt.value = type;
                opt.textContent = type;
                typeSelect.appendChild(opt);
            }

            // Add separator and "Create new..." option
            if (existingTypes.length > 0) {
                const separator = document.createElement('option');
                separator.disabled = true;
                separator.textContent = '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ';
                typeSelect.appendChild(separator);
            }

            const newOpt = document.createElement('option');
            newOpt.value = '__new__';
            newOpt.textContent = '+ Create new type...';
            typeSelect.appendChild(newOpt);

            // Set current value
            typeSelect.value = blueprint.type;

            // Handle selection change
            typeSelect.onchange = () => {
                // Check if instances exist
                const instances = Object.values(state.instances).filter(inst =>
                    inst.templateId === blueprint.id
                );

                if (instances.length > 0) {
                    const instanceList = instances.slice(0, 5).map(inst => {
                        const label = getInstanceLabel(inst.id);
                        return `  ‚Ä¢ ${label} (${inst.id.slice(0, 8)})`;
                    }).join('\n');

                    const more = instances.length > 5 ? `\n  ... and ${instances.length - 5} more` : '';

                    alert(
                        `‚ùå Cannot change blueprint type\n\n` +
                        `${instances.length} instance(s) exist:\n\n${instanceList}${more}\n\n` +
                        `Delete all instances first, then change the type.`
                    );

                    typeSelect.value = blueprint.type; // Revert dropdown
                    return;
                }

                if (typeSelect.value === '__new__') {
                    const newType = prompt('Enter new type name:');
                    if (newType && newType.trim()) {
                        pushUndo();
                        blueprint.type = newType.trim();
                        save();
                        renderAll();
                    } else {
                        typeSelect.value = blueprint.type; // Revert if cancelled
                    }
                } else {
                    pushUndo();
                    blueprint.type = typeSelect.value;
                    invalidateBlueprintMap();
                    save();
                    renderAll();
                }
            };

            wrap.appendChild(nameLabel);
            wrap.appendChild(nameInput);
            wrap.appendChild(typeLabel);
            wrap.appendChild(typeSelect);

            // ============================================================================
            // STATIC BLUEPRINT DEFAULTS SECTION
            // ============================================================================

            // HARDENING: Ensure staticValues exists
            if (!blueprint.staticValues) {
                blueprint.staticValues = {};
            }

            // Static defaults toggle and editor
            const staticSection = document.createElement('div');
            staticSection.style.marginTop = '20px';
            staticSection.style.padding = '16px';
            staticSection.style.border = '1px solid var(--border)';
            staticSection.style.borderRadius = '6px';
            staticSection.style.backgroundColor = 'rgba(251,191,36,0.05)';

            // Section header with checkbox
            const staticHeader = document.createElement('div');
            staticHeader.style.display = 'flex';
            staticHeader.style.alignItems = 'center';
            staticHeader.style.gap = '8px';
            staticHeader.style.marginBottom = '12px';

            const staticToggle = document.createElement('input');
            staticToggle.type = 'checkbox';
            staticToggle.id = 'staticToggle';
            staticToggle.checked = !!blueprint.isStatic;
            staticToggle.style.cursor = 'pointer';

            const staticLabel = document.createElement('label');
            staticLabel.htmlFor = 'staticToggle';
            staticLabel.textContent = 'Use blueprint defaults';
            staticLabel.style.cursor = 'pointer';
            staticLabel.style.fontWeight = '600';
            staticLabel.title = 'Pre-fill new instances with default values';

            staticHeader.appendChild(staticToggle);
            staticHeader.appendChild(staticLabel);
            staticSection.appendChild(staticHeader);

            // Help text
            const staticHelp = document.createElement('div');
            staticHelp.className = 'muted';
            staticHelp.style.fontSize = '12px';
            staticHelp.style.marginBottom = '12px';
            staticHelp.textContent = 'New instances will start with these default values. Existing instances are not affected.';
            staticSection.appendChild(staticHelp);

            // Container for default value inputs
            const defaultsContainer = document.createElement('div');
            defaultsContainer.style.display = blueprint.isStatic ? 'block' : 'none';

            // Function to render default value inputs
            function renderDefaultInputs() {
                try {
                    defaultsContainer.innerHTML = '';

                    if (!blueprint || !blueprint.fields) {
                        const error = document.createElement('div');
                        error.className = 'muted';
                        error.textContent = 'Blueprint not found or has no fields.';
                        defaultsContainer.appendChild(error);
                        return;
                    }

                    // HARDENING: Ensure staticValues exists
                    if (!blueprint.staticValues) {
                        blueprint.staticValues = {};
                    }

                    const primitiveFields = blueprint.fields.filter(f => f && f.fieldKind === FIELD_KIND.PRIMITIVE);

                    if (primitiveFields.length === 0) {
                        const noFields = document.createElement('div');
                        noFields.className = 'muted';
                        noFields.textContent = 'No primitive fields yet. Add text or number fields to configure defaults.';
                        defaultsContainer.appendChild(noFields);
                        return;
                    }

                    for (const field of primitiveFields) {
                        if (!field || !field.id) continue;

                        const fieldRow = document.createElement('div');
                        fieldRow.style.marginBottom = '12px';

                        const fieldLabel = document.createElement('label');
                        fieldLabel.textContent = field.name || 'Unnamed field';
                        fieldLabel.style.display = 'block';
                        fieldLabel.style.marginBottom = '4px';
                        fieldLabel.style.fontSize = '13px';

                        const fieldInput = document.createElement('input');
                        fieldInput.type = field.primitiveType === PRIMITIVE_TYPE.NUMBER ? 'number' : 'text';

                        // HARDENING: Safe access to staticValues with fallback
                        const currentValue = blueprint.staticValues[field.id];
                        const defaultValue = field.primitiveType === PRIMITIVE_TYPE.NUMBER ? 0 : '';
                        fieldInput.value = (currentValue !== undefined && currentValue !== null) ? currentValue : defaultValue;

                        fieldInput.style.width = '100%';
                        fieldInput.placeholder = `Default value for new instances...`;

                        fieldInput.onfocus = () => pushUndo();
                        fieldInput.oninput = () => {
                            // HARDENING: Ensure staticValues exists before writing
                            if (!blueprint.staticValues) {
                                blueprint.staticValues = {};
                            }

                            if (field.primitiveType === PRIMITIVE_TYPE.NUMBER) {
                                blueprint.staticValues[field.id] = fieldInput.value === '' ? 0 : Number(fieldInput.value);
                            } else {
                                blueprint.staticValues[field.id] = fieldInput.value;
                            }
                            save();

                            // STATIC UI: Update field indicator without full re-render
                            updateFieldIndicators();
                        };

                        const fieldHint = document.createElement('div');
                        fieldHint.className = 'muted';
                        fieldHint.style.fontSize = '11px';
                        fieldHint.style.marginTop = '2px';

                        // Calculate usage statistics
                        let usingDefault = 0;
                        let overridden = 0;
                        let totalInstances = 0;

                        for (const instId in state.instances) {
                            const inst = state.instances[instId];
                            if (inst.templateId !== blueprint.id) continue;

                            totalInstances++;

                            if (inst.fieldValues[field.id] === undefined) {
                                usingDefault++;
                            } else {
                                overridden++;
                            }
                        }

                        if (totalInstances === 0) {
                            fieldHint.textContent = `New ${blueprint.name || 'instances'} will start with this value`;
                        } else {
                            const parts = [];
                            if (usingDefault > 0) parts.push(`${usingDefault} using default`);
                            if (overridden > 0) parts.push(`${overridden} overridden`);

                            fieldHint.textContent = `üìä ${parts.join(', ')} (${totalInstances} total)`;
                            fieldHint.title = `${usingDefault} instance(s) will use this blueprint default\n${overridden} instance(s) have custom values`;
                        }

                        fieldRow.appendChild(fieldLabel);
                        fieldRow.appendChild(fieldInput);
                        fieldRow.appendChild(fieldHint);
                        defaultsContainer.appendChild(fieldRow);
                    }
                } catch (error) {
                    console.error('Error rendering default inputs:', error);
                    defaultsContainer.innerHTML = '<div class="muted" style="color: var(--danger);">Error rendering defaults. Check console.</div>';
                }
            }

            // Initial render
            renderDefaultInputs();

            // Toggle handler
            staticToggle.onchange = () => {
                pushUndo();
                blueprint.isStatic = staticToggle.checked;

                // HARDENING: Initialize staticValues if enabling
                if (blueprint.isStatic && !blueprint.staticValues) {
                    blueprint.staticValues = {};
                }

                // Show/hide defaults container
                defaultsContainer.style.display = blueprint.isStatic ? 'block' : 'none';

                // Render inputs if showing
                if (blueprint.isStatic) {
                    renderDefaultInputs();
                }

                save();
                renderAll();
            };

            staticSection.appendChild(defaultsContainer);
            // ============================================================================
            // GENERATOR TOGGLE
            // ============================================================================
            const generatorSection = document.createElement('div');
            generatorSection.style.marginTop = '12px';
            generatorSection.style.padding = '12px';
            generatorSection.style.border = '1px solid var(--border)';
            generatorSection.style.borderRadius = '6px';
            generatorSection.style.backgroundColor = 'rgba(77,163,255,0.05)';

            const generatorHeader = document.createElement('div');
            generatorHeader.style.display = 'flex';
            generatorHeader.style.alignItems = 'center';
            generatorHeader.style.gap = '8px';

            const generatorToggle = document.createElement('input');
            generatorToggle.type = 'checkbox';
            generatorToggle.id = 'generatorToggle';
            generatorToggle.checked = !!blueprint.isGenerator;
            generatorToggle.style.cursor = 'pointer';

            const generatorLabel = document.createElement('label');
            generatorLabel.htmlFor = 'generatorToggle';
            generatorLabel.textContent = 'Blueprint Generator - Field-type callout codes: [txt], [num], [inst], [inst_list], [ref], [ref_list] - [field_name], [field_type], [allowed_types]';
            generatorLabel.style.cursor = 'pointer';
            generatorLabel.style.fontWeight = '600';
            generatorLabel.title = 'This blueprint generates other blueprints';

            generatorToggle.onchange = () => {
                pushUndo();
                blueprint.isGenerator = generatorToggle.checked;
                save();
            };

            generatorHeader.appendChild(generatorToggle);
            generatorHeader.appendChild(generatorLabel);
            generatorSection.appendChild(generatorHeader);
            wrap.appendChild(generatorSection);

            // ============================================================================
            // END GENERATOR SECTION
            // ============================================================================

            wrap.appendChild(staticSection);

            // ============================================================================
            // END DEFAULT SECTION
            // ============================================================================
            // Fields list
            const fieldList = document.createElement('div');
            fieldList.className = 'field-list';
            fieldList.style.display = 'flex';
            fieldList.style.flexDirection = 'column';
            fieldList.style.gap = '6px';  // Reduced from 8px


            for (let fieldIdx = 0; fieldIdx < blueprint.fields.length; fieldIdx++) {
                const f = blueprint.fields[fieldIdx];
                const fd = document.createElement('div');
                fd.className = 'field-def';

                // STATIC UI: Add visual indicator for fields with defaults
                if (blueprint.isStatic &&
                    f.fieldKind === FIELD_KIND.PRIMITIVE &&
                    blueprint.staticValues &&
                    blueprint.staticValues[f.id] !== undefined &&
                    blueprint.staticValues[f.id] !== null &&
                    blueprint.staticValues[f.id] !== '') {
                    fd.classList.add('has-default');

                    // Add tooltip showing default value
                    const defaultValue = blueprint.staticValues[f.id];
                    const displayValue = typeof defaultValue === 'number' ? defaultValue : `"${defaultValue}"`;
                    fd.title = `Default value: ${displayValue}`;
                }
                fd.draggable = true;

                // Drag handle
                const dragHandle = document.createElement('div');
                dragHandle.className = 'drag-handle';
                dragHandle.innerHTML = '‚ãÆ‚ãÆ';
                fd.appendChild(dragHandle);
                fd.style.display = 'flex';
                fd.style.alignItems = 'center';  // THIS IS KEY - vertically centers all items
                fd.style.gap = '8px';

                fd.ondragstart = (e) => {
                    e.dataTransfer.setData('text/plain', JSON.stringify({
                        type: 'field-reorder',
                        templateId: blueprint.id,
                        fieldIndex: fieldIdx
                    }));
                };
                fd.ondragover = (e) => {
                    e.preventDefault();
                    fd.classList.add('drag-over');
                };
                fd.ondragleave = () => {
                    fd.classList.remove('drag-over');
                };
                fd.ondrop = (e) => {
                    e.preventDefault();
                    fd.classList.remove('drag-over');
                    try {
                        const payload = JSON.parse(e.dataTransfer.getData('text/plain'));
                        if (payload.type === 'field-reorder' && payload.templateId === blueprint.id) {
                            pushUndo();
                            const [removed] = blueprint.fields.splice(payload.fieldIndex, 1);
                            blueprint.fields.splice(fieldIdx, 0, removed);
                            save();
                            renderAll();
                        }
                    } catch (err) {
                        console.error('Field reorder failed', err);
                    }
                };

                // Field name
                const inputName = document.createElement('input');
                inputName.value = f.name;
                inputName.style.flex = '1';
                inputName.style.minWidth = '120px';
                inputName.onfocus = () => pushUndo();
                inputName.oninput = () => { f.name = inputName.value; save(); };
                inputName.onblur = () => { save(); renderAll(); };
                fd.appendChild(inputName);

                // Field kind
                const kindSel = document.createElement('select');
                [FIELD_KIND.PRIMITIVE, FIELD_KIND.INSTANTIATOR, FIELD_KIND.INSTANTIATOR_LIST, FIELD_KIND.INSTANCE_REFERENCE, FIELD_KIND.INSTANCE_REFERENCE_LIST].forEach(k => {

                    const o = document.createElement('option');
                    o.value = k;
                    o.textContent = k;
                    kindSel.appendChild(o);
                });
                kindSel.value = f.fieldKind;
                kindSel.onchange = () => {
                    const oldKind = f.fieldKind;
                    const newKind = kindSel.value;

                    // Scan for affected instances and owned children that will be deleted
                    const affectedInstances = [];
                    let totalOwnedToDelete = 0;

                    for (const instId in state.instances) {
                        const inst = state.instances[instId];
                        if (inst.templateId !== blueprint.id) continue;

                        const val = inst.fieldValues[f.id];
                        if (!val) continue; // Skip empty fields

                        // Check if field has data
                        const hasData =
                            (typeof val === 'string' && val) ||
                            (Array.isArray(val) && val.length > 0);

                        if (!hasData) continue;

                        // For instantiator/instantiatorList fields, count owned children
                        let ownedChildren = [];
                        if (oldKind === FIELD_KIND.INSTANTIATOR || oldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                            const ids = oldKind === FIELD_KIND.INSTANTIATOR ? [val] : val;
                            for (const childId of ids) {
                                const child = findInstanceById(childId);
                                if (child && child._parent === instId) {
                                    ownedChildren.push({ id: childId, name: findBlueprintById(child.templateId)?.name || 'Unknown' });
                                }
                            }
                        }

                        if (hasData) {
                            affectedInstances.push({
                                id: instId,
                                ownedChildren: ownedChildren
                            });
                            totalOwnedToDelete += ownedChildren.length;
                        }
                    }

                    // Scan for references to instances that will be deleted
                    const allDeletedIds = new Set();
                    for (const a of affectedInstances) {
                        for (const child of a.ownedChildren) {
                            allDeletedIds.add(child.id);
                        }
                    }

                    // Find all references to deleted instances
                    const brokenReferences = [];
                    let totalBrokenRefs = 0;

                    if (allDeletedIds.size > 0) {
                        for (const instId in state.instances) {
                            if (allDeletedIds.has(instId)) continue; // Skip instances being deleted

                            const inst = state.instances[instId];
                            const bp = findBlueprintById(inst.templateId);
                            if (!bp) continue;

                            const refsInThisInstance = [];

                            for (const field of bp.fields) {
                                const val = inst.fieldValues[field.id];

                                // Check all reference field types
                                if (field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE && val) {
                                    const ids = typeof val === 'string' ? [val] : (Array.isArray(val) ? val : []);
                                    for (const id of ids) {
                                        if (allDeletedIds.has(id)) {
                                            refsInThisInstance.push(field.name);
                                        }
                                    }
                                }

                                if (field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE_LIST && Array.isArray(val)) {
                                    for (const id of val) {
                                        if (allDeletedIds.has(id)) {
                                            refsInThisInstance.push(field.name);
                                        }
                                    }
                                }

                                if (field.fieldKind === FIELD_KIND.INSTANTIATOR && val && typeof val === 'string') {
                                    if (allDeletedIds.has(val)) {
                                        refsInThisInstance.push(field.name);
                                    }
                                }

                                if (field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST && Array.isArray(val)) {
                                    for (const id of val) {
                                        if (allDeletedIds.has(id)) {
                                            refsInThisInstance.push(field.name);
                                        }
                                    }
                                }
                            }

                            if (refsInThisInstance.length > 0) {
                                brokenReferences.push({
                                    id: instId,
                                    count: refsInThisInstance.length,
                                    fields: refsInThisInstance
                                });
                                totalBrokenRefs += refsInThisInstance.length;
                            }
                        }
                    }

                    // Show warning if there's data or owned instances
                    if (affectedInstances.length > 0) {
                        const instanceDetails = affectedInstances.map(a => {
                            const instName = `Instance ${a.id.slice(0, 8)}`;
                            if (a.ownedChildren.length > 0) {
                                const childList = a.ownedChildren.map(c => c.name).join(', ');
                                return `  ‚Ä¢ ${instName}: ${a.ownedChildren.length} owned instance(s) will be deleted (${childList})`;
                            } else {
                                return `  ‚Ä¢ ${instName}: field data will be cleared`;
                            }
                        }).join('\n');

                        const confirmMsg =
                            `‚ö†Ô∏è FIELD TYPE CHANGE\n\n` +
                            `Changing "${f.name}" from ${oldKind} ‚Üí ${newKind}\n` +
                            `will clear this field in ${affectedInstances.length} instance(s).\n\n` +
                            (totalOwnedToDelete > 0 ?
                                `This will CASCADE DELETE ${totalOwnedToDelete} owned instance(s):\n\n${instanceDetails}\n\n` :
                                `Affected:\n${instanceDetails}\n\n`) +
                            (totalBrokenRefs > 0 ?
                                `This will CREATE ${totalBrokenRefs} BROKEN REFERENCE(S):\n\n` +
                                brokenReferences.map(br =>
                                    `  ‚Ä¢ Instance ${br.id.slice(0, 8)}: ${br.count} reference(s) will break (${br.fields.join(', ')})`
                                ).join('\n') + '\n\n' : '') +
                            `Continue?`;

                        if (!confirm(confirmMsg)) {
                            // Cancel: revert dropdown
                            kindSel.value = oldKind;
                            return;
                        }
                    }

                    pushUndo();

                    // CASCADE DELETE owned instances before clearing fields
                    for (const a of affectedInstances) {
                        for (const child of a.ownedChildren) {
                            deleteInstance(child.id);
                        }
                    }

                    // Change field kind
                    f.fieldKind = newKind;

                    // Update field properties based on new kind
                    if (f.fieldKind === FIELD_KIND.PRIMITIVE) {
                        delete f.blueprintTypeFilter;
                        delete f.fieldMode;
                        f.primitiveType = f.primitiveType || PRIMITIVE_TYPE.TEXT;
                    } else if (f.fieldKind === FIELD_KIND.INSTANCE_REFERENCE || f.fieldKind === FIELD_KIND.INSTANCE_REFERENCE_LIST) {
                        delete f.primitiveType;
                        delete f.fieldMode;
                        f.blueprintTypeFilter = f.blueprintTypeFilter || null;
                    } else {
                        delete f.primitiveType;
                        f.blueprintTypeFilter = f.blueprintTypeFilter || null;
                        f.fieldMode = f.fieldMode;
                    }

                    // Clear all field values for this field
                    for (const instId in state.instances) {
                        const inst = state.instances[instId];
                        if (inst.templateId !== blueprint.id) continue;

                        // Initialize based on new field kind
                        if (newKind === FIELD_KIND.PRIMITIVE) {
                            const primType = f.primitiveType || PRIMITIVE_TYPE.TEXT;
                            inst.fieldValues[f.id] = primType === PRIMITIVE_TYPE.NUMBER ? 0 : '';
                        } else if (newKind === FIELD_KIND.INSTANTIATOR_LIST || newKind === FIELD_KIND.INSTANCE_REFERENCE_LIST) {
                            inst.fieldValues[f.id] = [];
                        } else if (newKind === FIELD_KIND.INSTANTIATOR || newKind === FIELD_KIND.INSTANCE_REFERENCE) {
                            inst.fieldValues[f.id] = null;
                        }
                    }

                    save();
                    renderAll();
                };
                fd.appendChild(kindSel);

                // Additional controls based on field kind
                if (f.fieldKind === FIELD_KIND.PRIMITIVE) {
                    const psel = document.createElement('select');
                    [PRIMITIVE_TYPE.TEXT, PRIMITIVE_TYPE.NUMBER].forEach(p => {
                        const o = document.createElement('option');
                        o.value = p;
                        o.textContent = p;
                        psel.appendChild(o);
                    });
                    psel.value = f.primitiveType || PRIMITIVE_TYPE.TEXT;
                    psel.onchange = () => {
                        pushUndo();
                        f.primitiveType = psel.value;
                        save();
                        renderAll();
                    };
                    fd.appendChild(psel);
                } else if (f.fieldKind !== FIELD_KIND.INSTANCE_REFERENCE && f.fieldKind !== FIELD_KIND.INSTANCE_REFERENCE_LIST) {
                    // instantiator/instantiatorList: type filter
                    const filterSel = renderBlueprintTypeFilterDropdown(f, blueprint);
                    fd.appendChild(filterSel);
                } else {
                    // instanceReference or instanceReferenceList: type filter
                    const filterSel = renderBlueprintTypeFilterDropdown(f, blueprint);
                    fd.appendChild(filterSel);
                }

                // Remove button
                const rm = document.createElement('button');
                rm.className = 'btn small danger';
                rm.textContent = '√ó';
                rm.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm(`Remove field ${f.name}?`)) removeField(blueprint.id, f.id);
                };
                fd.appendChild(rm);

                fieldList.appendChild(fd);
            }

            wrap.appendChild(fieldList);

            // Add field button
            const addBtn = document.createElement('button');
            addBtn.className = 'btn small primary';
            addBtn.textContent = 'Add Field';
            addBtn.onclick = () => {
                const newF = {
                    id: generateUUID(),
                    name: 'field',
                    fieldKind: FIELD_KIND.PRIMITIVE,
                    primitiveType: PRIMITIVE_TYPE.TEXT
                };
                addField(blueprint.id, newF);
            };

            wrap.appendChild(addBtn);

            // Delete blueprint button
            if (!isRootBlueprintId(blueprint.id)) {
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'btn small danger';
                deleteBtn.textContent = 'üóëÔ∏è Delete Blueprint';
                deleteBtn.style.marginTop = '16px';

                deleteBtn.onclick = () => {
                    if (isRootBlueprintId(blueprint.id)) {
                        alert('Cannot delete root blueprint');
                        return;
                    }

                    // HARD CONTRACT: Block deletion if instances exist
                    const instances = Object.values(state.instances).filter(inst =>
                        inst.templateId === blueprint.id
                    );

                    if (instances.length > 0) {
                        console.log('üö´ BLOCKING: Found', instances.length, 'instances');
                        // ... build instanceList ...

                        alert(
                            `Cannot delete blueprint ${blueprint.name}\n\n` +
                            `${instances.length} instance(s) still exist:\n\n${instanceList}\n\n` +
                            `Delete all instances first, then delete the blueprint.`
                        );

                        console.log('üö´ RETURNED - deletion blocked');
                        return; // BLOCK deletion
                    }

                    console.log('‚úÖ NO INSTANCES - showing confirm');

                    // No instances - safe to delete
                    if (confirm(`Delete blueprint ${blueprint.name}?`)) {
                        console.log('‚úÖ CONFIRMED - deleting');
                        pushUndo();
                        state.blueprints = state.blueprints.filter(t => t.id !== blueprint.id);
                        save();
                        renderAll();
                    }
                };

                wrap.appendChild(deleteBtn);
            }

            wrapper.appendChild(wrap);
        }

        function renderInstanceEditor(wrapper) {
            const inst = findInstanceById(selected.id);
            if (!inst) {
                wrapper.innerHTML = '<div class="muted">Instance not found.</div>';
                return;
            }

            const card = renderInstanceBlueprint(inst, null, null, 'dynamic', new Set());
            wrapper.appendChild(card);
        }

        // ============================================================================
        // INSTANCE CARD RENDERING (HARDENED)
        // ============================================================================

        function renderInstanceBlueprint(inst, parentInst, parentField, origin, visited) {

            if (visited.has(inst.id)) {
                const card = document.createElement('div');
                card.className = 'instance-card';
                card.style.borderColor = 'var(--danger)';

                const content = document.createElement('div');
                content.style.padding = '10px';
                content.style.color = 'var(--danger)';
                content.style.display = 'flex';
                content.style.justifyContent = 'space-between';
                content.style.alignItems = 'center';

                const msg = document.createElement('span');
                msg.textContent = '‚ö†Ô∏è Circular reference';
                content.appendChild(msg);

                // Add delete button if we have parent context
                if (parentInst && parentField) {
                    const rmBtn = document.createElement('button');
                    rmBtn.className = 'btn small danger';
                    rmBtn.textContent = '√ó';
                    rmBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm('Remove this circular reference?')) {
                            pushUndo();

                            if (parentField.fieldKind === FIELD_KIND.INSTANTIATOR) {
                                parentInst.fieldValues[parentField.id] = null;
                            } else if (parentField.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                                const arr = parentInst.fieldValues[parentField.id];
                                if (Array.isArray(arr)) {
                                    parentInst.fieldValues[parentField.id] = arr.filter(id => id !== inst.id);
                                }
                            }

                            save();
                            renderAll();
                        }
                    };
                    content.appendChild(rmBtn);
                }

                card.appendChild(content);
                return card;
            }
            visited.add(inst.id);

            const blueprint = findBlueprintById(inst.templateId);
            if (!blueprint) {
                // Blueprint was deleted - render error state
                const errorBlueprint = document.createElement('div');
                errorBlueprint.className = 'instance-card';
                errorBlueprint.style.borderColor = 'var(--danger)';
                errorBlueprint.innerHTML = `
        <div class="card-header" style="color: var(--danger);">
            ‚ö†Ô∏è Blueprint Deleted
        </div>
        <div class="muted" style="padding: 12px;">
            Instance ${inst.id.slice(0, 8)} references deleted blueprint ${inst.templateId.slice(0, 8)}.
            This instance cannot be edited.
        </div>
    `;
                return errorBlueprint;
            }
            const templateDeleted = !blueprint;
            const templateData = blueprint || { name: '', type: '', fields: [] };

            const card = document.createElement('div');
            card.className = 'instance-card';
            if (origin === 'static') card.classList.add('static-child');
            if (origin === 'reference') {
                const isOrphaned = isInstanceOrphaned(inst.id);
                if (isOrphaned) {
                    card.classList.add('orphaned-reference-child');
                } else {
                    card.classList.add('reference-child');
                }
            }
            if (templateDeleted) card.classList.add('deleted-blueprint');

            if (editorCollapsed[inst.id] === undefined) {
                editorCollapsed[inst.id] = true;
            }
            const isCollapsed = editorCollapsed[inst.id];

            // Header
            const header = document.createElement('div');
            header.className = 'instance-header';

            const headerLeft = document.createElement('div');
            headerLeft.className = 'instance-header-left';
            headerLeft.onclick = (e) => {
                e.stopPropagation();
                editorCollapsed[inst.id] = !editorCollapsed[inst.id];
                renderEditor();
            };

            const twisty = document.createElement('span');
            twisty.textContent = isCollapsed ? '‚ñ∏' : '‚ñæ';
            twisty.style.cursor = 'pointer';
            headerLeft.appendChild(twisty);

            const nameSpan = document.createElement('span');
            nameSpan.className = 'card-name';

            if (templateDeleted) {
                // Gentler styling for deleted blueprints
                nameSpan.textContent = '(Blueprint Deleted)';
                nameSpan.style.fontStyle = 'italic';
                nameSpan.style.opacity = '0.6';

                headerLeft.appendChild(nameSpan);

                const idSpan = document.createElement('span');
                idSpan.className = 'muted';
                idSpan.style.fontSize = '0.85em';
                idSpan.textContent = ` ‚Ä¢ ${inst.templateId.slice(0, 8)}`;
                headerLeft.appendChild(idSpan);

                // Add explanatory hint
                const hintSpan = document.createElement('div');
                hintSpan.style.fontSize = '0.75em';
                hintSpan.style.opacity = '0.5';
                hintSpan.style.marginTop = '2px';
                hintSpan.textContent = 'Blueprint was deleted. Instance data preserved.';
                headerLeft.appendChild(hintSpan);
            } else {
                // Normal blueprint rendering
                nameSpan.textContent = templateData.name;
                headerLeft.appendChild(nameSpan);

                const typeSpan = document.createElement('span');
                typeSpan.className = 'muted';
                typeSpan.textContent = ' (' + templateData.type + ')';
                headerLeft.appendChild(typeSpan);
            }

            // Show reference icon for linked (not owned) instances
            if (origin === 'reference') {
                const refIcon = document.createElement('span');
                refIcon.className = 'reference-icon';
                refIcon.textContent = 'üîó';
                refIcon.title = 'Referenced instance (not owned by this parent)';
                headerLeft.appendChild(refIcon);
            }

            const headerActions = document.createElement('div');
            headerActions.className = 'instance-header-actions';

            const editBtn = document.createElement('button');
            editBtn.className = 'btn small';
            editBtn.textContent = 'Edit Blueprint';
            editBtn.onclick = (e) => {
                e.stopPropagation();
                navigateTo('blueprint', inst.templateId);
            };
            headerActions.appendChild(editBtn);

            // HARDENING: Only allow removal if not static and not root
            if (parentInst && parentField && origin !== 'static' && inst.id !== state.rootInstanceId) {
                const rmBtn = document.createElement('button');
                rmBtn.className = 'btn small danger';
                rmBtn.textContent = origin === 'reference' ? 'Unlink' : '√ó';
                rmBtn.onclick = (e) => {
                    e.stopPropagation();

                    // HARDENING: Check for references before deletion
                    let confirmMsg = origin === 'reference' ?
                        'Remove this reference? (Instance will not be deleted)' :
                        'Delete this instance? (Will cascade-delete owned children)';

                    if (origin !== 'reference') {
                        // Check if other instances reference this one
                        const referencingInstances = [];
                        for (const checkId in state.instances) {
                            const checkInst = state.instances[checkId];
                            const checkBlueprint = findBlueprintById(checkInst.templateId);
                            if (!checkBlueprint) continue;

                            for (const checkField of checkBlueprint.fields) {
                                if (isInstanceReferenceField(checkField)) {
                                    const val = checkInst.fieldValues[checkField.id];
                                    if (Array.isArray(val) && val.includes(inst.id)) {
                                        referencingInstances.push({
                                            instanceId: checkId,
                                            fieldName: checkField.name,
                                            fieldKind: checkField.fieldKind
                                        });
                                    }
                                }

                                const val = checkInst.fieldValues[checkField.id];
                                if (checkField.fieldKind === FIELD_KIND.INSTANTIATOR && val === inst.id) {
                                    referencingInstances.push({
                                        instanceId: checkId,
                                        fieldName: checkField.name,
                                        fieldKind: checkField.fieldKind
                                    });
                                } else if (checkField.fieldKind === FIELD_KIND.INSTANTIATOR_LIST && Array.isArray(val) && val.includes(inst.id)) {
                                    referencingInstances.push({
                                        instanceId: checkId,
                                        fieldName: checkField.name,
                                        fieldKind: checkField.fieldKind
                                    });
                                }
                            }
                        }

                        if (referencingInstances.length > 0) {
                            const refList = referencingInstances.slice(0, 5).map(ref =>
                                `  ‚Ä¢ Instance ${ref.instanceId.slice(0, 8)} (${ref.fieldName} field)`
                            ).join('\n');
                            const more = referencingInstances.length > 5 ?
                                `\n  ... and ${referencingInstances.length - 5} more` : '';

                            confirmMsg = `‚ö†Ô∏è WARNING: This instance is referenced by ${referencingInstances.length} other instance(s):\n\n${refList}${more}\n\nDeleting will leave broken references. Continue?`;
                        }
                    }

                    if (confirm(confirmMsg)) {
                        pushUndo();

                        if (origin === 'reference') {
                            // For references, just unlink (don't delete the instance)
                            if (parentField.fieldKind === FIELD_KIND.INSTANTIATOR) {
                                parentInst.fieldValues[parentField.id] = null;
                            } else if (parentField.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                                const arr = parentInst.fieldValues[parentField.id];
                                if (Array.isArray(arr)) {
                                    parentInst.fieldValues[parentField.id] = arr.filter(id => id !== inst.id);
                                }
                            }
                        } else {
                            // For owned instances, actually delete
                            deleteInstance(inst.id);
                        }

                        save();
                        renderAll();
                    }
                };
                headerActions.appendChild(rmBtn);
            }

            // GENERATE BLUEPRINT BUTTON (only for Blueprint Generator instances)
            if (blueprint && blueprint.isGenerator) {
                const genBtn = document.createElement('button');
                genBtn.textContent = '‚ö° Generate';
                genBtn.className = 'btn primary small';
                genBtn.title = 'Create a new blueprint from this template';
                genBtn.style.marginLeft = '4px';

                genBtn.onclick = () => {
                    generateBlueprintFromTemplate(inst.id);
                };

                headerActions.appendChild(genBtn);
            }

            header.appendChild(headerLeft);
            header.appendChild(headerActions);
            card.appendChild(header);

            // STATIC FEATURE: Reset all overrides button
            if (blueprint.isStatic) {
                // Count how many fields are overridden
                const overriddenFields = blueprint.fields.filter(f =>
                    f.fieldKind === FIELD_KIND.PRIMITIVE &&
                    blueprint.staticValues?.[f.id] !== undefined &&
                    inst.fieldValues[f.id] !== undefined
                );

                if (overriddenFields.length > 0) {
                    const resetAllContainer = document.createElement('div');
                    resetAllContainer.style.padding = '8px 12px';
                    resetAllContainer.style.background = 'rgba(59, 130, 246, 0.05)';
                    resetAllContainer.style.borderBottom = '1px solid var(--border)';
                    resetAllContainer.style.display = 'flex';
                    resetAllContainer.style.alignItems = 'center';
                    resetAllContainer.style.gap = '8px';

                    const resetInfo = document.createElement('div');
                    resetInfo.className = 'muted';
                    resetInfo.style.fontSize = '11px';
                    resetInfo.style.flex = '1';
                    resetInfo.textContent = `${overriddenFields.length} field(s) customized`;

                    const resetAllBtn = document.createElement('button');
                    resetAllBtn.className = 'btn small';
                    resetAllBtn.textContent = '‚éå Reset All to Defaults';
                    resetAllBtn.title = `Revert ${overriddenFields.length} field(s) to blueprint defaults`;
                    resetAllBtn.onclick = () => {
                        const fieldNames = overriddenFields.map(f => f.name).join(', ');
                        if (confirm(
                            `Reset ${overriddenFields.length} field(s) to blueprint defaults?\n\n` +
                            `Fields: ${fieldNames}\n\n` +
                            `This can be undone.`
                        )) {
                            pushUndo();
                            for (const field of overriddenFields) {
                                delete inst.fieldValues[field.id];
                            }
                            save();
                            renderAll();
                        }
                    };

                    resetAllContainer.appendChild(resetInfo);
                    resetAllContainer.appendChild(resetAllBtn);
                    card.appendChild(resetAllContainer);
                }
            }

            // Body
            const body = document.createElement('div');
            body.className = 'instance-body' + (isCollapsed ? ' collapsed' : '');

            for (const f of templateData.fields) {
                const row = document.createElement('div');
                row.className = 'field-line';

                const label = document.createElement('div');
                label.className = 'field-key';
                label.style.display = 'flex';
                label.style.alignItems = 'center';
                label.style.gap = '6px';
                label.style.marginBottom = '4px';
                label.style.fontSize = '13px';

                // Determine if this field is using the blueprint default
                const isUsingBlueprintDefault = blueprint.isStatic && blueprint.staticValues?.[f.id] !== undefined
                    && inst.fieldValues[f.id] === undefined;

                // Only show lock if using blueprint default
                if (isUsingBlueprintDefault) {
                    const lockIcon = document.createElement('span');
                    lockIcon.textContent = 'üîí';
                    lockIcon.style.fontSize = '11px';
                    lockIcon.style.color = 'var(--muted)';
                    label.appendChild(lockIcon);
                }

                // Field name
                const fieldNameSpan = document.createElement('span');
                fieldNameSpan.textContent = f.name;
                label.appendChild(fieldNameSpan);

                //label.textContent = f.name;

                const control = document.createElement('div');
                control.style.flex = '1';
                control.style.minWidth = '0';
                control.style.display = 'flex';
                control.style.flexDirection = 'column';

                // Render field based on kind
                if (f.fieldKind === FIELD_KIND.PRIMITIVE) {
                    const isStaticBlueprint = blueprint.isStatic && blueprint.staticValues?.[f.id] !== undefined;
                    const isOverridden = inst.fieldValues[f.id] !== undefined;

                    if (isStaticBlueprint && !isOverridden) {
                        // STATE: Using blueprint default (not overridden)
                        const defaultValue = blueprint.staticValues[f.id];

                        const defaultDisplay = document.createElement('div');
                        defaultDisplay.style.display = 'flex';
                        defaultDisplay.style.alignItems = 'center';
                        defaultDisplay.style.gap = '8px';
                        defaultDisplay.style.marginBottom = '8px';
                        defaultDisplay.style.marginTop = '0'

                        const valueText = document.createElement('div');
                        valueText.className = 'muted';
                        valueText.style.flex = '1';

                        if (hasMarkdownSyntax(String(defaultValue))) {
                            valueText.innerHTML = renderMarkdown(String(defaultValue));
                        } else {
                            valueText.textContent = String(defaultValue);
                        }

                        const overrideBtn = document.createElement('button');
                        overrideBtn.className = 'btn small';
                        overrideBtn.textContent = 'Override';
                        overrideBtn.title = 'Customize this value for this instance';
                        overrideBtn.onclick = () => {
                            pushUndo();
                            // Copy blueprint default to instance (makes it editable)
                            inst.fieldValues[f.id] = defaultValue;
                            save();
                            renderAll();
                        };

                        defaultDisplay.appendChild(valueText);
                        defaultDisplay.appendChild(overrideBtn);
                        control.appendChild(defaultDisplay);

                        // Edit defaults button directly under field name
                        if (isStaticBlueprint) {
                            const editBtn = document.createElement('button');
                            editBtn.className = 'btn small';
                            editBtn.style.fontSize = '10px';
                            editBtn.style.padding = '2px 6px';
                            editBtn.style.marginTop = '2px';
                            editBtn.style.marginBottom = '4px';
                            editBtn.textContent = 'üîó Edit defaults';
                            editBtn.title = 'Go to blueprint editor to change default values';
                            editBtn.onclick = (e) => {
                                e.stopPropagation();
                                navigateTo('blueprint', blueprint.id);
                            };
                            control.appendChild(editBtn);  // Insert after label
                        }



                    } else {
                        // STATE: Normal input (no blueprint default, or overridden)

                        // Get value from instance or use default
                        let currentValue;
                        if (isOverridden) {
                            currentValue = inst.fieldValues[f.id];
                        } else {
                            currentValue = f.primitiveType === PRIMITIVE_TYPE.NUMBER ? 0 : '';
                        }

                        // Create unique key for tracking expansion state
                        const fieldKey = `${inst.id}-${f.id}`;
                        const isExpanded = expandedTextFields[fieldKey] || false;

                        // Check if this is text with markdown
                        const isTextWithMarkdown = f.primitiveType === PRIMITIVE_TYPE.TEXT && hasMarkdownSyntax(currentValue);


                        if (f.primitiveType === PRIMITIVE_TYPE.TEXT) {
                            const textContainer = document.createElement('div');
                            const fieldKey = `${inst.id}-${f.id}`;

                            // Track edit mode state
                            if (window.textFieldEditMode === undefined) {
                                window.textFieldEditMode = {};
                            }
                            const isEditMode = window.textFieldEditMode[fieldKey] !== false;  // Default to edit

                            // Get current value - ensure never undefined
                            let currentValue = inst.fieldValues[f.id];
                            if (currentValue === undefined || currentValue === null) {
                                currentValue = '';
                            }

                            // Check if we have markdown
                            const hasMarkdown = hasMarkdownSyntax(currentValue);
                            const isEmpty = !currentValue || currentValue.trim() === '';

                            // Show preview only if: has markdown AND not in edit mode AND not empty
                            const showPreview = hasMarkdown && !isEditMode && !isEmpty;

                            // Create resize container (ALWAYS)
                            const resizeContainer = document.createElement('div');
                            resizeContainer.className = 'resize-container';
                            resizeContainer.style.position = 'relative';

                            // Get stored height or default to 200
                            let currentHeight = textFieldHeights[fieldKey] || 70;
                            let currentWidth = textFieldWidths[fieldKey] || null;
                            let isResizing = false;

                            if (showPreview) {
                                // ========== PREVIEW MODE ==========
                                const previewDiv = document.createElement('div');
                                previewDiv.className = 'markdown-preview';
                                previewDiv.innerHTML = renderMarkdown(currentValue);
                                previewDiv.style.height = currentHeight + 'px';
                                previewDiv.style.overflowY = 'auto';
                                previewDiv.style.cursor = 'default';
                                if (currentWidth) {
                                    previewDiv.style.width = currentWidth + 'px';
                                }

                                resizeContainer.appendChild(previewDiv);

                            } else {
                                // ========== EDITOR MODE ==========
                                const textarea = document.createElement('textarea');
                                textarea.value = currentValue;
                                textarea.placeholder = 'Type here... (Markdown: **bold** _italic_ [link](url))';
                                textarea.style.height = currentHeight + 'px';
                                if (currentWidth) {
                                    textarea.style.width = currentWidth + 'px';
                                }

                                textarea.onfocus = () => pushUndo();

                                textarea.oninput = () => {
                                    inst.fieldValues[f.id] = textarea.value;
                                    debouncedSave();
                                };

                                textarea.onblur = () => {
                                    clearTimeout(saveTimeout);
                                    save();
                                };

                                resizeContainer.appendChild(textarea);
                            }

                            // ========== RESIZE HANDLES (ALWAYS ADDED) ==========

                            // TOP HANDLE
                            const topHandle = document.createElement('div');
                            topHandle.className = 'resize-handle top';
                            topHandle.style.width = '100%';
                            topHandle.style.height = '8px';
                            topHandle.style.position = 'absolute';
                            topHandle.style.top = '0';
                            topHandle.style.left = '0';

                            topHandle.onmousedown = (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                isResizing = true;

                                const startY = e.clientY;
                                const startHeight = currentHeight;
                                document.body.style.cursor = 'ns-resize';

                                const onMouseMove = (e) => {
                                    if (!isResizing) return;
                                    const deltaY = e.clientY - startY;
                                    const newHeight = startHeight - deltaY;  // No clamping during drag

                                    // Only enforce limits, don't clamp
                                    if (newHeight < 100) return;
                                    if (newHeight > window.innerHeight * 0.8) return;

                                    currentHeight = newHeight;
                                    const content = resizeContainer.firstChild;
                                    content.style.height = newHeight + 'px';
                                };

                                const onMouseUp = () => {
                                    isResizing = false;
                                    document.body.style.cursor = '';
                                    textFieldHeights[fieldKey] = currentHeight;  // Save height
                                    document.removeEventListener('mousemove', onMouseMove);
                                    document.removeEventListener('mouseup', onMouseUp);
                                };

                                document.addEventListener('mousemove', onMouseMove);
                                document.addEventListener('mouseup', onMouseUp);
                            };

                            resizeContainer.appendChild(topHandle);

                            // BOTTOM HANDLE
                            const bottomHandle = document.createElement('div');
                            bottomHandle.className = 'resize-handle bottom';
                            bottomHandle.style.width = '100%';
                            bottomHandle.style.height = '8px';
                            bottomHandle.style.position = 'absolute';
                            bottomHandle.style.bottom = '0';
                            bottomHandle.style.left = '0';

                            bottomHandle.onmousedown = (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                isResizing = true;

                                const startY = e.clientY;
                                const startHeight = currentHeight;
                                document.body.style.cursor = 'ns-resize';

                                const onMouseMove = (e) => {
                                    if (!isResizing) return;
                                    const deltaY = e.clientY - startY;
                                    const newHeight = startHeight + deltaY;  // No clamping during drag

                                    // Only enforce limits, don't clamp
                                    if (newHeight < 100) return;
                                    if (newHeight > window.innerHeight * 0.8) return;

                                    currentHeight = newHeight;
                                    const content = resizeContainer.firstChild;
                                    content.style.height = newHeight + 'px';
                                };

                                const onMouseUp = () => {
                                    isResizing = false;
                                    document.body.style.cursor = '';
                                    textFieldHeights[fieldKey] = currentHeight;  // Save height
                                    document.removeEventListener('mousemove', onMouseMove);
                                    document.removeEventListener('mouseup', onMouseUp);
                                };

                                document.addEventListener('mousemove', onMouseMove);
                                document.addEventListener('mouseup', onMouseUp);
                            };

                            resizeContainer.appendChild(bottomHandle);

                            // RIGHT HANDLE
                            const rightHandle = document.createElement('div');
                            rightHandle.className = 'resize-handle right';

                            // FORCE dimensions via JavaScript (overrides any inherited issues)
                            rightHandle.style.width = '8px';
                            rightHandle.style.minWidth = '8px';
                            rightHandle.style.maxWidth = '8px';
                            rightHandle.style.height = '100%';
                            rightHandle.style.position = 'absolute';
                            rightHandle.style.top = '50%';
                            rightHandle.style.transform = 'translateY(-50%)';
                            rightHandle.style.right = '0px';

                            rightHandle.onmousedown = (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                isResizing = true;

                                const startX = e.clientX;
                                const startWidth = currentWidth || resizeContainer.offsetWidth;

                                // Get center panel's actual current width
                                const centerPane = document.querySelector('.pane.center');
                                const panelWidth = centerPane ? centerPane.offsetWidth : 360;
                                const minFieldWidth = Math.max(200, panelWidth - 200); // Panel width minus padding/margins

                                document.body.style.cursor = 'ew-resize';

                                const onMouseMove = (e) => {
                                    if (!isResizing) return;
                                    const deltaX = e.clientX - startX;

                                    const newWidth = Math.max(minFieldWidth, startWidth + deltaX);
                                    currentWidth = newWidth;

                                    const content = resizeContainer.firstChild;
                                    content.style.width = newWidth + 'px';
                                    resizeContainer.style.width = newWidth + 'px';
                                };

                                const onMouseUp = () => {
                                    isResizing = false;
                                    document.body.style.cursor = '';
                                    textFieldWidths[fieldKey] = currentWidth;  // Save width
                                    document.removeEventListener('mousemove', onMouseMove);
                                    document.removeEventListener('mouseup', onMouseUp);
                                };

                                document.addEventListener('mousemove', onMouseMove);
                                document.addEventListener('mouseup', onMouseUp);
                            };

                            resizeContainer.appendChild(rightHandle);

                            // CORNER HANDLE
                            const cornerHandle = document.createElement('div');
                            cornerHandle.className = 'resize-handle corner bottom-right';
                            cornerHandle.style.width = '8px';
                            cornerHandle.style.height = '8px';
                            cornerHandle.style.position = 'absolute';
                            cornerHandle.style.bottom = '0';
                            cornerHandle.style.right = '0';

                            cornerHandle.onmousedown = (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                isResizing = true;

                                const startX = e.clientX;
                                const startY = e.clientY;
                                const startWidth = currentWidth || resizeContainer.offsetWidth;
                                const startHeight = currentHeight;

                                // Get center panel's actual current width
                                const centerPane = document.querySelector('.pane.center');
                                const panelWidth = centerPane ? centerPane.offsetWidth : 360;
                                const minFieldWidth = Math.max(200, panelWidth - 200);

                                document.body.style.cursor = 'se-resize';

                                const onMouseMove = (e) => {
                                    if (!isResizing) return;
                                    const deltaX = e.clientX - startX;
                                    const deltaY = e.clientY - startY;

                                    const newHeight = Math.max(60, Math.min(window.innerHeight * 0.8, startHeight + deltaY));
                                    const newWidth = Math.max(minFieldWidth, startWidth + deltaX);

                                    currentHeight = newHeight;
                                    currentWidth = newWidth;

                                    const content = resizeContainer.firstChild;
                                    content.style.height = newHeight + 'px';
                                    content.style.width = newWidth + 'px';
                                    resizeContainer.style.width = newWidth + 'px';
                                };

                                const onMouseUp = () => {
                                    isResizing = false;
                                    document.body.style.cursor = '';
                                    textFieldHeights[fieldKey] = currentHeight;  // Save height
                                    textFieldWidths[fieldKey] = currentWidth;    // Save width
                                    document.removeEventListener('mousemove', onMouseMove);
                                    document.removeEventListener('mouseup', onMouseUp);
                                };

                                document.addEventListener('mousemove', onMouseMove);
                                document.addEventListener('mouseup', onMouseUp);
                            };

                            resizeContainer.appendChild(cornerHandle);

                            // Add to page
                            textContainer.appendChild(resizeContainer);

                            // ========== TOGGLE BUTTON ==========

                            const toggleBtn = document.createElement('button');
                            toggleBtn.className = 'field-toggle-btn';
                            toggleBtn.style.cssText = 'margin-bottom: 4px; padding: 2px 6px; font-size: 11px; opacity: 0.6;';

                            if (showPreview) {
                                toggleBtn.innerHTML = '‚úèÔ∏è Edit ‚Üì';
                                toggleBtn.title = 'Switch to editor';
                            } else {
                                toggleBtn.innerHTML = 'üìÑ Preview ‚Üì';
                                toggleBtn.title = 'Show formatted preview';
                                // Show toggle even for empty/non-markdown fields
                                // User might want to preview as they type
                            }

                            toggleBtn.onclick = () => {
                                window.textFieldEditMode[fieldKey] = !isEditMode;
                                save();
                                renderAll();
                            };

                            // Insert at the START of control (before textContainer)
                            control.insertBefore(toggleBtn, control.firstChild);

                            control.appendChild(textContainer);
                        } else {
                            // NUMBER INPUT MODE
                            const inp = document.createElement('input');
                            inp.type = 'number';
                            inp.value = currentValue;

                            inp.onfocus = () => pushUndo();
                            inp.oninput = () => {
                                inst.fieldValues[f.id] = inp.value === '' ? 0 : Number(inp.value);
                                debouncedSave();
                            };
                            inp.onblur = () => {
                                clearTimeout(saveTimeout);
                                save();
                            };

                            control.appendChild(inp);
                        }
                        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                        // POST-STATE: Overridden indicator + revert
                        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
                        if (isStaticBlueprint && isOverridden) {

                            const overrideIndicator = document.createElement('div');
                            overrideIndicator.className = 'override-indicator';

                            const badge = document.createElement('span');
                            badge.className = 'override-badge';
                            badge.textContent = '‚úèÔ∏è Overridden';

                            const originalText = document.createElement('span');
                            originalText.className = 'override-original';
                            originalText.textContent =
                                `Blueprint default: ${blueprint.staticValues[f.id]}`;

                            const revertBtn = document.createElement('button');
                            revertBtn.className = 'btn small';
                            revertBtn.textContent = '‚éå Revert';
                            revertBtn.title = 'Restore blueprint default';
                            revertBtn.onclick = () => {
                                const currentValue = inst.fieldValues[f.id];
                                const defaultValue = blueprint.staticValues[f.id];

                                if (confirm(
                                    `Replace "${currentValue}" with blueprint default "${defaultValue}"?`
                                )) {
                                    pushUndo();
                                    delete inst.fieldValues[f.id];
                                    save();
                                    renderAll();
                                }
                            };

                            overrideIndicator.appendChild(badge);
                            overrideIndicator.appendChild(originalText);
                            overrideIndicator.appendChild(revertBtn);
                            control.appendChild(overrideIndicator);
                        }
                    }

                } else if (f.fieldKind === FIELD_KIND.INSTANCE_REFERENCE) {
                    if (false /*isFieldStatic(blueprint, f)*/) {
                        const txt = document.createElement('div');
                        txt.textContent = '(static instanceReference)';
                        txt.className = 'muted';
                        control.appendChild(txt);
                    } else {
                        const ids = inst.fieldValues?.[f.id] || [];

                        // Render existing chips with expandable containers
                        const chipsOuterContainer = document.createElement('div');
                        chipsOuterContainer.style.marginBottom = '6px';

                        for (let refId of ids) {
                            // HARDENING: Ensure refId is a string (extract ID from object if needed)
                            if (typeof refId === 'object' && refId !== null && refId.id) {
                                refId = refId.id; // Extract ID from instance object
                            }
                            if (typeof refId !== 'string') {
                                console.error('Invalid refId in INSTANCE_REFERENCE_LIST:', refId);
                                continue; // Skip invalid entries
                            }

                            // Container for chip + expanded view
                            const chipContainer = document.createElement('div');
                            chipContainer.className = 'chip-container';

                            const chip = document.createElement('div');
                            chip.className = 'entityref-chip';
                            chip.style.display = 'flex';
                            chip.style.alignItems = 'center';

                            const refStatus = getReferenceStatus(refId, parentInst, f);
                            if (refStatus.cssClass) chip.classList.add(refStatus.cssClass);

                            const twisty = createReferenceTwisty(refId, refStatus, inst, f);
                            chip.appendChild(twisty);

                            const chipContent = document.createElement('span');
                            const chipLabel = getInstanceLabel(refId);
                            chipContent.textContent = chipLabel + refStatus.labelSuffix;

                            const target = findInstanceById(refId);
                            const targetBlueprint = target ? findBlueprintById(target.templateId) : null;
                            const isExpanded = isChipExpanded(inst.id, f.id, refId);
                            chipContent.style.cursor = target ? 'pointer' : 'default';
                            chipContent.style.flex = '1';

                            // Click navigation (same as INSTANCE_REFERENCE)
                            if (target) {
                                chipContent.onclick = (e) => {
                                    e.stopPropagation();
                                    handleEntityRefNavigate(refId);
                                };
                                chipContent.onmouseenter = () => {
                                    chipContent.style.textDecoration = 'underline';
                                };
                                chipContent.onmouseleave = () => {
                                    chipContent.style.textDecoration = 'none';
                                };
                            }

                            chip.appendChild(chipContent);

                            // Type indicator (subtle)
                            if (target && targetBlueprint) {
                                const typeSpan = document.createElement('span');
                                typeSpan.className = 'muted';
                                typeSpan.textContent = ` ¬∑ ${targetBlueprint.name}`;
                                typeSpan.style.fontSize = '11px';
                                typeSpan.style.marginRight = '4px';
                                chip.appendChild(typeSpan);
                            }

                            // Create remove button
                            const removeBtn = document.createElement('span');
                            removeBtn.className = 'remove';
                            removeBtn.textContent = '√ó';
                            removeBtn.onclick = (e) => {
                                e.stopPropagation();

                                // Remove only this reference from the list
                                pushUndo();
                                const newIds = ids.filter(id => id !== refId);
                                inst.fieldValues[f.id] = newIds;

                                // Also remove from expanded chips set
                                expandedChips.delete(getChipKey(inst.id, f.id, refId));

                                save();
                                renderAll();
                            };

                            chip.appendChild(removeBtn);

                            chip.title = target ?
                                `${chipLabel} ¬∑ ${targetBlueprint.name}\nClick label to navigate | Click ‚ñ∏ to expand` :
                                `‚ö†Ô∏è Broken reference to ${refId.slice(0, 8)}`;

                            chipContainer.appendChild(chip);

                            // EXPANDED VIEW: Show instance fields
                            if (isExpanded && target && targetBlueprint) {
                                const expandedView = renderChipExpandedView(target, targetBlueprint, refId);
                                chipContainer.appendChild(expandedView);
                            }

                            chipsOuterContainer.appendChild(chipContainer);
                        }

                        control.appendChild(chipsOuterContainer);

                        if (ids.length === 0) {
                            // Add reference button
                            const addBtn = document.createElement('button');

                            const hasNoFilter = !f.blueprintTypeFilter || f.blueprintTypeFilter === null || f.blueprintTypeFilter === '';

                            if (hasNoFilter) {
                                addBtn.className = 'btn small';
                                addBtn.textContent = '‚ö†Ô∏è No Type Filter - Set a filter from source blueprint';
                                addBtn.disabled = true;
                                addBtn.style.cssText = 'border: 1px solid var(--warning) !important; background: rgba(251, 191, 36, 0.08) !important; color: var(--warning) !important; cursor: not-allowed !important;';
                                addBtn.title = 'Blueprint field has no type filter - edit blueprint to fix';
                            } else {
                                addBtn.className = 'btn small primary';
                                addBtn.textContent = 'üîó Add Reference';
                                addBtn.onclick = () => {
                                    // HARDENING: Pass current instance to exclude self and descendants
                                    showInstancePicker(f.allowedTemplateIds, (selectedId) => {
                                        pushUndo();
                                        if (!ids.includes(selectedId)) {
                                            ids.push(selectedId);
                                            inst.fieldValues[f.id] = ids;
                                        }
                                        save();
                                        renderAll();
                                    }, inst.id);
                                };
                            }

                            control.appendChild(addBtn);
                        }
                    }
                } else if (f.fieldKind === FIELD_KIND.INSTANCE_REFERENCE_LIST) {
                    // INSTANCE_REFERENCE_LIST: Ordered list of entity references (reuses INSTANCE_REFERENCE chip semantics)
                    if (false /*isFieldStatic(blueprint, f)*/) {
                        const txt = document.createElement('div');
                        txt.textContent = '(static instanceReferenceList)';
                        txt.className = 'muted';
                        control.appendChild(txt);
                    } else {
                        let ids = inst.fieldValues?.[f.id] || [];

                        // HARDENING: Ensure ids is always an array of strings (not objects)
                        if (Array.isArray(ids)) {
                            ids = ids.map(item => {
                                if (typeof item === 'object' && item !== null && item.id) {
                                    return item.id; // Extract ID from object
                                }
                                return item; // Already a string
                            }).filter(id => typeof id === 'string');

                            // Fix the corruption in the instance permanently
                            if (JSON.stringify(ids) !== JSON.stringify(inst.fieldValues[f.id])) {
                                inst.fieldValues[f.id] = ids;
                                save();
                            }
                        }

                        // Render existing chips with expandable containers (VERTICAL)
                        const chipsOuterContainer = document.createElement('div');
                        chipsOuterContainer.style.marginBottom = '6px';

                        for (const refId of ids) {
                            // Container for chip + expanded view
                            const chipContainer = document.createElement('div');
                            chipContainer.className = 'chip-container';

                            const chip = document.createElement('div');
                            chip.className = 'entityref-chip';
                            chip.style.display = 'flex';
                            chip.style.alignItems = 'center';

                            const chipIndex = ids.indexOf(refId);

                            const refStatus = getReferenceStatus(refId, parentInst, f);
                            if (refStatus.cssClass) chip.classList.add(refStatus.cssClass);

                            const twisty = createReferenceTwisty(refId, refStatus, inst, f);
                            chip.appendChild(twisty);

                            const chipContent = document.createElement('span');
                            const chipLabel = getInstanceLabel(refId);
                            chipContent.textContent = `${chipIndex + 1}. ${chipLabel}${refStatus.labelSuffix}`;

                            const target = findInstanceById(refId);
                            const targetBlueprint = target ? findBlueprintById(target.templateId) : null;
                            const isExpanded = isChipExpanded(inst.id, f.id, refId);
                            chipContent.style.cursor = target ? 'pointer' : 'default';
                            chipContent.style.flex = '1';

                            // Navigate on click (only on label, not twisty)
                            if (target) {
                                chipContent.onclick = (e) => {
                                    e.stopPropagation();
                                    handleEntityRefNavigate(refId);
                                };
                                chipContent.onmouseenter = () => {
                                    chipContent.style.textDecoration = 'underline';
                                };
                                chipContent.onmouseleave = () => {
                                    chipContent.style.textDecoration = 'none';
                                };
                            }

                            chip.appendChild(chipContent);

                            // Type indicator (subtle)
                            if (target && targetBlueprint) {
                                const typeSpan = document.createElement('span');
                                typeSpan.className = 'muted';
                                typeSpan.textContent = ` ¬∑ ${targetBlueprint.name}`;
                                typeSpan.style.fontSize = '11px';
                                typeSpan.style.marginRight = '4px';
                                chip.appendChild(typeSpan);
                            }

                            // Create remove button
                            const removeBtn = document.createElement('span');
                            removeBtn.className = 'remove';
                            removeBtn.textContent = '√ó';
                            removeBtn.onclick = (e) => {
                                e.stopPropagation();
                                // HARDENING: instanceReference removal only affects pointer, never deletes target
                                pushUndo();
                                inst.fieldValues[f.id] = ids.filter(id => id !== refId);

                                // Also remove from expanded chips set
                                expandedChips.delete(getChipKey(inst.id, f.id, refId));

                                save();
                                renderAll();
                            };

                            chip.appendChild(removeBtn);

                            chip.title = target ?
                                `${chipIndex + 1}. ${chipLabel} ¬∑ ${targetBlueprint.name}\nDrag ‚ãÆ‚ãÆ to reorder | Click label to navigate | Click ‚ñ∏ to expand` :
                                `‚ö†Ô∏è Broken reference to ${refId.slice(0, 8)}`;

                            chipContainer.appendChild(chip);

                            // EXPANDED VIEW: Show instance fields
                            if (isExpanded && target && targetBlueprint) {
                                const expandedView = renderChipExpandedView(target, targetBlueprint, refId);
                                chipContainer.appendChild(expandedView);
                            }

                            chipsOuterContainer.appendChild(chipContainer);
                        }

                        control.appendChild(chipsOuterContainer);

                        const hasTypeSelected =
                            Array.isArray(f.blueprintTypeFilter) &&
                            f.blueprintTypeFilter.length > 0;

                        // Add reference button (with duplicate prevention)
                        // Add reference button (with duplicate prevention)
                        const addBtn = document.createElement('button');

                        const hasNoFilter = !f.blueprintTypeFilter || f.blueprintTypeFilter === null || f.blueprintTypeFilter === '';

                        if (hasNoFilter) {
                            addBtn.className = 'btn small';
                            addBtn.textContent = '‚ö†Ô∏è No Type Filter - Set a filter from source blueprint';
                            addBtn.disabled = true;
                            addBtn.style.cssText = 'border: 1px solid var(--warning) !important; background: rgba(251, 191, 36, 0.08) !important; color: var(--warning) !important; cursor: not-allowed !important;';
                            addBtn.title = 'Blueprint field has no type filter - edit blueprint to fix';
                        } else {
                            addBtn.className = 'btn small primary';
                            addBtn.textContent = 'üîó Add Reference';
                            addBtn.onclick = () => {
                                showInstancePicker(f.blueprintTypeFilter, (selectedId) => {
                                    if (!ids.includes(selectedId)) {
                                        pushUndo();
                                        ids.push(selectedId);
                                        inst.fieldValues[f.id] = ids;
                                        save();
                                        renderAll();
                                    } else {
                                        alert('This reference already exists in the list.');
                                    }
                                }, inst.id);
                            };
                        }

                        control.appendChild(addBtn);
                    }
                } else if (f.fieldKind === FIELD_KIND.INSTANTIATOR || f.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                    // Check for broken/orphaned references BEFORE rendering children
                    const val = inst.fieldValues[f.id];
                    const brokenRefs = [];
                    const orphanedRefs = [];

                    if (f.fieldKind === FIELD_KIND.INSTANTIATOR) {
                        if (val) {
                            const target = findInstanceById(val);
                            if (!target) {
                                brokenRefs.push(val);
                            } else if (isInstanceOrphaned(val)) {
                                orphanedRefs.push(val);
                            }
                        }
                    } else if (f.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                        if (Array.isArray(val)) {
                            for (const id of val) {
                                const target = findInstanceById(id);
                                if (!target) {
                                    brokenRefs.push(id);
                                } else if (isInstanceOrphaned(id)) {
                                    orphanedRefs.push(id);
                                }
                            }
                        }
                    }

                    // Show broken reference indicators
                    for (const brokenId of brokenRefs) {
                        const brokenCard = document.createElement('div');
                        brokenCard.className = 'instance-card';
                        brokenCard.style.borderColor = 'var(--danger)';
                        brokenCard.style.background = 'rgba(255, 107, 107, 0.08)';
                        brokenCard.style.padding = '10px';
                        brokenCard.style.display = 'flex';
                        brokenCard.style.alignItems = 'center';
                        brokenCard.style.justifyContent = 'space-between';

                        const brokenMsg = document.createElement('span');
                        brokenMsg.style.color = 'var(--danger)';
                        brokenMsg.textContent = `üî¥ Instance ${brokenId.slice(0, 8)} (deleted)`;
                        brokenCard.appendChild(brokenMsg);

                        // Clear button
                        const clearBtn = document.createElement('button');
                        clearBtn.className = 'btn small danger';
                        clearBtn.textContent = '√ó';
                        clearBtn.title = 'Clear broken reference';
                        clearBtn.onclick = () => {
                            pushUndo();
                            if (f.fieldKind === FIELD_KIND.INSTANTIATOR) {
                                inst.fieldValues[f.id] = null;
                            } else if (f.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                                inst.fieldValues[f.id] = inst.fieldValues[f.id].filter(id => id !== brokenId);
                            }
                            save();
                            renderAll();
                        };
                        brokenCard.appendChild(clearBtn);

                        control.appendChild(brokenCard);
                    }

                    // Show orphaned reference indicators (YELLOW)
                    for (const orphanedId of orphanedRefs) {
                        const orphanCard = document.createElement('div');
                        orphanCard.className = 'instance-card';
                        orphanCard.style.borderColor = 'var(--warning)';
                        orphanCard.style.background = 'rgba(251, 191, 36, 0.08)';
                        orphanCard.style.padding = '10px';
                        orphanCard.style.display = 'flex';
                        orphanCard.style.alignItems = 'center';
                        orphanCard.style.justifyContent = 'space-between';

                        const orphanMsg = document.createElement('span');
                        orphanMsg.style.color = 'var(--warning)';
                        orphanMsg.textContent = `‚ö†Ô∏è Instance ${orphanedId.slice(0, 8)} (orphaned)`;
                        orphanCard.appendChild(orphanMsg);

                        // Clear button
                        const clearBtn = document.createElement('button');
                        clearBtn.className = 'btn small';
                        clearBtn.textContent = '√ó';
                        clearBtn.title = 'Clear orphaned reference';
                        clearBtn.onclick = () => {
                            pushUndo();
                            if (f.fieldKind === FIELD_KIND.INSTANTIATOR) {
                                inst.fieldValues[f.id] = null;
                            } else if (f.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                                inst.fieldValues[f.id] = inst.fieldValues[f.id].filter(id => id !== orphanedId);
                            }
                            save();
                            renderAll();
                        };
                        orphanCard.appendChild(clearBtn);

                        control.appendChild(orphanCard);
                    }

                    const merged = getMergedChildrenWithProvenance(blueprint, inst, f.id)
                        .filter(item => !isInstanceOrphaned(item.child.id));

                    for (const item of merged) {
                        // HARDENING: Skip static shapes in runtime rendering
                        if (isStaticInstanceShape(item.child)) {
                            const ghost = document.createElement('div');
                            ghost.className = 'instance-card static-ghost';
                            ghost.textContent = 'üëª Static blueprint default';
                            ghost.title = 'Static children are defined in blueprint, not runtime';
                            control.appendChild(ghost);
                            continue;
                        }

                        // Check if child's blueprint exists
                        const childBp = findBlueprintById(item.child.templateId);
                        if (!childBp) {
                            // Blueprint deleted - show error card with clear button
                            const errorCard = document.createElement('div');
                            errorCard.className = 'instance-card';
                            errorCard.style.borderColor = 'var(--danger)';
                            errorCard.style.background = 'rgba(255, 107, 107, 0.08)';
                            errorCard.style.padding = '10px';
                            errorCard.style.display = 'flex';
                            errorCard.style.alignItems = 'center';
                            errorCard.style.justifyContent = 'space-between';

                            const errorMsg = document.createElement('span');
                            errorMsg.style.color = 'var(--danger)';
                            errorMsg.textContent = `üî¥ Instance ${item.child.id.slice(0, 8)} (blueprint deleted)`;
                            errorCard.appendChild(errorMsg);

                            // Clear button
                            const clearBtn = document.createElement('button');
                            clearBtn.className = 'btn small danger';
                            clearBtn.textContent = '√ó Remove';
                            clearBtn.title = 'Remove instance with deleted blueprint';
                            clearBtn.onclick = () => {
                                if (confirm(`Delete instance ${item.child.id.slice(0, 8)}?\n\nThis instance's blueprint no longer exists.`)) {
                                    pushUndo();
                                    deleteInstance(item.child.id);
                                    save();
                                    renderAll();
                                }
                            };
                            errorCard.appendChild(clearBtn);

                            control.appendChild(errorCard);
                            continue;
                        }

                        // CRITICAL: Only track visited for OWNED children (origin = 'dynamic')
                        // Referenced children should not contribute to cycle detection
                        const childVisited = item.origin === 'dynamic' ? visited : new Set();

                        const childBlueprint = renderInstanceBlueprint(
                            item.child, inst, f, item.origin, childVisited
                        );
                        control.appendChild(childBlueprint);
                    }

                    //if (!isFieldStatic(blueprint, f)) {
                    const btnRow = document.createElement('div');
                    btnRow.style.display = 'flex';
                    btnRow.style.gap = '6px';

                    if ((f.fieldKind === FIELD_KIND.INSTANTIATOR || f.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) && merged.length === 0) {
                        const moveBtn = document.createElement('button');
                        moveBtn.className = 'btn small primary';
                        moveBtn.textContent = '‚Ü™Ô∏è Move Instance Here';
                        moveBtn.title = 'Move an orphan or instance here';
                        moveBtn.onclick = () => {
                            showInstancePicker(f.blueprintTypeFilter, (selectedId) => {
                                pushUndo();
                                const result = moveInstance(selectedId, inst.id, f.id);
                                if (!result.success) {
                                    alert('Move failed: ' + result.error);
                                } else {
                                    console.log(`Moved instance ${selectedId.slice(0, 8)} to ${inst.id.slice(0, 8)}.${f.name}`);
                                }
                                save();
                                renderAll();
                            }, inst.id, false);  // showOnlyOrphans = true
                        };
                        btnRow.appendChild(moveBtn);
                        if (f.fieldKind === FIELD_KIND.INSTANTIATOR) {
                            const linkBtn = document.createElement('button');
                            linkBtn.className = 'btn small primary';
                            linkBtn.textContent = 'üîó Link Instance';
                            linkBtn.onclick = () => {
                                // HARDENING: Exclude self and descendants
                                showInstancePicker(f.blueprintTypeFilter, (selectedId) => {
                                    pushUndo();
                                    inst.fieldValues[f.id] = selectedId;
                                    save();
                                    renderAll();
                                }, inst.id);
                            };
                            btnRow.appendChild(linkBtn);
                        }

                        const sel = createTypeFilterDropdown(f, inst, false);
                        btnRow.appendChild(sel);
                        control.appendChild(btnRow);
                    } else if (f.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) {
                        const addRow = document.createElement('div');
                        addRow.style.display = 'flex';
                        addRow.style.gap = '6px';
                        addRow.style.marginTop = '6px';

                        const moveBtn = document.createElement('button');
                        moveBtn.className = 'btn small primary';
                        moveBtn.textContent = '‚Ü™Ô∏è Move Instance Here';
                        moveBtn.title = 'Move an orphan or instance here';
                        moveBtn.onclick = () => {
                            showInstancePicker(f.blueprintTypeFilter, (selectedId) => {
                                pushUndo();
                                const result = moveInstance(selectedId, inst.id, f.id);
                                if (!result.success) {
                                    alert('Move failed: ' + result.error);
                                } else {
                                    console.log(`Moved instance ${selectedId.slice(0, 8)} to ${inst.id.slice(0, 8)}.${f.name}`);
                                }
                                save();
                                renderAll();
                            }, inst.id, false);  // showOnlyOrphans = true
                        };
                        addRow.appendChild(moveBtn);

                        const addSel = createTypeFilterDropdown(f, inst, true);
                        addRow.appendChild(addSel);
                        control.appendChild(addRow);
                    }
                }

                row.appendChild(label);
                row.appendChild(control);
                body.appendChild(row);
            }

            card.appendChild(body);
            return card;
        }



        // ============================================================================
        // ORPHAN CLEANUP
        // ============================================================================

        /**
         * Delete all orphaned instances from the registry.
         * Orphaned instances exist in registry but are unreachable from root.
         */
        function cleanupOrphans() {
            const reachable = collectReachableInstances();
            const orphans = Object.keys(state.instances).filter(id =>
                id !== state.rootInstanceId && !reachable.has(id)
            );

            if (orphans.length === 0) {
                alert('‚úÖ No orphaned instances found!\n\nThe registry is clean.');
                return;
            }

            // Show orphan details
            const orphanDetails = orphans.map(id => {
                const inst = state.instances[id];
                const blueprint = findBlueprintById(inst.templateId);
                return `  ‚Ä¢ ${blueprint?.name || 'Unknown'} (${id.slice(0, 8)})`;
            }).join('\n');

            const confirmMsg =
                `Found ${orphans.length} orphaned instance(s):\n\n${orphanDetails}\n\n` +
                `Delete these instances?\n\n` +
                `‚ö†Ô∏è This cannot be undone (except via Undo).`;

            if (confirm(confirmMsg)) {
                pushUndo();
                const deletedIds = new Set(orphans);
                orphans.forEach(id => delete state.instances[id]);

                // CRITICAL: Clean up references to deleted instances
                cleanupReferences(deletedIds);

                save();
                renderAll();
                alert(`‚úÖ Deleted ${orphans.length} orphaned instance(s).`);
            }
        }

        // ============================================================================
        // EVENT HANDLERS (HARDENED)
        // ============================================================================

        document.getElementById('newBlueprintBtn').addEventListener('click', () => {
            const t = createBlueprint('New', 'Generic');
            navigateTo('blueprint', t.id);
        });

        document.getElementById('exportBtn').addEventListener('click', exportJSON);

        document.getElementById('importBtn').addEventListener('click', () =>
            document.getElementById('fileInput').click()
        );

        document.getElementById('fileInput').addEventListener('change', (ev) => {
            const f = ev.target.files[0];
            if (f) importJSONFile(f);
            ev.target.value = '';
        });

        document.getElementById('resetBtn').addEventListener('click', reset);

        document.getElementById('undoBtn').addEventListener('click', () => undo());

        document.getElementById('redoBtn').addEventListener('click', () => redo());

        document.getElementById('backBtn').addEventListener('click', () => navigateBack());

        document.getElementById('forwardBtn').addEventListener('click', () => navigateForward());

        document.getElementById('cleanupOrphansBtn').addEventListener('click', () => {
            cleanupOrphans();
        });

        // HARDENING: Enhanced validation display
        document.getElementById('validateBtn').addEventListener('click', () => {
            const result = validateState();
            lastValidationResult = result;

            const msg = [];

            if (result.valid) {
                msg.push('‚úÖ VALIDATION PASSED!\n\nNo errors found.');
                validationWarningsVisible = false;
            } else {
                msg.push('‚ùå VALIDATION FAILED\n');
                msg.push(`Found ${result.errors.length} error(s)\n`);
                msg.push('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
                msg.push('ERRORS:\n');
                msg.push(result.errors.slice(0, 15).join('\n'));
                if (result.errors.length > 15) {
                    msg.push(`\n... and ${result.errors.length - 15} more errors`);
                }
                validationWarningsVisible = true;
            }

            if (result.warnings.length > 0) {
                msg.push('\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
                msg.push(`WARNINGS (${result.warnings.length}):\n`);
                msg.push(result.warnings.slice(0, 10).join('\n'));
                if (result.warnings.length > 10) {
                    msg.push(`\n... and ${result.warnings.length - 10} more warnings`);
                }
            }

            // HARDENING: Additional integrity checks
            const reachable = collectReachableInstances();
            const registryIds = Object.keys(state.instances);
            const orphaned = registryIds.filter(id => id !== state.rootInstanceId && !reachable.has(id));

            if (orphaned.length > 0) {
                msg.push('\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');
                msg.push(`ORPHANED INSTANCES: ${orphaned.length}\n`);
                msg.push('(Instances in registry but unreachable from root)\n');
                msg.push(orphaned.slice(0, 5).map(id => `  ‚Ä¢ ${id.slice(0, 8)}`).join('\n'));
                if (orphaned.length > 5) {
                    msg.push(`\n  ... and ${orphaned.length - 5} more`);
                }
            }

            alert(msg.join('\n'));
            renderAll();
        });

        el.templateSearch.addEventListener('input', () => renderLibrary());

        el.verboseToggle.addEventListener('change', () => {
            verboseMode = el.verboseToggle.checked;
            renderHierarchy();
        });

        // HARDENING: Keyboard shortcuts
        window.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'y' || (e.shiftKey && e.key.toLowerCase() === 'z'))) {
                e.preventDefault();
                redo();
            }
            if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 's') {
                e.preventDefault();
                save();
                alert('Saved');
            }
            if (e.altKey && e.key === 'ArrowLeft') {
                e.preventDefault();
                navigateBack();
            }
            if (e.altKey && e.key === 'ArrowRight') {
                e.preventDefault();
                navigateForward();
            }
            // HARDENING: Ctrl+Shift+V for validation
            if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'v') {
                e.preventDefault();
                document.getElementById('validateBtn').click();
            }
        });

        // HARDENING: Drag & Drop for instance moves
        document.addEventListener('dragover', (e) => {
            // Allow drop on specific targets only
            e.preventDefault();
        });

        document.addEventListener('drop', (e) => {
            e.preventDefault();

            try {
                const data = JSON.parse(e.dataTransfer.getData('text/plain'));

                // HARDENING: Only handle instance moves, never blueprints
                if (data.type !== 'instance-move') {
                    return;
                }

                // HARDENING: Implement explicit move validation
                // For now, drag & drop in tree is disabled for safety
                // User must use explicit "Move" operations if we add them
                console.log('Drag & drop moves disabled for integrity. Use explicit move operations.');

            } catch (err) {
                // Invalid drag data, ignore
            }
        });

        // HARDENING: Detailed duplicate analysis
        function analyzeDuplicates() {
            console.group('Duplicate Analysis');

            // Check registry
            const registryIds = Object.keys(state.instances);
            console.log('Registry IDs:', registryIds);
            console.log('Registry size:', registryIds.length);
            console.log('Unique registry IDs:', new Set(registryIds).size);

            // Check for object identity duplicates (same UUID, different objects)
            const idToObjects = {};
            for (const id in state.instances) {
                const inst = state.instances[id];
                if (!idToObjects[inst.id]) {
                    idToObjects[inst.id] = [];
                }
                idToObjects[inst.id].push(inst);
            }

            const identityDuplicates = [];
            for (const id in idToObjects) {
                if (idToObjects[id].length > 1) {
                    identityDuplicates.push({
                        id: id,
                        count: idToObjects[id].length,
                        objects: idToObjects[id]
                    });
                }
            }

            if (identityDuplicates.length > 0) {
                console.error('Identity duplicates found:', identityDuplicates);
            } else {
                console.log('‚úÖ No identity duplicates');
            }

            console.groupEnd();
        }

        // ============================================================================
        // RESIZABLE PANELS
        // ============================================================================

        function initResizablePanels() {
            const STORAGE_KEY_WIDTHS = 'DharmaForge_panelWidths';

            const leftPane = document.querySelector('.pane.left');
            const rightPane = document.querySelector('.pane.right');
            const dividerLeft = document.getElementById('divider-left');
            const dividerRight = document.getElementById('divider-right');
            const mainContainer = document.querySelector('main');

            // Load saved widths or use defaults
            let leftWidth = 410;
            let rightWidth = 220;

            try {
                const saved = localStorage.getItem(STORAGE_KEY_WIDTHS);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    leftWidth = parsed.left || leftWidth;
                    rightWidth = parsed.right || rightWidth;
                }
            } catch (e) {
                console.warn('Could not load panel widths:', e);
            }

            // Apply loaded widths
            mainContainer.style.setProperty('--left-width', leftWidth + 'px');
            mainContainer.style.setProperty('--right-width', rightWidth + 'px');

            // Save widths to localStorage
            function saveWidths() {
                try {
                    localStorage.setItem(STORAGE_KEY_WIDTHS, JSON.stringify({
                        left: leftWidth,
                        right: rightWidth
                    }));
                } catch (e) {
                    console.warn('Could not save panel widths:', e);
                }
            }

            // Left divider (resizes left pane)
            let isDraggingLeft = false;
            let startXLeft = 0;
            let startWidthLeft = 0;

            dividerLeft.addEventListener('mousedown', (e) => {
                isDraggingLeft = true;
                startXLeft = e.clientX;
                startWidthLeft = leftWidth;
                document.body.classList.add('resizing');
                e.preventDefault();
            });

            // Right divider (resizes right pane)
            let isDraggingRight = false;
            let startXRight = 0;
            let startWidthRight = 0;

            dividerRight.addEventListener('mousedown', (e) => {
                isDraggingRight = true;
                startXRight = e.clientX;
                startWidthRight = rightWidth;
                document.body.classList.add('resizing');
                e.preventDefault();
            });

            // Global mouse move handler
            document.addEventListener('mousemove', (e) => {
                if (isDraggingLeft) {
                    const delta = e.clientX - startXLeft;
                    const newWidth = Math.max(200, Math.min(800, startWidthLeft + delta));
                    leftWidth = newWidth;
                    mainContainer.style.setProperty('--left-width', newWidth + 'px');
                } else if (isDraggingRight) {
                    const delta = startXRight - e.clientX; // Reversed for right pane
                    const newWidth = Math.max(180, Math.min(600, startWidthRight + delta));
                    rightWidth = newWidth;
                    mainContainer.style.setProperty('--right-width', newWidth + 'px');
                }
            });

            // Global mouse up handler
            document.addEventListener('mouseup', () => {
                if (isDraggingLeft || isDraggingRight) {
                    document.body.classList.remove('resizing');
                    saveWidths();
                    isDraggingLeft = false;
                    isDraggingRight = false;
                }
            });
        }

        // ============================================================================
        // BOOT (HARDENED)
        // ============================================================================

        (function boot() {
            console.log('DharmaForge v1.0 - Booting...');

            // Initialize resizable panels
            initResizablePanels();

            const ok = load();

            for (const blueprint of state.blueprints) {
                for (const field of blueprint.fields) {
                    if ((field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE ||
                        field.fieldKind === FIELD_KIND.INSTANCE_REFERENCE_LIST ||
                        field.fieldKind === FIELD_KIND.INSTANTIATOR ||
                        field.fieldKind === FIELD_KIND.INSTANTIATOR_LIST) &&
                        field.blueprintTypeFilter &&
                        (!field.allowedTemplateIds || field.allowedTemplateIds.length === 0)) {

                        // Populate allowedTemplateIds from type filter
                        field.allowedTemplateIds = state.blueprints
                            .filter(bp => bp.type === field.blueprintTypeFilter)
                            .map(bp => bp.id);

                        console.log(`Migrated field ${field.name}: type "${field.blueprintTypeFilter}" ‚Üí ${field.allowedTemplateIds.length} blueprints`);
                    }
                }
            }
            save();

            if (!ok) {
                console.log('No saved state, initializing sample data...');
                initSampleIfEmpty();
                // HARDENING: Do NOT call migrateState on fresh init
            } else {
                if (!state.rootInstanceId) {
                    console.warn('Loaded state has no root, initializing...');
                    initSampleIfEmpty();
                } else {
                    migrateState(state); // Only migrate loaded state
                }

                // HARDENING: Auto-validate on boot
                console.log('Running integrity validation on boot...');
                const validation = validateState();
                // ... validation logic
            }

            // HARDENING: Check for duplicate IDs
            const duplicates = findDuplicateIds();
            if (duplicates.length > 0) {
                console.error('‚ö†Ô∏è BOOT: Duplicate instance IDs detected:', duplicates);
            }

            if (state.rootInstanceId) {
                navigateTo('instance', state.rootInstanceId, false);
            }

            analyzeDuplicates();
            scroll
            renderAll();
            updateUndoButtons();
            updateNavButtons();

            console.log('DharmaForge v1.0 - Ready');
        })();  // End of boot()

        // MANUAL
        const MANUAL_HTML = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DharmaForge User Manual</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }

        .manual-container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-height: 100vh;
        }

        .manual-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .manual-header h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .manual-header p {
            opacity: 0.9;
            font-size: 1rem;
        }

        .close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            color: white;
            padding: 0.5rem 1.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s;
        }

        .close-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: translateY(-1px);
        }

        .toc {
            background: #f8f9fa;
            padding: 2rem;
            border-bottom: 2px solid #e0e0e0;
        }

        .toc h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #667eea;
        }

        .toc ol {
            list-style: none;
            counter-reset: toc-counter;
        }

        .toc li {
            counter-increment: toc-counter;
            margin-bottom: 0.5rem;
        }

        .toc li a {
            color: #333;
            text-decoration: none;
            display: block;
            padding: 0.5rem;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .toc li a:before {
            content: counter(toc-counter) ". ";
            font-weight: 600;
            color: #667eea;
            margin-right: 0.5rem;
        }

        .toc li a:hover {
            background: white;
            color: #667eea;
            transform: translateX(4px);
        }

        .manual-content {
            padding: 2rem;
        }

        .section {
            margin-bottom: 3rem;
            scroll-margin-top: 80px;
        }

        .section h2 {
            font-size: 1.8rem;
            color: #667eea;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid #667eea;
        }

        .section h3 {
            font-size: 1.3rem;
            color: #764ba2;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        .section h4 {
            font-size: 1.1rem;
            color: #555;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
        }

        .section p {
            margin-bottom: 1rem;
        }

        .section ul, .section ol {
            margin-left: 2rem;
            margin-bottom: 1rem;
        }

        .section li {
            margin-bottom: 0.5rem;
        }

        code {
            background: #f5f5f5;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #d63384;
        }

        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            margin-bottom: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .callout {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 4px;
        }

        .callout.warning {
            background: #fff3cd;
            border-left-color: #ffc107;
        }

        .callout.danger {
            background: #f8d7da;
            border-left-color: #dc3545;
        }

        .callout.success {
            background: #d4edda;
            border-left-color: #28a745;
        }

        .callout strong {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 1.05em;
        }

        .example {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 1rem;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .example-title {
            font-weight: 600;
            color: #764ba2;
            margin-bottom: 0.5rem;
        }

        .emoji {
            font-style: normal;
        }

        strong {
            color: #667eea;
        }

        a {
            color: #667eea;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        hr {
            border: none;
            border-top: 2px solid #e0e0e0;
            margin: 2rem 0;
        }

        @media (max-width: 768px) {
            .manual-header h1 {
                font-size: 1.5rem;
            }

            .close-btn {
                position: static;
                display: block;
                margin-top: 1rem;
            }

            .manual-content {
                padding: 1rem;
            }

            .section h2 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="manual-container">
        <div class="manual-header">
            <h1>DharmaForge User Manual</h1>
            <p>Complete guide to building your own knowledge structures</p>
            <button class="close-btn">Close</button>
        </div>

        <div class="toc">
            <h2>Table of Contents</h2>
            <ol>
                <li><a href="#what-is-dharmaforge">What is DharmaForge?</a></li>
                <li><a href="#core-concepts">Core Concepts</a></li>
                <li><a href="#getting-started">Getting Started Tutorial</a></li>
                <li><a href="#blueprint-library">Blueprint Library</a></li>
                <li><a href="#instance-hierarchy">Instance Hierarchy</a></li>
                <li><a href="#field-types">Field Types Deep Dive</a></li>
                <li><a href="#references-ownership">References & Ownership</a></li>
                <li><a href="#error-indicators">Error Indicators</a></li>
                <li><a href="#advanced-operations">Advanced Operations</a></li>
                <li><a href="#shortcuts">Keyboard Shortcuts</a></li>
                <li><a href="#workflows">Common Workflows</a></li>
                <li><a href="#troubleshooting">Troubleshooting</a></li>
            </ol>
        </div>

        <div class="manual-content">
            <section class="section" id="what-is-dharmaforge">
                <h2>1. What is DharmaForge?</h2>
                
                <p>DharmaForge is a visual programming tool for building custom knowledge structures. Unlike traditional apps that force you into their structure (pages, folders, tables), DharmaForge lets you <strong>define your own structure</strong>, then use it.</p>

                <div class="callout">
                    <strong>Think of it like:</strong>
                    <ul>
                        <li>LEGO for information - you define the pieces and how they connect</li>
                        <li>A spreadsheet where you design the columns yourself</li>
                        <li>A database you can see and touch</li>
                    </ul>
                </div>

                <p><strong>The core idea:</strong> You build templates (called <strong>blueprints</strong>), create things from those templates (called <strong>instances</strong>), and link them together. Your structure becomes your tool.</p>

                <p><strong>The philosophy:</strong> DharmaForge shows you everything and fixes nothing automatically. If something breaks, you'll see it (red boxes). If something's wrong, you'll fix it. No hand-holding, no surprises, total control.</p>
            </section>

            <section class="section" id="core-concepts">
                <h2>2. Core Concepts</h2>

                <h3>Blueprints</h3>
                <p><strong>Templates that define types of things.</strong></p>
                <p>Think of blueprints as cookie cutters. They define what shape instances will have, but they're not the actual cookies.</p>
                <p>Examples: "Character," "Quest," "Project," "Note"</p>
                <p>Each blueprint has:</p>
                <ul>
                    <li>A <strong>name</strong> (what it's called)</li>
                    <li>A <strong>type</strong> (a category like "Card" or "Task")</li>
                    <li><strong>Fields</strong> (the properties instances will have)</li>
                </ul>

                <h3>Instances</h3>
                <p><strong>The actual things you create from blueprints.</strong></p>
                <p>If blueprints are cookie cutters, instances are the cookies. Each instance is based on a blueprint and has values for all its fields.</p>
                <p>Examples: "Bob" (a Character), "Save the Princess" (a Quest), "My Novel" (a Project)</p>

                <h3>Fields</h3>
                <p><strong>Properties that blueprints have and instances fill in.</strong></p>
                <p>Fields define what information each instance stores. There are 5 types:</p>
                <ol>
                    <li><strong>Primitive</strong> - Simple data (text, numbers)</li>
                    <li><strong>Instantiator</strong> - Contains ONE owned child instance</li>
                    <li><strong>Instantiator List</strong> - Contains MULTIPLE owned child instances</li>
                    <li><strong>Instance Reference</strong> - Links to ONE other instance (doesn't own it)</li>
                    <li><strong>Instance Reference List</strong> - Links to MULTIPLE other instances (doesn't own them)</li>
                </ol>

                <h3>Ownership vs References</h3>
                <p><strong>The most important concept in DharmaForge.</strong></p>

                <div class="example">
                    <div class="example-title">Ownership (instantiator fields):</div>
                    <ul>
                        <li>Instance A <strong>owns</strong> Instance B</li>
                        <li>B is a child of A</li>
                        <li>Deleting A deletes B (cascade deletion)</li>
                        <li>B appears under A in the hierarchy</li>
                        <li>Visual: Solid border</li>
                    </ul>
                </div>

                <div class="example">
                    <div class="example-title">References (instanceReference fields):</div>
                    <ul>
                        <li>Instance A <strong>references</strong> Instance B</li>
                        <li>B is independent of A</li>
                        <li>Deleting A leaves B intact (but shows broken reference)</li>
                        <li>B doesn't appear under A in hierarchy</li>
                        <li>Visual: Green dashed border, <span class="emoji">üîó</span> icon</li>
                    </ul>
                </div>

                <p><strong>Think of it like:</strong> Ownership = "contains," Reference = "points to"</p>
            </section>

            <section class="section" id="getting-started">
                <h2>3. Getting Started Tutorial</h2>
                
                <p>Let's build a simple character relationship system.</p>

                <h3>Step 1: Create Your First Blueprint</h3>
                <ol>
                    <li>Look at the right panel labeled <strong>"Blueprint Library"</strong></li>
                    <li>Click the <strong>"+ Create New Blueprint"</strong> button</li>
                    <li>A new blueprint appears with default name "Unnamed"</li>
                    <li>Click on the name and change it to <strong>"Character"</strong></li>
                    <li>In the <strong>"Type"</strong> dropdown, select <strong>"Card"</strong> (or create a new type)</li>
                </ol>

                <h3>Step 2: Add Fields to Your Blueprint</h3>
                <p>Now we'll add properties that all characters will have.</p>

                <h4>Add a Name field:</h4>
                <ol>
                    <li>Click <strong>"+ Add Field"</strong> in your Character blueprint</li>
                    <li>Change field name from "field" to <strong>"Name"</strong></li>
                    <li>Field Kind dropdown: Select <strong>"Primitive"</strong></li>
                    <li>Primitive Type dropdown: Select <strong>"Text"</strong></li>
                </ol>

                <h4>Add a Friends field:</h4>
                <ol>
                    <li>Click <strong>"+ Add Field"</strong> again</li>
                    <li>Change name to <strong>"Friends"</strong></li>
                    <li>Field Kind: Select <strong>"Instance Reference List"</strong></li>
                    <li>Type Filter: Select <strong>"Character"</strong>
                        <ul><li>This means the Friends field can only contain other Characters</li></ul>
                    </li>
                </ol>

                <h4>Add a Description field:</h4>
                <ol>
                    <li>Click <strong>"+ Add Field"</strong></li>
                    <li>Name it <strong>"Description"</strong></li>
                    <li>Field Kind: <strong>"Primitive"</strong></li>
                    <li>Primitive Type: <strong>"Text"</strong></li>
                </ol>

                <h3>Step 3: Create Instances</h3>
                <p>Now let's create actual characters.</p>
                <ol>
                    <li>In the <strong>middle panel</strong> ("Instance Hierarchy"), you'll see your root instance</li>
                    <li>Expand it by clicking the triangle (‚ñ∏)</li>
                    <li>Find a field in root that accepts Character type, or add one</li>
                    <li>In the root, click <strong>"Create new instance of [type]"</strong> dropdown</li>
                    <li>Select <strong>"Character"</strong></li>
                    <li>A new character instance appears!</li>
                </ol>

                <h4>Fill in the character:</h4>
                <ol>
                    <li>Click on the character card to expand it</li>
                    <li>In the <strong>"Name"</strong> field, type <strong>"Alice"</strong></li>
                    <li>In the <strong>"Description"</strong> field, type whatever you want</li>
                    <li>Leave Friends empty for now</li>
                </ol>

                <h4>Create more characters:</h4>
                <ol>
                    <li>Create another Character instance named <strong>"Bob"</strong></li>
                    <li>Create a third named <strong>"Carol"</strong></li>
                </ol>

                <h3>Step 4: Link Characters Together</h3>
                <p>Now let's make Alice friends with Bob.</p>
                <ol>
                    <li>Click on Alice's card to view it</li>
                    <li>Find the <strong>"Friends"</strong> field (it's an Instance Reference List)</li>
                    <li>Click the <strong>"üîó Link Instance"</strong> button</li>
                    <li>A picker appears showing all Character instances</li>
                    <li>Click <strong>"Bob"</strong></li>
                    <li>Bob appears as a blue chip in Alice's Friends field!</li>
                </ol>

                <h4>Try the other direction:</h4>
                <ol>
                    <li>Click on Bob's card</li>
                    <li>In Bob's Friends field, link to Alice</li>
                    <li>Now they're mutual friends!</li>
                </ol>

                <h4>See the reference in action:</h4>
                <ol>
                    <li>Click the <strong>triangle (‚ñ∏)</strong> on Bob's chip in Alice's Friends field</li>
                    <li>Bob's full card appears inline - you can see all his info!</li>
                    <li>Click the triangle again to collapse it</li>
                </ol>

                <h3>Step 5: Understanding Ownership</h3>
                <p>Let's see the difference between ownership and references.</p>

                <h4>Create an owned child:</h4>
                <ol>
                    <li>Add a new field to Character blueprint called <strong>"Inventory"</strong></li>
                    <li>Field Kind: <strong>"Instantiator List"</strong> (note: not Reference List)</li>
                    <li>Type Filter: Create a new blueprint called <strong>"Item"</strong> and select it</li>
                    <li>Now create an Item instance inside Alice's Inventory</li>
                    <li>This Item is <strong>owned by Alice</strong> - if you delete Alice, it gets deleted too</li>
                </ol>

                <h4>Compare to references:</h4>
                <ul>
                    <li>Alice's Friends are <strong>references</strong> - if you delete Alice, Bob and Carol still exist</li>
                    <li>Alice's Inventory items are <strong>owned</strong> - if you delete Alice, her items get deleted</li>
                    <li>Visual difference: Inventory shows solid border, Friends shows green dashed border</li>
                </ul>
            </section>

            <section class="section" id="blueprint-library">
                <h2>4. Blueprint Library (Right Panel)</h2>

                <h3>Creating Blueprints</h3>
                <p><strong>"+ Create New Blueprint" button:</strong></p>
                <ul>
                    <li>Creates a new blueprint with default name "Unnamed"</li>
                    <li>Type defaults to "Generic"</li>
                    <li>Has no fields initially</li>
                </ul>

                <p><strong>Blueprint properties:</strong></p>
                <ul>
                    <li><strong>Name:</strong> What you call this blueprint (e.g., "Character")</li>
                    <li><strong>Type:</strong> A category for filtering (e.g., "Card," "Task," "Note")</li>
                    <li><strong>Is Static:</strong> Advanced - makes this blueprint a singleton with default values</li>
                </ul>

                <h3>Editing Blueprint Fields</h3>
                <p><strong>"+ Add Field" button:</strong></p>
                <ul>
                    <li>Adds a new field to the blueprint</li>
                    <li>All instances of this blueprint immediately get this field</li>
                </ul>

                <p><strong>Field properties:</strong></p>
                <ul>
                    <li><strong>Name:</strong> What you call this field (shows in instances)</li>
                    <li><strong>Field Kind:</strong> What type of data (see Field Types section)</li>
                    <li><strong>Type Filter:</strong> For instantiator/reference fields, which blueprint types are allowed</li>
                    <li><strong>Primitive Type:</strong> For primitive fields, whether it's text or number</li>
                </ul>

                <p><strong>Reordering fields:</strong></p>
                <ul>
                    <li>Drag the <strong>‚ò∞</strong> handle on the left of each field</li>
                    <li>Drop it above or below other fields</li>
                    <li>All instances update to match the new order</li>
                </ul>

                <p><strong>Deleting fields:</strong></p>
                <ul>
                    <li>Click the red <strong>√ó</strong> button on the right</li>
                    <li>Warns you if instances have data in this field</li>
                    <li>All instance data for this field is lost</li>
                </ul>

                <h3>Changing Field Types</h3>
                <div class="callout warning">
                    <strong>Warning system:</strong>
                    <p>When you change a field's type (e.g., from text to instantiator), DharmaForge shows a comprehensive warning:</p>
                    <ul>
                        <li>How many instances will be affected</li>
                        <li>How many owned instances will be deleted (if changing from instantiator)</li>
                        <li>How many references will break (if others reference the deleted instances)</li>
                        <li>Full list of consequences</li>
                    </ul>
                    <p><strong>You must explicitly confirm</strong> - DharmaForge won't make assumptions.</p>
                </div>

                <h3>Blueprint Issues Indicators</h3>
                <p>In the Blueprint Library header, you may see:</p>
                <ul>
                    <li><strong><span class="emoji">üü°</span> [number]</strong> - Warnings (unselected type filters)</li>
                    <li><strong><span class="emoji">üî¥</span> [number]</strong> - Errors (fields reference non-existent blueprint types)</li>
                </ul>
                <p>Click <strong>"Show Blueprint Issues"</strong> to see details.</p>

                <h3>Deleting Blueprints</h3>
                <div class="callout danger">
                    <strong>Red √ó button next to blueprint name:</strong>
                    <ul>
                        <li>Warns if instances exist using this blueprint</li>
                        <li>Deleting a blueprint deletes ALL its instances (cascade deletion)</li>
                        <li>Shows how many instances will be deleted</li>
                        <li>Cannot be undone (except via Undo button)</li>
                    </ul>
                </div>
            </section>

            <section class="section" id="instance-hierarchy">
                <h2>5. Instance Hierarchy (Left Panel)</h2>

                <h3>Understanding the Hierarchy</h3>
                <p>The hierarchy shows your <strong>ownership tree</strong> - which instances contain which other instances.</p>

                <p><strong>Visual indicators:</strong></p>
                <ul>
                    <li><strong>‚ñ∏/‚ñæ</strong> - Expand/collapse to show children</li>
                    <li><strong>Solid border</strong> - Owned child (lives here)</li>
                    <li><strong>Green dashed border + üîó</strong> - Referenced child (linked from elsewhere)</li>
                    <li><strong><span class="emoji">üî¥</span> [number]</strong> - Error count (broken references)</li>
                    <li><strong><span class="emoji">‚ö†Ô∏è</span> [number]</strong> - Warning count (orphaned references)</li>
                </ul>

                <h3>Navigation</h3>
                <p><strong>Back/Forward buttons (‚óÄ ‚ñ∂):</strong></p>
                <ul>
                    <li>Navigate through your viewing history</li>
                    <li>Like a web browser's back/forward buttons</li>
                    <li>Keyboard: Alt+Left, Alt+Right</li>
                </ul>

                <p><strong>Clicking instances:</strong></p>
                <ul>
                    <li>Selects the instance</li>
                    <li>Shows it in the Workspace (middle panel)</li>
                    <li>Updates the breadcrumb path</li>
                </ul>

                <h3>Hierarchy Controls</h3>
                <p><strong>"Verbose Hierarchy" checkbox:</strong></p>
                <ul>
                    <li>OFF: Shows <code>"Bob (Character)"</code> ‚Üí <code>"Carol (Character)"</code></li>
                    <li>ON: Shows <code>"Bob (Character)"</code> ‚Üí <code>"Friends (instanceReferenceList)"</code> ‚Üí <code>"Carol (Character)"</code></li>
                    <li>Useful for understanding exact field relationships</li>
                </ul>
            </section>

            <section class="section" id="field-types">
                <h2>6. Field Types Deep Dive</h2>

                <h3>1. Primitive Fields</h3>
                <p><strong>What they do:</strong> Store simple data like text or numbers</p>
                <p><strong>Properties:</strong></p>
                <ul>
                    <li>Primitive Type: Text or Number</li>
                    <li>No type filter needed</li>
                </ul>
                <p><strong>When to use:</strong></p>
                <ul>
                    <li>Names, descriptions, dates</li>
                    <li>Quantities, prices, scores</li>
                    <li>Any simple data that doesn't relate to other instances</li>
                </ul>

                <h3>2. Instantiator (Single)</h3>
                <p><strong>What it does:</strong> Contains exactly ONE owned child instance</p>
                <p><strong>When to use:</strong></p>
                <ul>
                    <li>One-to-one ownership relationships</li>
                    <li>"Project has a Lead Designer"</li>
                    <li>"Character has a Home Location"</li>
                </ul>
                <p><strong>Behavior:</strong></p>
                <ul>
                    <li>Child instance is OWNED by parent</li>
                    <li>Deleting parent deletes child (cascade)</li>
                    <li>Child appears in hierarchy under parent</li>
                    <li>Moving child removes it from old parent</li>
                </ul>
                <p><strong>Operations available:</strong></p>
                <ul>
                    <li><strong>Create new instance:</strong> Instantiate a new child</li>
                    <li><strong>Move Instance Here:</strong> Take ownership of an existing instance</li>
                    <li><strong>Link Instance:</strong> Reference an existing instance (makes it a reference, not owned)</li>
                </ul>

                <h3>3. Instantiator List</h3>
                <p><strong>What it does:</strong> Contains MULTIPLE owned child instances</p>
                <p><strong>When to use:</strong></p>
                <ul>
                    <li>One-to-many ownership relationships</li>
                    <li>"Project has Tasks"</li>
                    <li>"Character has Inventory Items"</li>
                    <li>"Quest has Sub-Quests"</li>
                </ul>
                <p><strong>Behavior:</strong></p>
                <ul>
                    <li>All child instances are OWNED by parent</li>
                    <li>Deleting parent deletes all children (cascade)</li>
                    <li>Children appear in hierarchy under parent</li>
                    <li>Can reorder children via drag-and-drop</li>
                </ul>

                <h3>4. Instance Reference (Single)</h3>
                <p><strong>What it does:</strong> Links to exactly ONE other instance (doesn't own it)</p>
                <p><strong>When to use:</strong></p>
                <ul>
                    <li>Relationships between independent things</li>
                    <li>"Character has a Best Friend" (but doesn't own them)</li>
                    <li>"Task references a Related Project" (but doesn't contain it)</li>
                </ul>
                <p><strong>Behavior:</strong></p>
                <ul>
                    <li>Referenced instance is NOT owned</li>
                    <li>Deleting parent leaves child intact</li>
                    <li>Reference shows as blue chip (expandable)</li>
                    <li>If referenced instance is deleted, shows <span class="emoji">üî¥</span> red "broken reference"</li>
                    <li>If referenced instance is orphaned, shows <span class="emoji">‚ö†Ô∏è</span> yellow "orphaned reference"</li>
                </ul>

                <h3>5. Instance Reference List</h3>
                <p><strong>What it does:</strong> Links to MULTIPLE other instances (doesn't own them)</p>
                <p><strong>When to use:</strong></p>
                <ul>
                    <li>Many-to-many relationships</li>
                    <li>"Character has Friends" (but doesn't own them)</li>
                    <li>"Project has Contributors" (who exist independently)</li>
                    <li>"Quest requires Items" (that exist in the world)</li>
                </ul>
                <p><strong>Behavior:</strong></p>
                <ul>
                    <li>Referenced instances are NOT owned</li>
                    <li>Deleting parent leaves children intact</li>
                    <li>References show as blue chips (expandable)</li>
                    <li>Can reorder references via drag-and-drop</li>
                    <li>Broken/orphaned references show <span class="emoji">üî¥</span>/<span class="emoji">‚ö†Ô∏è</span></li>
                </ul>
            </section>

            <section class="section" id="references-ownership">
                <h2>7. References & Ownership</h2>

                <h3>The Fundamental Distinction</h3>
                <div class="example">
                    <div class="example-title">Ownership (instantiator):</div>
                    <pre>A owns B means:
- B exists because of A
- B lives under A in hierarchy
- Deleting A deletes B
- B has ONE parent (A)</pre>
                </div>

                <div class="example">
                    <div class="example-title">References (instanceReference):</div>
                    <pre>A references B means:
- B exists independently
- B doesn't appear under A in hierarchy
- Deleting A leaves B intact (but reference breaks)
- B can be referenced by MANY things</pre>
                </div>

                <h3>Visual Indicators</h3>
                <p><strong>In the hierarchy:</strong></p>
                <ul>
                    <li>Owned children: Solid border, indented under parent</li>
                    <li>Referenced children: Green dashed border + üîó, indented but marked</li>
                </ul>

                <p><strong>In instance cards:</strong></p>
                <ul>
                    <li>Instantiator fields: Show children inline with solid borders</li>
                    <li>Reference fields: Show blue chips that expand to show content</li>
                </ul>

                <h3>The "Link Instance" Subtlety</h3>
                <div class="callout warning">
                    <strong>Important:</strong> When you use "Link Instance" in an instantiator field, you're creating a <strong>reference</strong>, not ownership!
                    <p><strong>To create owned children in instantiator fields:</strong></p>
                    <ul>
                        <li>Use "Create new instance" (instantiates owned child)</li>
                        <li>Use "Move Instance Here" (transfers ownership)</li>
                    </ul>
                </div>
            </section>

            <section class="section" id="error-indicators">
                <h2>8. Error Indicators</h2>

                <h3>Red (<span class="emoji">üî¥</span>) - Broken References</h3>
                <p><strong>What it means:</strong> A field contains an ID of an instance that no longer exists</p>
                <p><strong>Where you'll see it:</strong></p>
                <ul>
                    <li>Red box in instance cards: <code>üî¥ Instance abc12345 (deleted) [√ó]</code></li>
                    <li>Red chip in reference fields: <code>üî¥ abc12345 (deleted) [√ó]</code></li>
                    <li>Red number in hierarchy: <code>üî¥ 2</code> (count of broken references)</li>
                </ul>
                <p><strong>What to do:</strong></p>
                <ul>
                    <li>Click the <strong>√ó</strong> button on each red box/chip to clear it</li>
                    <li>Or leave it there as an audit trail (you can see what was deleted)</li>
                    <li>No automatic cleanup - you must explicitly clear each one</li>
                </ul>

                <h3>Yellow (<span class="emoji">‚ö†Ô∏è</span>) - Orphaned References</h3>
                <p><strong>What it means:</strong> A field contains an ID of an instance that exists but is unreachable from root</p>
                <p><strong>Where you'll see it:</strong></p>
                <ul>
                    <li>Yellow box in instance cards: <code>‚ö†Ô∏è Instance abc12345 (orphaned) [√ó]</code></li>
                    <li>Yellow chip in reference fields: <code>‚ö†Ô∏è abc12345 (orphaned) [√ó]</code></li>
                    <li>Yellow number in hierarchy: <code>‚ö†Ô∏è 1</code> (count of orphaned references)</li>
                </ul>
                <p><strong>What to do:</strong></p>
                <ul>
                    <li>Click <strong>"Clean Orphans"</strong> button (top right) to delete orphans</li>
                    <li>After cleaning, orphaned references become broken (turn red)</li>
                    <li>Then clear the broken references (√ó) as above</li>
                </ul>
            </section>

            <section class="section" id="advanced-operations">
                <h2>9. Advanced Operations</h2>

                <h3>Move Instance</h3>
                <p><strong>What it does:</strong> Transfers ownership of an instance from one parent to another</p>
                <p><strong>How to use:</strong></p>
                <ol>
                    <li>In an instantiator field, click <strong>"‚Ü™Ô∏è Move Instance Here"</strong></li>
                    <li>Picker shows all instances (filters by type if type filter is set)</li>
                    <li>Select an instance</li>
                    <li>That instance is removed from old parent and moved here</li>
                    <li>Becomes owned child of new parent</li>
                </ol>

                <h3>Link Instance</h3>
                <p><strong>What it does:</strong> Creates a reference to an existing instance (without ownership)</p>
                <p><strong>How to use:</strong></p>
                <ol>
                    <li>In any instantiator or reference field, click <strong>"üîó Link Instance"</strong></li>
                    <li>Picker shows all instances (filters by type if type filter is set)</li>
                    <li>Select an instance</li>
                    <li>Instance appears as a reference (green border if in instantiator field, blue chip if in reference field)</li>
                </ol>

                <h3>Expandable Reference Chips</h3>
                <p><strong>What they do:</strong> Let you view referenced instances inline without navigating away</p>
                <p><strong>How to use:</strong></p>
                <ol>
                    <li>Find a blue chip (in reference fields)</li>
                    <li>Click the <strong>‚ñ∏</strong> triangle on the left</li>
                    <li>The full instance card appears inline below the chip</li>
                    <li>You can view all fields, even edit them</li>
                    <li>Click <strong>‚ñæ</strong> to collapse it again</li>
                </ol>

                <h3>Cascade Deletion</h3>
                <p><strong>What it does:</strong> When you delete an instance, all its owned children are deleted too</p>
                <div class="callout danger">
                    <strong>Important notes:</strong>
                    <ul>
                        <li>Only affects OWNED children (via instantiator fields)</li>
                        <li>Does NOT delete referenced instances (via instanceReference fields)</li>
                        <li>Recursive: deletes children, grandchildren, great-grandchildren, etc.</li>
                        <li>Cannot be undone (except via Undo button)</li>
                    </ul>
                </div>

                <h3>Orphan Detection & Cleanup</h3>
                <p><strong>What are orphans?</strong> Instances that exist in the registry but are unreachable from root.</p>
                <p><strong>How to clean them:</strong></p>
                <ol>
                    <li>Click <strong>"Clean Orphans"</strong> button (top right)</li>
                    <li>DharmaForge scans for unreachable instances</li>
                    <li>Shows count and IDs</li>
                    <li>Click "Delete Orphans" to remove them</li>
                    <li>References to orphans turn broken (<span class="emoji">üî¥</span> red)</li>
                </ol>
            </section>

            <section class="section" id="shortcuts">
                <h2>10. Keyboard Shortcuts</h2>

                <h3>Navigation</h3>
                <ul>
                    <li><strong>Ctrl+Z</strong> - Undo last action</li>
                    <li><strong>Ctrl+Y</strong> - Redo last undone action</li>
                    <li><strong>Alt+Left</strong> - Navigate back (like browser back button)</li>
                    <li><strong>Alt+Right</strong> - Navigate forward (like browser forward)</li>
                </ul>

                <h3>Workflow Tips</h3>
                <ul>
                    <li><strong>Double-click instance name</strong> - Edit name inline</li>
                    <li><strong>Drag ‚ò∞ handle</strong> - Reorder fields or instances</li>
                    <li><strong>Click ‚ñ∏ triangle</strong> - Expand/collapse in hierarchy</li>
                    <li><strong>Click blue chip ‚ñ∏</strong> - Expand reference inline</li>
                </ul>
            </section>

            <section class="section" id="workflows">
                <h2>11. Common Workflows</h2>

                <h3>Worldbuilding</h3>
                <div class="example">
                    <div class="example-title">Setup:</div>
                    <pre>Blueprints:
- Character (fields: Name, Description, Friends [refList], Home [ref])
- Location (fields: Name, Description, Residents [refList])
- Quest (fields: Name, Objectives [list], NPCs [refList], Location [ref])</pre>
                </div>

                <p><strong>Workflow:</strong></p>
                <ol>
                    <li>Create all Characters as owned by root</li>
                    <li>Create all Locations as owned by root</li>
                    <li>Link Characters to Friends (mutual references)</li>
                    <li>Link Characters to Home locations</li>
                    <li>Link Locations to Residents (Characters)</li>
                    <li>Create Quests referencing Characters and Locations</li>
                    <li>Expand chips to see NPC details while writing quest</li>
                </ol>

                <h3>Project Management</h3>
                <div class="example">
                    <div class="example-title">Setup:</div>
                    <pre>Blueprints:
- Project (fields: Name, Lead [ref], Tasks [instantiatorList])
- Task (fields: Name, Status, Assignee [ref], Subtasks [instantiatorList])
- Person (fields: Name, Email, Skills)</pre>
                </div>

                <p><strong>Workflow:</strong></p>
                <ol>
                    <li>Create all People as owned by root</li>
                    <li>Create Projects as owned by root</li>
                    <li>Create Tasks INSIDE Projects (owned by Project)</li>
                    <li>Link People to Task Assignees</li>
                    <li>Link Project Lead to People</li>
                    <li>Create Subtasks inside Tasks (nested ownership)</li>
                    <li>Drag tasks to reorder priorities</li>
                </ol>

                <h3>Knowledge Graph / Zettelkasten</h3>
                <div class="example">
                    <div class="example-title">Setup:</div>
                    <pre>Blueprints:
- Note (fields: Title, Content, Related [refList], Topics [refList])
- Topic (fields: Name, Description, Notes [refList])</pre>
                </div>

                <p><strong>Workflow:</strong></p>
                <ol>
                    <li>Create Notes as owned by root (or category folders)</li>
                    <li>Create Topics as owned by root</li>
                    <li>Link Notes to Related Notes (bidirectional)</li>
                    <li>Link Notes to Topics</li>
                    <li>Link Topics to Notes</li>
                    <li>Expand chips to see related notes inline while writing</li>
                    <li>Navigate through Related references to explore connections</li>
                </ol>
            </section>

            <section class="section" id="troubleshooting">
                <h2>12. Troubleshooting</h2>

                <h3>"I can't find my instance!"</h3>
                <p><strong>Check:</strong></p>
                <ul>
                    <li>Is it collapsed in the hierarchy? Click ‚ñ∏ to expand parents</li>
                    <li>Is it orphaned? Click "Clean Orphans" to find unreachable instances</li>
                    <li>Is it referenced? Look for green dashed borders (references don't show in hierarchy at that location)</li>
                    <li>Did you delete it? Check Undo button</li>
                </ul>

                <h3>"I see red boxes everywhere!"</h3>
                <p><strong>This means:</strong> You deleted an instance that was referenced by others</p>
                <p><strong>Fix:</strong></p>
                <ul>
                    <li>Click the <strong>√ó</strong> button on each red box to clear the reference</li>
                    <li>Or use Undo (Ctrl+Z) to restore the deleted instance</li>
                    <li>Red boxes are intentional - they show you what broke</li>
                </ul>

                <h3>"I deleted something by accident!"</h3>
                <p><strong>Fix:</strong></p>
                <ol>
                    <li>Click <strong>Undo</strong> (Ctrl+Z) immediately</li>
                    <li>This restores the deleted instance and all its children</li>
                    <li>DharmaForge has unlimited undo/redo</li>
                </ol>

                <h3>"The dropdown says 'No instances available'"</h3>
                <p><strong>This means:</strong> No instances of the required type exist</p>
                <p><strong>Fix:</strong></p>
                <ul>
                    <li>Check the field's type filter (what blueprint type it expects)</li>
                    <li>Create an instance of that type first</li>
                    <li>Or change the type filter to accept more types</li>
                </ul>

                <h3>"I can't move an instance"</h3>
                <p><strong>Possible reasons:</strong></p>
                <ul>
                    <li><strong>Circular reference:</strong> Can't move A into B if B is inside A</li>
                    <li><strong>Wrong type:</strong> Type filter doesn't match instance's blueprint</li>
                    <li><strong>No parent:</strong> Instance doesn't have parent set (might be root)</li>
                    <li><strong>Already there:</strong> Instance is already in that field</li>
                </ul>

                <h3>"Yellow warnings appeared out of nowhere"</h3>
                <p><strong>This means:</strong> You have orphaned instances (unreachable from root)</p>
                <p><strong>Fix:</strong></p>
                <ol>
                    <li>Click <strong>"Clean Orphans"</strong> button</li>
                    <li>Review the list of orphans</li>
                    <li>Click "Delete Orphans" to remove them</li>
                    <li>Yellow references will turn red (broken)</li>
                    <li>Clear red references as needed</li>
                </ol>

                <h3>"I want to start over"</h3>
                <p><strong>Best practice:</strong></p>
                <ol>
                    <li>Click <strong>"Export JSON"</strong> first (backup)</li>
                    <li>Click <strong>"Reset"</strong> button (top right)</li>
                    <li>Confirms: "This will delete ALL data"</li>
                    <li>Import later if you change your mind</li>
                </ol>

                <hr>

                <h3>Final Tips</h3>
                <div class="callout success">
                    <strong>Best Practices:</strong>
                    <ul>
                        <li>Design blueprints first - Think through your structure before creating instances</li>
                        <li>Use type filters - Constrain fields to specific types for data integrity</li>
                        <li>Own sparingly, reference liberally - Use ownership only for true containment</li>
                        <li>Export regularly - Save your work as JSON files</li>
                        <li>Read warnings carefully - DharmaForge tells you exactly what will happen</li>
                        <li>Don't fear broken references - They're information (what broke, where)</li>
                    </ul>
                </div>

                <div class="callout">
                    <strong>Philosophy Reminders:</strong>
                    <ul>
                        <li>DharmaForge shows everything - No hidden state, no surprises</li>
                        <li>DharmaForge fixes nothing automatically - You're in control</li>
                        <li>Broken things stay broken - Until you explicitly fix them</li>
                        <li>Complexity is visible - Not abstracted away</li>
                    </ul>
                    <p><strong>This gives you total power. Use it wisely.</strong></p>
                </div>
            </section>
        </div>
    </div>
</body>
</html>
`;

        setTimeout(() => {
            console.log('Manual setup running...');
            const btn = document.getElementById('manualBtn');
            console.log('manualBtn found:', btn);

            if (btn) {
                console.log('Setting onclick handler...');
                btn.onclick = () => {
                    console.log('Manual button clicked!');
                    const modal = document.getElementById('manualModal');
                    const frame = document.getElementById('manualFrame');
                    console.log('Modal:', modal, 'Frame:', frame);

                    if (!modal || !frame) {
                        console.error('Modal or frame not found!');
                        return;
                    }

                    modal.style.display = 'block';
                    const doc = frame.contentDocument;
                    doc.open();
                    doc.write(MANUAL_HTML);
                    doc.close();

                    setTimeout(() => {
                        const closeBtn = doc.querySelector('.close-btn');
                        if (closeBtn) closeBtn.onclick = () => modal.style.display = 'none';
                    }, 100);

                    modal.onclick = (e) => {
                        if (e.target === modal) modal.style.display = 'none';
                    };
                };
                console.log('onclick handler set!');
            } else {
                console.error('manualBtn not found!');
            }
        }, 500);

    </script>

    <!-- Manual Modal -->
    <div id="manualModal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; overflow: auto;">
        <div style="position: relative; width: 100%; max-width: 900px; margin: 20px auto;">
            <iframe id="manualFrame"
                style="width: 100%; height: 90vh; border: none; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);"></iframe>
        </div>
    </div>

</body>

</html>